{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"./util\");\n\nvar utils_1 = require(\"../utils\");\n\nvar redis_1 = require(\"../redis\");\n\nvar debug = utils_1.Debug(\"cluster:subscriber\");\nvar SUBSCRIBER_CONNECTION_NAME = \"ioredisClusterSubscriber\";\n\nvar ClusterSubscriber =\n/*#__PURE__*/\nfunction () {\n  function ClusterSubscriber(connectionPool, emitter) {\n    var _this = this;\n\n    _classCallCheck(this, ClusterSubscriber);\n\n    this.connectionPool = connectionPool;\n    this.emitter = emitter;\n    this.started = false;\n    this.subscriber = null;\n    this.connectionPool.on(\"-node\", function (_, key) {\n      if (!_this.started || !_this.subscriber) {\n        return;\n      }\n\n      if (util_1.getNodeKey(_this.subscriber.options) === key) {\n        debug(\"subscriber has left, selecting a new one...\");\n\n        _this.selectSubscriber();\n      }\n    });\n    this.connectionPool.on(\"+node\", function () {\n      if (!_this.started || _this.subscriber) {\n        return;\n      }\n\n      debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n\n      _this.selectSubscriber();\n    });\n  }\n\n  _createClass(ClusterSubscriber, [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      return this.subscriber;\n    }\n  }, {\n    key: \"selectSubscriber\",\n    value: function selectSubscriber() {\n      var _this2 = this;\n\n      var lastActiveSubscriber = this.lastActiveSubscriber; // Disconnect the previous subscriber even if there\n      // will not be a new one.\n\n      if (lastActiveSubscriber) {\n        lastActiveSubscriber.disconnect();\n      }\n\n      var sampleNode = utils_1.sample(this.connectionPool.getNodes());\n\n      if (!sampleNode) {\n        debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n        this.subscriber = null;\n        return;\n      }\n\n      var options = sampleNode.options;\n      debug(\"selected a subscriber %s:%s\", options.host, options.port);\n      /*\n       * Create a specialized Redis connection for the subscription.\n       * Note that auto reconnection is enabled here.\n       *\n       * `enableReadyCheck` is also enabled because although subscription is allowed\n       * while redis is loading data from the disk, we can check if the password\n       * provided for the subscriber is correct, and if not, the current subscriber\n       * will be disconnected and a new subscriber will be selected.\n       */\n\n      this.subscriber = new redis_1.default({\n        port: options.port,\n        host: options.host,\n        password: options.password,\n        enableReadyCheck: true,\n        connectionName: SUBSCRIBER_CONNECTION_NAME,\n        lazyConnect: true,\n        tls: options.tls\n      }); // Ignore the errors since they're handled in the connection pool.\n\n      this.subscriber.on(\"error\", utils_1.noop); // Re-subscribe previous channels\n\n      var previousChannels = {\n        subscribe: [],\n        psubscribe: []\n      };\n\n      if (lastActiveSubscriber) {\n        var condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n\n        if (condition && condition.subscriber) {\n          previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n          previousChannels.psubscribe = condition.subscriber.channels(\"psubscribe\");\n        }\n      }\n\n      if (previousChannels.subscribe.length || previousChannels.psubscribe.length) {\n        var pending = 0;\n\n        for (var _i = 0, _arr = [\"subscribe\", \"psubscribe\"]; _i < _arr.length; _i++) {\n          var type = _arr[_i];\n          var channels = previousChannels[type];\n\n          if (channels.length) {\n            pending += 1;\n            debug(\"%s %d channels\", type, channels.length);\n            this.subscriber[type](channels).then(function () {\n              if (! --pending) {\n                _this2.lastActiveSubscriber = _this2.subscriber;\n              }\n            }).catch(utils_1.noop);\n          }\n        }\n      } else {\n        this.lastActiveSubscriber = this.subscriber;\n      }\n\n      var _loop = function _loop() {\n        var event = _arr2[_i2];\n\n        _this2.subscriber.on(event, function (arg1, arg2) {\n          _this2.emitter.emit(event, arg1, arg2);\n        });\n      };\n\n      for (var _i2 = 0, _arr2 = [\"message\", \"messageBuffer\"]; _i2 < _arr2.length; _i2++) {\n        _loop();\n      }\n\n      var _loop2 = function _loop2() {\n        var event = _arr3[_i3];\n\n        _this2.subscriber.on(event, function (arg1, arg2, arg3) {\n          _this2.emitter.emit(event, arg1, arg2, arg3);\n        });\n      };\n\n      for (var _i3 = 0, _arr3 = [\"pmessage\", \"pmessageBuffer\"]; _i3 < _arr3.length; _i3++) {\n        _loop2();\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.started = true;\n      this.selectSubscriber();\n      debug(\"started\");\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.started = false;\n\n      if (this.subscriber) {\n        this.subscriber.disconnect();\n        this.subscriber = null;\n      }\n\n      debug(\"stopped\");\n    }\n  }]);\n\n  return ClusterSubscriber;\n}();\n\nexports.default = ClusterSubscriber;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/cluster/ClusterSubscriber.js"],"names":["Object","defineProperty","exports","value","util_1","require","utils_1","redis_1","debug","Debug","SUBSCRIBER_CONNECTION_NAME","ClusterSubscriber","connectionPool","emitter","started","subscriber","on","_","key","getNodeKey","options","selectSubscriber","lastActiveSubscriber","disconnect","sampleNode","sample","getNodes","host","port","default","password","enableReadyCheck","connectionName","lazyConnect","tls","noop","previousChannels","subscribe","psubscribe","condition","prevCondition","channels","length","pending","type","then","catch","event","arg1","arg2","emit","arg3"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\nconst utils_1 = require(\"../utils\");\nconst redis_1 = require(\"../redis\");\nconst debug = utils_1.Debug(\"cluster:subscriber\");\nconst SUBSCRIBER_CONNECTION_NAME = \"ioredisClusterSubscriber\";\nclass ClusterSubscriber {\n    constructor(connectionPool, emitter) {\n        this.connectionPool = connectionPool;\n        this.emitter = emitter;\n        this.started = false;\n        this.subscriber = null;\n        this.connectionPool.on(\"-node\", (_, key) => {\n            if (!this.started || !this.subscriber) {\n                return;\n            }\n            if (util_1.getNodeKey(this.subscriber.options) === key) {\n                debug(\"subscriber has left, selecting a new one...\");\n                this.selectSubscriber();\n            }\n        });\n        this.connectionPool.on(\"+node\", () => {\n            if (!this.started || this.subscriber) {\n                return;\n            }\n            debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n            this.selectSubscriber();\n        });\n    }\n    getInstance() {\n        return this.subscriber;\n    }\n    selectSubscriber() {\n        const lastActiveSubscriber = this.lastActiveSubscriber;\n        // Disconnect the previous subscriber even if there\n        // will not be a new one.\n        if (lastActiveSubscriber) {\n            lastActiveSubscriber.disconnect();\n        }\n        const sampleNode = utils_1.sample(this.connectionPool.getNodes());\n        if (!sampleNode) {\n            debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n            this.subscriber = null;\n            return;\n        }\n        const { options } = sampleNode;\n        debug(\"selected a subscriber %s:%s\", options.host, options.port);\n        /*\n         * Create a specialized Redis connection for the subscription.\n         * Note that auto reconnection is enabled here.\n         *\n         * `enableReadyCheck` is also enabled because although subscription is allowed\n         * while redis is loading data from the disk, we can check if the password\n         * provided for the subscriber is correct, and if not, the current subscriber\n         * will be disconnected and a new subscriber will be selected.\n         */\n        this.subscriber = new redis_1.default({\n            port: options.port,\n            host: options.host,\n            password: options.password,\n            enableReadyCheck: true,\n            connectionName: SUBSCRIBER_CONNECTION_NAME,\n            lazyConnect: true,\n            tls: options.tls\n        });\n        // Ignore the errors since they're handled in the connection pool.\n        this.subscriber.on(\"error\", utils_1.noop);\n        // Re-subscribe previous channels\n        var previousChannels = { subscribe: [], psubscribe: [] };\n        if (lastActiveSubscriber) {\n            const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n            if (condition && condition.subscriber) {\n                previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n                previousChannels.psubscribe = condition.subscriber.channels(\"psubscribe\");\n            }\n        }\n        if (previousChannels.subscribe.length ||\n            previousChannels.psubscribe.length) {\n            var pending = 0;\n            for (const type of [\"subscribe\", \"psubscribe\"]) {\n                var channels = previousChannels[type];\n                if (channels.length) {\n                    pending += 1;\n                    debug(\"%s %d channels\", type, channels.length);\n                    this.subscriber[type](channels)\n                        .then(() => {\n                        if (!--pending) {\n                            this.lastActiveSubscriber = this.subscriber;\n                        }\n                    })\n                        .catch(utils_1.noop);\n                }\n            }\n        }\n        else {\n            this.lastActiveSubscriber = this.subscriber;\n        }\n        for (const event of [\"message\", \"messageBuffer\"]) {\n            this.subscriber.on(event, (arg1, arg2) => {\n                this.emitter.emit(event, arg1, arg2);\n            });\n        }\n        for (const event of [\"pmessage\", \"pmessageBuffer\"]) {\n            this.subscriber.on(event, (arg1, arg2, arg3) => {\n                this.emitter.emit(event, arg1, arg2, arg3);\n            });\n        }\n    }\n    start() {\n        this.started = true;\n        this.selectSubscriber();\n        debug(\"started\");\n    }\n    stop() {\n        this.started = false;\n        if (this.subscriber) {\n            this.subscriber.disconnect();\n            this.subscriber = null;\n        }\n        debug(\"stopped\");\n    }\n}\nexports.default = ClusterSubscriber;\n"]},"metadata":{},"sourceType":"script"}