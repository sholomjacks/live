{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar utils_1 = require(\"../utils\");\n\nvar util_1 = require(\"./util\");\n\nvar redis_1 = require(\"../redis\");\n\nvar debug = utils_1.Debug(\"cluster:connectionPool\");\n\nvar ConnectionPool =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(ConnectionPool, _events_1$EventEmitte);\n\n  function ConnectionPool(redisOptions) {\n    var _this;\n\n    _classCallCheck(this, ConnectionPool);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionPool).call(this));\n    _this.redisOptions = redisOptions; // master + slave = all\n\n    _this.nodes = {\n      all: {},\n      master: {},\n      slave: {}\n    };\n    _this.specifiedOptions = {};\n    return _this;\n  }\n\n  _createClass(ConnectionPool, [{\n    key: \"getNodes\",\n    value: function getNodes() {\n      var role = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"all\";\n      var nodes = this.nodes[role];\n      return Object.keys(nodes).map(function (key) {\n        return nodes[key];\n      });\n    }\n  }, {\n    key: \"getInstanceByKey\",\n    value: function getInstanceByKey(key) {\n      return this.nodes.all[key];\n    }\n  }, {\n    key: \"getSampleInstance\",\n    value: function getSampleInstance(role) {\n      var keys = Object.keys(this.nodes[role]);\n      var sampleKey = utils_1.sample(keys);\n      return this.nodes[role][sampleKey];\n    }\n    /**\n     * Find or create a connection to the node\n     *\n     * @param {IRedisOptions} node\n     * @param {boolean} [readOnly=false]\n     * @returns {*}\n     * @memberof ConnectionPool\n     */\n\n  }, {\n    key: \"findOrCreate\",\n    value: function findOrCreate(node) {\n      var _this2 = this;\n\n      var readOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var key = util_1.getNodeKey(node);\n      readOnly = Boolean(readOnly);\n\n      if (this.specifiedOptions[key]) {\n        Object.assign(node, this.specifiedOptions[key]);\n      } else {\n        this.specifiedOptions[key] = node;\n      }\n\n      var redis;\n\n      if (this.nodes.all[key]) {\n        redis = this.nodes.all[key];\n\n        if (redis.options.readOnly !== readOnly) {\n          redis.options.readOnly = readOnly;\n          debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n          redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n\n          if (readOnly) {\n            delete this.nodes.master[key];\n            this.nodes.slave[key] = redis;\n          } else {\n            delete this.nodes.slave[key];\n            this.nodes.master[key] = redis;\n          }\n        }\n      } else {\n        debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n        redis = new redis_1.default(utils_1.defaults({\n          // Never try to reconnect when a node is lose,\n          // instead, waiting for a `MOVED` error and\n          // fetch the slots again.\n          retryStrategy: null,\n          // Offline queue should be enabled so that\n          // we don't need to wait for the `ready` event\n          // before sending commands to the node.\n          enableOfflineQueue: true,\n          readOnly: readOnly\n        }, node, this.redisOptions, {\n          lazyConnect: true\n        }));\n        this.nodes.all[key] = redis;\n        this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n        redis.once(\"end\", function () {\n          _this2.removeNode(key);\n\n          _this2.emit(\"-node\", redis, key);\n\n          if (!Object.keys(_this2.nodes.all).length) {\n            _this2.emit(\"drain\");\n          }\n        });\n        this.emit(\"+node\", redis, key);\n        redis.on(\"error\", function (error) {\n          this.emit(\"nodeError\", error, key);\n        });\n      }\n\n      return redis;\n    }\n    /**\n     * Remove a node from the pool.\n     */\n\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      var nodes = this.nodes;\n\n      if (nodes.all[key]) {\n        debug(\"Remove %s from the pool\", key);\n        delete nodes.all[key];\n      }\n\n      delete nodes.master[key];\n      delete nodes.slave[key];\n    }\n    /**\n     * Reset the pool with a set of nodes.\n     * The old node will be removed.\n     *\n     * @param {(Array<string | number | object>)} nodes\n     * @memberof ConnectionPool\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset(nodes) {\n      var _this3 = this;\n\n      debug(\"Reset with %O\", nodes);\n      var newNodes = {};\n      nodes.forEach(function (node) {\n        var key = util_1.getNodeKey(node); // Don't override the existing (master) node\n        // when the current one is slave.\n\n        if (!(node.readOnly && newNodes[key])) {\n          newNodes[key] = node;\n        }\n      });\n      Object.keys(this.nodes.all).forEach(function (key) {\n        if (!newNodes[key]) {\n          debug(\"Disconnect %s because the node does not hold any slot\", key);\n\n          _this3.nodes.all[key].disconnect();\n\n          _this3.removeNode(key);\n        }\n      });\n      Object.keys(newNodes).forEach(function (key) {\n        var node = newNodes[key];\n\n        _this3.findOrCreate(node, node.readOnly);\n      });\n    }\n  }]);\n\n  return ConnectionPool;\n}(events_1.EventEmitter);\n\nexports.default = ConnectionPool;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/cluster/ConnectionPool.js"],"names":["Object","defineProperty","exports","value","events_1","require","utils_1","util_1","redis_1","debug","Debug","ConnectionPool","redisOptions","nodes","all","master","slave","specifiedOptions","role","keys","map","key","sampleKey","sample","node","readOnly","getNodeKey","Boolean","assign","redis","options","catch","noop","default","defaults","retryStrategy","enableOfflineQueue","lazyConnect","once","removeNode","emit","length","on","error","newNodes","forEach","disconnect","findOrCreate","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst utils_1 = require(\"../utils\");\nconst util_1 = require(\"./util\");\nconst redis_1 = require(\"../redis\");\nconst debug = utils_1.Debug(\"cluster:connectionPool\");\nclass ConnectionPool extends events_1.EventEmitter {\n    constructor(redisOptions) {\n        super();\n        this.redisOptions = redisOptions;\n        // master + slave = all\n        this.nodes = {\n            all: {},\n            master: {},\n            slave: {}\n        };\n        this.specifiedOptions = {};\n    }\n    getNodes(role = \"all\") {\n        const nodes = this.nodes[role];\n        return Object.keys(nodes).map(key => nodes[key]);\n    }\n    getInstanceByKey(key) {\n        return this.nodes.all[key];\n    }\n    getSampleInstance(role) {\n        const keys = Object.keys(this.nodes[role]);\n        const sampleKey = utils_1.sample(keys);\n        return this.nodes[role][sampleKey];\n    }\n    /**\n     * Find or create a connection to the node\n     *\n     * @param {IRedisOptions} node\n     * @param {boolean} [readOnly=false]\n     * @returns {*}\n     * @memberof ConnectionPool\n     */\n    findOrCreate(node, readOnly = false) {\n        const key = util_1.getNodeKey(node);\n        readOnly = Boolean(readOnly);\n        if (this.specifiedOptions[key]) {\n            Object.assign(node, this.specifiedOptions[key]);\n        }\n        else {\n            this.specifiedOptions[key] = node;\n        }\n        let redis;\n        if (this.nodes.all[key]) {\n            redis = this.nodes.all[key];\n            if (redis.options.readOnly !== readOnly) {\n                redis.options.readOnly = readOnly;\n                debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n                redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n                if (readOnly) {\n                    delete this.nodes.master[key];\n                    this.nodes.slave[key] = redis;\n                }\n                else {\n                    delete this.nodes.slave[key];\n                    this.nodes.master[key] = redis;\n                }\n            }\n        }\n        else {\n            debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n            redis = new redis_1.default(utils_1.defaults({\n                // Never try to reconnect when a node is lose,\n                // instead, waiting for a `MOVED` error and\n                // fetch the slots again.\n                retryStrategy: null,\n                // Offline queue should be enabled so that\n                // we don't need to wait for the `ready` event\n                // before sending commands to the node.\n                enableOfflineQueue: true,\n                readOnly: readOnly\n            }, node, this.redisOptions, { lazyConnect: true }));\n            this.nodes.all[key] = redis;\n            this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n            redis.once(\"end\", () => {\n                this.removeNode(key);\n                this.emit(\"-node\", redis, key);\n                if (!Object.keys(this.nodes.all).length) {\n                    this.emit(\"drain\");\n                }\n            });\n            this.emit(\"+node\", redis, key);\n            redis.on(\"error\", function (error) {\n                this.emit(\"nodeError\", error, key);\n            });\n        }\n        return redis;\n    }\n    /**\n     * Remove a node from the pool.\n     */\n    removeNode(key) {\n        const { nodes } = this;\n        if (nodes.all[key]) {\n            debug(\"Remove %s from the pool\", key);\n            delete nodes.all[key];\n        }\n        delete nodes.master[key];\n        delete nodes.slave[key];\n    }\n    /**\n     * Reset the pool with a set of nodes.\n     * The old node will be removed.\n     *\n     * @param {(Array<string | number | object>)} nodes\n     * @memberof ConnectionPool\n     */\n    reset(nodes) {\n        debug(\"Reset with %O\", nodes);\n        const newNodes = {};\n        nodes.forEach(node => {\n            const key = util_1.getNodeKey(node);\n            // Don't override the existing (master) node\n            // when the current one is slave.\n            if (!(node.readOnly && newNodes[key])) {\n                newNodes[key] = node;\n            }\n        });\n        Object.keys(this.nodes.all).forEach(key => {\n            if (!newNodes[key]) {\n                debug(\"Disconnect %s because the node does not hold any slot\", key);\n                this.nodes.all[key].disconnect();\n                this.removeNode(key);\n            }\n        });\n        Object.keys(newNodes).forEach(key => {\n            const node = newNodes[key];\n            this.findOrCreate(node, node.readOnly);\n        });\n    }\n}\nexports.default = ConnectionPool;\n"]},"metadata":{},"sourceType":"script"}