{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar commands = require(\"redis-commands\");\n\nvar calculateSlot = require(\"cluster-key-slot\");\n\nvar standard_as_callback_1 = require(\"standard-as-callback\");\n\nvar utils_1 = require(\"./utils\");\n\nvar lodash_1 = require(\"./utils/lodash\");\n\nvar promiseContainer_1 = require(\"./promiseContainer\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * @export\n * @class Command\n *\n * @example\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n * @see {@link Redis#sendCommand} which can send a Command instance to Redis\n */\n\n\nvar Command =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of Command.\n   * @param {string} name Command name\n   * @param {(Array<string | Buffer | number>)} [args=[]] An array of command arguments\n   * @param {ICommandOptions} [options={}]\n   * @param {CallbackFunction} [callback] The callback that handles the response.\n   * If omit, the response will be handled via Promise\n   * @memberof Command\n   */\n  function Command(name) {\n    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, Command);\n\n    this.name = name;\n    this.transformed = false;\n    this.isCustomCommand = false;\n    this.replyEncoding = options.replyEncoding;\n    this.errorStack = options.errorStack;\n    this.args = lodash_1.flatten(args);\n    this.callback = callback;\n    this.initPromise();\n\n    if (options.keyPrefix) {\n      this._iterateKeys(function (key) {\n        return options.keyPrefix + key;\n      });\n    }\n\n    if (options.readOnly) {\n      this.isReadOnly = true;\n    }\n  }\n\n  _createClass(Command, [{\n    key: \"initPromise\",\n    value: function initPromise() {\n      var _this = this;\n\n      var Promise = promiseContainer_1.get();\n      var promise = new Promise(function (resolve, reject) {\n        if (!_this.transformed) {\n          _this.transformed = true;\n          var transformer = Command._transformer.argument[_this.name];\n\n          if (transformer) {\n            _this.args = transformer(_this.args);\n          }\n\n          _this.stringifyArguments();\n        }\n\n        _this.resolve = _this._convertValue(resolve);\n\n        if (_this.errorStack) {\n          _this.reject = function (err) {\n            reject(utils_1.optimizeErrorStack(err, _this.errorStack, __dirname));\n          };\n        } else {\n          _this.reject = reject;\n        }\n      });\n      this.promise = standard_as_callback_1.default(promise, this.callback);\n    }\n  }, {\n    key: \"getSlot\",\n    value: function getSlot() {\n      if (typeof this.slot === \"undefined\") {\n        var key = this.getKeys()[0];\n        this.slot = key == null ? null : calculateSlot(key);\n      }\n\n      return this.slot;\n    }\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      return this._iterateKeys();\n    }\n    /**\n     * Iterate through the command arguments that are considered keys.\n     *\n     * @param {Function} [transform=(key) => key] The transformation that should be applied to\n     * each key. The transformations will persist.\n     * @returns {string[]} The keys of the command.\n     * @memberof Command\n     */\n\n  }, {\n    key: \"_iterateKeys\",\n    value: function _iterateKeys() {\n      var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (key) {\n        return key;\n      };\n\n      if (typeof this.keys === \"undefined\") {\n        this.keys = [];\n\n        if (commands.exists(this.name)) {\n          var keyIndexes = commands.getKeyIndexes(this.name, this.args);\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = keyIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var index = _step.value;\n              this.args[index] = transform(this.args[index]);\n              this.keys.push(this.args[index]);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n\n      return this.keys;\n    }\n    /**\n     * Convert command to writable buffer or string\n     *\n     * @return {string|Buffer}\n     * @see {@link Redis#sendCommand}\n     * @public\n     */\n\n  }, {\n    key: \"toWritable\",\n    value: function toWritable() {\n      var bufferMode = false;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _arg2 = _step2.value;\n\n          if (_arg2 instanceof Buffer) {\n            bufferMode = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var result;\n      var commandStr = \"*\" + (this.args.length + 1) + \"\\r\\n$\" + Buffer.byteLength(this.name) + \"\\r\\n\" + this.name + \"\\r\\n\";\n\n      if (bufferMode) {\n        var buffers = new MixedBuffers();\n        buffers.push(commandStr);\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var arg = _step3.value;\n\n            if (arg instanceof Buffer) {\n              if (arg.length === 0) {\n                buffers.push(\"$0\\r\\n\\r\\n\");\n              } else {\n                buffers.push(\"$\" + arg.length + \"\\r\\n\");\n                buffers.push(arg);\n                buffers.push(\"\\r\\n\");\n              }\n            } else {\n              buffers.push(\"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\");\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        result = buffers.toBuffer();\n      } else {\n        result = commandStr;\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.args[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _arg = _step4.value;\n            result += \"$\" + Buffer.byteLength(_arg) + \"\\r\\n\" + _arg + \"\\r\\n\";\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"stringifyArguments\",\n    value: function stringifyArguments() {\n      for (var i = 0; i < this.args.length; ++i) {\n        var arg = this.args[i];\n\n        if (!(arg instanceof Buffer) && typeof arg !== \"string\") {\n          this.args[i] = utils_1.toArg(arg);\n        }\n      }\n    }\n    /**\n     * Convert the value from buffer to the target encoding.\n     *\n     * @private\n     * @param {Function} resolve The resolve function of the Promise\n     * @returns {Function} A funtion to transform and resolve a value\n     * @memberof Command\n     */\n\n  }, {\n    key: \"_convertValue\",\n    value: function _convertValue(resolve) {\n      var _this2 = this;\n\n      return function (value) {\n        try {\n          resolve(_this2.transformReply(value));\n        } catch (err) {\n          _this2.reject(err);\n        }\n\n        return _this2.promise;\n      };\n    }\n    /**\n     * Convert buffer/buffer[] to string/string[],\n     * and apply reply transformer.\n     *\n     * @memberof Command\n     */\n\n  }, {\n    key: \"transformReply\",\n    value: function transformReply(result) {\n      if (this.replyEncoding) {\n        result = utils_1.convertBufferToString(result, this.replyEncoding);\n      }\n\n      var transformer = Command._transformer.reply[this.name];\n\n      if (transformer) {\n        result = transformer(result);\n      }\n\n      return result;\n    }\n  }], [{\n    key: \"getFlagMap\",\n    value: function getFlagMap() {\n      if (!this.flagMap) {\n        this.flagMap = Object.keys(Command.FLAGS).reduce(function (map, flagName) {\n          map[flagName] = {};\n          Command.FLAGS[flagName].forEach(function (commandName) {\n            map[flagName][commandName] = true;\n          });\n          return map;\n        }, {});\n      }\n\n      return this.flagMap;\n    }\n    /**\n     * Check whether the command has the flag\n     *\n     * @param {string} flagName\n     * @param {string} commandName\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"checkFlag\",\n    value: function checkFlag(flagName, commandName) {\n      return !!this.getFlagMap()[flagName][commandName];\n    }\n  }, {\n    key: \"setArgumentTransformer\",\n    value: function setArgumentTransformer(name, func) {\n      this._transformer.argument[name] = func;\n    }\n  }, {\n    key: \"setReplyTransformer\",\n    value: function setReplyTransformer(name, func) {\n      this._transformer.reply[name] = func;\n    }\n  }]);\n\n  return Command;\n}();\n\nCommand.FLAGS = {\n  VALID_IN_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\", \"unsubscribe\", \"punsubscribe\", \"ping\", \"quit\"],\n  VALID_IN_MONITOR_MODE: [\"monitor\", \"auth\"],\n  ENTER_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\"],\n  EXIT_SUBSCRIBER_MODE: [\"unsubscribe\", \"punsubscribe\"],\n  WILL_DISCONNECT: [\"quit\"]\n};\nCommand._transformer = {\n  argument: {},\n  reply: {}\n};\nexports.default = Command;\n\nvar msetArgumentTransformer = function msetArgumentTransformer(args) {\n  if (args.length === 1) {\n    if (typeof Map !== \"undefined\" && args[0] instanceof Map) {\n      return utils_1.convertMapToArray(args[0]);\n    }\n\n    if (typeof args[0] === \"object\" && args[0] !== null) {\n      return utils_1.convertObjectToArray(args[0]);\n    }\n  }\n\n  return args;\n};\n\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      return [args[0]].concat(utils_1.convertMapToArray(args[1]));\n    }\n\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils_1.convertObjectToArray(args[1]));\n    }\n  }\n\n  return args;\n});\nCommand.setReplyTransformer(\"hgetall\", function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n\n    return obj;\n  }\n\n  return result;\n});\nCommand.setArgumentTransformer(\"hset\", function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      return [args[0]].concat(utils_1.convertMapToArray(args[1]));\n    }\n\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils_1.convertObjectToArray(args[1]));\n    }\n  }\n\n  return args;\n});\n\nvar MixedBuffers =\n/*#__PURE__*/\nfunction () {\n  function MixedBuffers() {\n    _classCallCheck(this, MixedBuffers);\n\n    this.length = 0;\n    this.items = [];\n  }\n\n  _createClass(MixedBuffers, [{\n    key: \"push\",\n    value: function push(x) {\n      this.length += Buffer.byteLength(x);\n      this.items.push(x);\n    }\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      var result = Buffer.allocUnsafe(this.length);\n      var offset = 0;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this.items[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var item = _step5.value;\n          var length = Buffer.byteLength(item);\n          Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);\n          offset += length;\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return MixedBuffers;\n}();","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/command.js"],"names":["Object","defineProperty","exports","value","commands","require","calculateSlot","standard_as_callback_1","utils_1","lodash_1","promiseContainer_1","Command","name","args","options","callback","transformed","isCustomCommand","replyEncoding","errorStack","flatten","initPromise","keyPrefix","_iterateKeys","key","readOnly","isReadOnly","Promise","get","promise","resolve","reject","transformer","_transformer","argument","stringifyArguments","_convertValue","err","optimizeErrorStack","__dirname","default","slot","getKeys","transform","keys","exists","keyIndexes","getKeyIndexes","index","push","bufferMode","arg","Buffer","result","commandStr","length","byteLength","buffers","MixedBuffers","toBuffer","i","toArg","transformReply","convertBufferToString","reply","flagMap","FLAGS","reduce","map","flagName","forEach","commandName","getFlagMap","func","VALID_IN_SUBSCRIBER_MODE","VALID_IN_MONITOR_MODE","ENTER_SUBSCRIBER_MODE","EXIT_SUBSCRIBER_MODE","WILL_DISCONNECT","msetArgumentTransformer","Map","convertMapToArray","convertObjectToArray","setArgumentTransformer","concat","setReplyTransformer","Array","isArray","obj","items","x","allocUnsafe","offset","item","isBuffer","copy","write"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commands = require(\"redis-commands\");\nconst calculateSlot = require(\"cluster-key-slot\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst utils_1 = require(\"./utils\");\nconst lodash_1 = require(\"./utils/lodash\");\nconst promiseContainer_1 = require(\"./promiseContainer\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * @export\n * @class Command\n *\n * @example\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n * @see {@link Redis#sendCommand} which can send a Command instance to Redis\n */\nclass Command {\n    /**\n     * Creates an instance of Command.\n     * @param {string} name Command name\n     * @param {(Array<string | Buffer | number>)} [args=[]] An array of command arguments\n     * @param {ICommandOptions} [options={}]\n     * @param {CallbackFunction} [callback] The callback that handles the response.\n     * If omit, the response will be handled via Promise\n     * @memberof Command\n     */\n    constructor(name, args = [], options = {}, callback) {\n        this.name = name;\n        this.transformed = false;\n        this.isCustomCommand = false;\n        this.replyEncoding = options.replyEncoding;\n        this.errorStack = options.errorStack;\n        this.args = lodash_1.flatten(args);\n        this.callback = callback;\n        this.initPromise();\n        if (options.keyPrefix) {\n            this._iterateKeys(key => options.keyPrefix + key);\n        }\n        if (options.readOnly) {\n            this.isReadOnly = true;\n        }\n    }\n    static getFlagMap() {\n        if (!this.flagMap) {\n            this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {\n                map[flagName] = {};\n                Command.FLAGS[flagName].forEach(commandName => {\n                    map[flagName][commandName] = true;\n                });\n                return map;\n            }, {});\n        }\n        return this.flagMap;\n    }\n    /**\n     * Check whether the command has the flag\n     *\n     * @param {string} flagName\n     * @param {string} commandName\n     * @return {boolean}\n     */\n    static checkFlag(flagName, commandName) {\n        return !!this.getFlagMap()[flagName][commandName];\n    }\n    static setArgumentTransformer(name, func) {\n        this._transformer.argument[name] = func;\n    }\n    static setReplyTransformer(name, func) {\n        this._transformer.reply[name] = func;\n    }\n    initPromise() {\n        const Promise = promiseContainer_1.get();\n        const promise = new Promise((resolve, reject) => {\n            if (!this.transformed) {\n                this.transformed = true;\n                const transformer = Command._transformer.argument[this.name];\n                if (transformer) {\n                    this.args = transformer(this.args);\n                }\n                this.stringifyArguments();\n            }\n            this.resolve = this._convertValue(resolve);\n            if (this.errorStack) {\n                this.reject = err => {\n                    reject(utils_1.optimizeErrorStack(err, this.errorStack, __dirname));\n                };\n            }\n            else {\n                this.reject = reject;\n            }\n        });\n        this.promise = standard_as_callback_1.default(promise, this.callback);\n    }\n    getSlot() {\n        if (typeof this.slot === \"undefined\") {\n            const key = this.getKeys()[0];\n            this.slot = key == null ? null : calculateSlot(key);\n        }\n        return this.slot;\n    }\n    getKeys() {\n        return this._iterateKeys();\n    }\n    /**\n     * Iterate through the command arguments that are considered keys.\n     *\n     * @param {Function} [transform=(key) => key] The transformation that should be applied to\n     * each key. The transformations will persist.\n     * @returns {string[]} The keys of the command.\n     * @memberof Command\n     */\n    _iterateKeys(transform = key => key) {\n        if (typeof this.keys === \"undefined\") {\n            this.keys = [];\n            if (commands.exists(this.name)) {\n                const keyIndexes = commands.getKeyIndexes(this.name, this.args);\n                for (const index of keyIndexes) {\n                    this.args[index] = transform(this.args[index]);\n                    this.keys.push(this.args[index]);\n                }\n            }\n        }\n        return this.keys;\n    }\n    /**\n     * Convert command to writable buffer or string\n     *\n     * @return {string|Buffer}\n     * @see {@link Redis#sendCommand}\n     * @public\n     */\n    toWritable() {\n        let bufferMode = false;\n        for (const arg of this.args) {\n            if (arg instanceof Buffer) {\n                bufferMode = true;\n                break;\n            }\n        }\n        let result;\n        let commandStr = \"*\" +\n            (this.args.length + 1) +\n            \"\\r\\n$\" +\n            Buffer.byteLength(this.name) +\n            \"\\r\\n\" +\n            this.name +\n            \"\\r\\n\";\n        if (bufferMode) {\n            const buffers = new MixedBuffers();\n            buffers.push(commandStr);\n            for (const arg of this.args) {\n                if (arg instanceof Buffer) {\n                    if (arg.length === 0) {\n                        buffers.push(\"$0\\r\\n\\r\\n\");\n                    }\n                    else {\n                        buffers.push(\"$\" + arg.length + \"\\r\\n\");\n                        buffers.push(arg);\n                        buffers.push(\"\\r\\n\");\n                    }\n                }\n                else {\n                    buffers.push(\"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\");\n                }\n            }\n            result = buffers.toBuffer();\n        }\n        else {\n            result = commandStr;\n            for (const arg of this.args) {\n                result +=\n                    \"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\";\n            }\n        }\n        return result;\n    }\n    stringifyArguments() {\n        for (let i = 0; i < this.args.length; ++i) {\n            const arg = this.args[i];\n            if (!(arg instanceof Buffer) && typeof arg !== \"string\") {\n                this.args[i] = utils_1.toArg(arg);\n            }\n        }\n    }\n    /**\n     * Convert the value from buffer to the target encoding.\n     *\n     * @private\n     * @param {Function} resolve The resolve function of the Promise\n     * @returns {Function} A funtion to transform and resolve a value\n     * @memberof Command\n     */\n    _convertValue(resolve) {\n        return value => {\n            try {\n                resolve(this.transformReply(value));\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            return this.promise;\n        };\n    }\n    /**\n     * Convert buffer/buffer[] to string/string[],\n     * and apply reply transformer.\n     *\n     * @memberof Command\n     */\n    transformReply(result) {\n        if (this.replyEncoding) {\n            result = utils_1.convertBufferToString(result, this.replyEncoding);\n        }\n        const transformer = Command._transformer.reply[this.name];\n        if (transformer) {\n            result = transformer(result);\n        }\n        return result;\n    }\n}\nCommand.FLAGS = {\n    VALID_IN_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"ping\",\n        \"quit\"\n    ],\n    VALID_IN_MONITOR_MODE: [\"monitor\", \"auth\"],\n    ENTER_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\"],\n    EXIT_SUBSCRIBER_MODE: [\"unsubscribe\", \"punsubscribe\"],\n    WILL_DISCONNECT: [\"quit\"]\n};\nCommand._transformer = {\n    argument: {},\n    reply: {}\n};\nexports.default = Command;\nconst msetArgumentTransformer = function (args) {\n    if (args.length === 1) {\n        if (typeof Map !== \"undefined\" && args[0] instanceof Map) {\n            return utils_1.convertMapToArray(args[0]);\n        }\n        if (typeof args[0] === \"object\" && args[0] !== null) {\n            return utils_1.convertObjectToArray(args[0]);\n        }\n    }\n    return args;\n};\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", function (args) {\n    if (args.length === 2) {\n        if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n            return [args[0]].concat(utils_1.convertMapToArray(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [args[0]].concat(utils_1.convertObjectToArray(args[1]));\n        }\n    }\n    return args;\n});\nCommand.setReplyTransformer(\"hgetall\", function (result) {\n    if (Array.isArray(result)) {\n        var obj = {};\n        for (var i = 0; i < result.length; i += 2) {\n            obj[result[i]] = result[i + 1];\n        }\n        return obj;\n    }\n    return result;\n});\nCommand.setArgumentTransformer(\"hset\", function (args) {\n    if (args.length === 2) {\n        if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n            return [args[0]].concat(utils_1.convertMapToArray(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [args[0]].concat(utils_1.convertObjectToArray(args[1]));\n        }\n    }\n    return args;\n});\nclass MixedBuffers {\n    constructor() {\n        this.length = 0;\n        this.items = [];\n    }\n    push(x) {\n        this.length += Buffer.byteLength(x);\n        this.items.push(x);\n    }\n    toBuffer() {\n        const result = Buffer.allocUnsafe(this.length);\n        let offset = 0;\n        for (const item of this.items) {\n            const length = Buffer.byteLength(item);\n            Buffer.isBuffer(item)\n                ? item.copy(result, offset)\n                : result.write(item, offset, length);\n            offset += length;\n        }\n        return result;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}