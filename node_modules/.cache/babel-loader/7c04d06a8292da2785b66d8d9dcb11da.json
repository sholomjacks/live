{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst net_1 = require(\"net\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst tls_1 = require(\"tls\");\n\nconst StandaloneConnector_1 = require(\"../StandaloneConnector\");\n\nconst SentinelIterator_1 = require(\"./SentinelIterator\");\n\nexports.SentinelIterator = SentinelIterator_1.default;\n\nconst AbstractConnector_1 = require(\"../AbstractConnector\");\n\nconst redis_1 = require(\"../../redis\");\n\nconst debug = utils_1.Debug(\"SentinelConnector\");\n\nclass SentinelConnector extends AbstractConnector_1.default {\n  constructor(options) {\n    super();\n    this.options = options;\n\n    if (!this.options.sentinels.length) {\n      throw new Error(\"Requires at least one sentinel to connect to.\");\n    }\n\n    if (!this.options.name) {\n      throw new Error(\"Requires the name of master.\");\n    }\n\n    this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n  }\n\n  check(info) {\n    const roleMatches = !info.role || this.options.role === info.role;\n\n    if (!roleMatches) {\n      debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role); // Start from the next item.\n      // Note that `reset` will move the cursor to the previous element,\n      // so we advance two steps here.\n\n      this.sentinelIterator.next();\n      this.sentinelIterator.next();\n      this.sentinelIterator.reset(true);\n    }\n\n    return roleMatches;\n  }\n\n  connect(eventEmitter) {\n    this.connecting = true;\n    this.retryAttempts = 0;\n    let lastError;\n\n    const connectToNext = () => new Promise((resolve, reject) => {\n      const endpoint = this.sentinelIterator.next();\n\n      if (endpoint.done) {\n        this.sentinelIterator.reset(false);\n        const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;\n        let errorMsg = typeof retryDelay !== \"number\" ? \"All sentinels are unreachable and retry is disabled.\" : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n\n        if (lastError) {\n          errorMsg += ` Last error: ${lastError.message}`;\n        }\n\n        debug(errorMsg);\n        const error = new Error(errorMsg);\n\n        if (typeof retryDelay === \"number\") {\n          setTimeout(() => {\n            resolve(connectToNext());\n          }, retryDelay);\n          eventEmitter(\"error\", error);\n        } else {\n          reject(error);\n        }\n\n        return;\n      }\n\n      this.resolve(endpoint.value, (err, resolved) => {\n        if (!this.connecting) {\n          reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n          return;\n        }\n\n        if (resolved) {\n          debug(\"resolved: %s:%s\", resolved.host, resolved.port);\n\n          if (this.options.enableTLSForSentinelMode && this.options.tls) {\n            Object.assign(resolved, this.options.tls);\n            this.stream = tls_1.connect(resolved);\n          } else {\n            this.stream = net_1.createConnection(resolved);\n          }\n\n          this.sentinelIterator.reset(true);\n          resolve(this.stream);\n        } else {\n          const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n          const errorMsg = err ? \"failed to connect to sentinel \" + endpointAddress + \" because \" + err.message : \"connected to sentinel \" + endpointAddress + \" successfully, but got an invalid reply: \" + resolved;\n          debug(errorMsg);\n          eventEmitter(\"sentinelError\", new Error(errorMsg));\n\n          if (err) {\n            lastError = err;\n          }\n\n          resolve(connectToNext());\n        }\n      });\n    });\n\n    return connectToNext();\n  }\n\n  updateSentinels(client, callback) {\n    if (!this.options.updateSentinels) {\n      return callback(null);\n    }\n\n    client.sentinel(\"sentinels\", this.options.name, (err, result) => {\n      if (err) {\n        client.disconnect();\n        return callback(err);\n      }\n\n      if (!Array.isArray(result)) {\n        return callback(null);\n      }\n\n      result.map(utils_1.packObject).forEach(sentinel => {\n        const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n\n        if (flags.indexOf(\"disconnected\") === -1 && sentinel.ip && sentinel.port) {\n          const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n\n          if (this.sentinelIterator.add(endpoint)) {\n            debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n          }\n        }\n      });\n      debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n      callback(null);\n    });\n  }\n\n  resolveMaster(client, callback) {\n    client.sentinel(\"get-master-addr-by-name\", this.options.name, (err, result) => {\n      if (err) {\n        client.disconnect();\n        return callback(err);\n      }\n\n      this.updateSentinels(client, err => {\n        client.disconnect();\n\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, this.sentinelNatResolve(Array.isArray(result) ? {\n          host: result[0],\n          port: Number(result[1])\n        } : null));\n      });\n    });\n  }\n\n  resolveSlave(client, callback) {\n    client.sentinel(\"slaves\", this.options.name, (err, result) => {\n      client.disconnect();\n\n      if (err) {\n        return callback(err);\n      }\n\n      if (!Array.isArray(result)) {\n        return callback(null, null);\n      }\n\n      const availableSlaves = result.map(utils_1.packObject).filter(slave => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n      callback(null, this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves)));\n    });\n  }\n\n  sentinelNatResolve(item) {\n    if (!item || !this.options.natMap) return item;\n    return this.options.natMap[`${item.host}:${item.port}`] || item;\n  }\n\n  resolve(endpoint, callback) {\n    var client = new redis_1.default({\n      port: endpoint.port || 26379,\n      host: endpoint.host,\n      password: this.options.sentinelPassword || null,\n      family: endpoint.family || (StandaloneConnector_1.isIIpcConnectionOptions(this.options) ? undefined : this.options.family),\n      tls: this.options.sentinelTLS,\n      retryStrategy: null,\n      enableReadyCheck: false,\n      connectTimeout: this.options.connectTimeout,\n      dropBufferSupport: true\n    }); // ignore the errors since resolve* methods will handle them\n\n    client.on(\"error\", noop);\n\n    if (this.options.role === \"slave\") {\n      this.resolveSlave(client, callback);\n    } else {\n      this.resolveMaster(client, callback);\n    }\n  }\n\n}\n\nexports.default = SentinelConnector;\n\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n  if (availableSlaves.length === 0) {\n    return null;\n  }\n\n  let selectedSlave;\n\n  if (typeof preferredSlaves === \"function\") {\n    selectedSlave = preferredSlaves(availableSlaves);\n  } else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n    const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves]; // sort by priority\n\n    preferredSlavesArray.sort((a, b) => {\n      // default the priority to 1\n      if (!a.prio) {\n        a.prio = 1;\n      }\n\n      if (!b.prio) {\n        b.prio = 1;\n      } // lowest priority first\n\n\n      if (a.prio < b.prio) {\n        return -1;\n      }\n\n      if (a.prio > b.prio) {\n        return 1;\n      }\n\n      return 0;\n    }); // loop over preferred slaves and return the first match\n\n    for (let p = 0; p < preferredSlavesArray.length; p++) {\n      for (let a = 0; a < availableSlaves.length; a++) {\n        const slave = availableSlaves[a];\n\n        if (slave.ip === preferredSlavesArray[p].ip) {\n          if (slave.port === preferredSlavesArray[p].port) {\n            selectedSlave = slave;\n            break;\n          }\n        }\n      }\n\n      if (selectedSlave) {\n        break;\n      }\n    }\n  } // if none of the preferred slaves are available, a random available slave is returned\n\n\n  if (!selectedSlave) {\n    selectedSlave = utils_1.sample(availableSlaves);\n  }\n\n  return addressResponseToAddress(selectedSlave);\n}\n\nfunction addressResponseToAddress(input) {\n  return {\n    host: input.ip,\n    port: Number(input.port)\n  };\n}\n\nfunction noop() {}","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/connectors/SentinelConnector/index.js"],"names":["Object","defineProperty","exports","value","net_1","require","utils_1","tls_1","StandaloneConnector_1","SentinelIterator_1","SentinelIterator","default","AbstractConnector_1","redis_1","debug","Debug","SentinelConnector","constructor","options","sentinels","length","Error","name","sentinelIterator","check","info","roleMatches","role","next","reset","connect","eventEmitter","connecting","retryAttempts","lastError","connectToNext","Promise","resolve","reject","endpoint","done","retryDelay","sentinelRetryStrategy","errorMsg","message","error","setTimeout","err","resolved","CONNECTION_CLOSED_ERROR_MSG","host","port","enableTLSForSentinelMode","tls","assign","stream","createConnection","endpointAddress","updateSentinels","client","callback","sentinel","result","disconnect","Array","isArray","map","packObject","forEach","flags","split","indexOf","ip","sentinelNatResolve","addressResponseToAddress","add","resolveMaster","Number","resolveSlave","availableSlaves","filter","slave","match","selectPreferredSentinel","preferredSlaves","item","natMap","password","sentinelPassword","family","isIIpcConnectionOptions","undefined","sentinelTLS","retryStrategy","enableReadyCheck","connectTimeout","dropBufferSupport","on","noop","selectedSlave","preferredSlavesArray","sort","a","b","prio","p","sample","input"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = require(\"net\");\nconst utils_1 = require(\"../../utils\");\nconst tls_1 = require(\"tls\");\nconst StandaloneConnector_1 = require(\"../StandaloneConnector\");\nconst SentinelIterator_1 = require(\"./SentinelIterator\");\nexports.SentinelIterator = SentinelIterator_1.default;\nconst AbstractConnector_1 = require(\"../AbstractConnector\");\nconst redis_1 = require(\"../../redis\");\nconst debug = utils_1.Debug(\"SentinelConnector\");\nclass SentinelConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super();\n        this.options = options;\n        if (!this.options.sentinels.length) {\n            throw new Error(\"Requires at least one sentinel to connect to.\");\n        }\n        if (!this.options.name) {\n            throw new Error(\"Requires the name of master.\");\n        }\n        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n    }\n    check(info) {\n        const roleMatches = !info.role || this.options.role === info.role;\n        if (!roleMatches) {\n            debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role);\n            // Start from the next item.\n            // Note that `reset` will move the cursor to the previous element,\n            // so we advance two steps here.\n            this.sentinelIterator.next();\n            this.sentinelIterator.next();\n            this.sentinelIterator.reset(true);\n        }\n        return roleMatches;\n    }\n    connect(eventEmitter) {\n        this.connecting = true;\n        this.retryAttempts = 0;\n        let lastError;\n        const connectToNext = () => new Promise((resolve, reject) => {\n            const endpoint = this.sentinelIterator.next();\n            if (endpoint.done) {\n                this.sentinelIterator.reset(false);\n                const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\"\n                    ? this.options.sentinelRetryStrategy(++this.retryAttempts)\n                    : null;\n                let errorMsg = typeof retryDelay !== \"number\"\n                    ? \"All sentinels are unreachable and retry is disabled.\"\n                    : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n                if (lastError) {\n                    errorMsg += ` Last error: ${lastError.message}`;\n                }\n                debug(errorMsg);\n                const error = new Error(errorMsg);\n                if (typeof retryDelay === \"number\") {\n                    setTimeout(() => {\n                        resolve(connectToNext());\n                    }, retryDelay);\n                    eventEmitter(\"error\", error);\n                }\n                else {\n                    reject(error);\n                }\n                return;\n            }\n            this.resolve(endpoint.value, (err, resolved) => {\n                if (!this.connecting) {\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                    return;\n                }\n                if (resolved) {\n                    debug(\"resolved: %s:%s\", resolved.host, resolved.port);\n                    if (this.options.enableTLSForSentinelMode && this.options.tls) {\n                        Object.assign(resolved, this.options.tls);\n                        this.stream = tls_1.connect(resolved);\n                    }\n                    else {\n                        this.stream = net_1.createConnection(resolved);\n                    }\n                    this.sentinelIterator.reset(true);\n                    resolve(this.stream);\n                }\n                else {\n                    const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n                    const errorMsg = err\n                        ? \"failed to connect to sentinel \" +\n                            endpointAddress +\n                            \" because \" +\n                            err.message\n                        : \"connected to sentinel \" +\n                            endpointAddress +\n                            \" successfully, but got an invalid reply: \" +\n                            resolved;\n                    debug(errorMsg);\n                    eventEmitter(\"sentinelError\", new Error(errorMsg));\n                    if (err) {\n                        lastError = err;\n                    }\n                    resolve(connectToNext());\n                }\n            });\n        });\n        return connectToNext();\n    }\n    updateSentinels(client, callback) {\n        if (!this.options.updateSentinels) {\n            return callback(null);\n        }\n        client.sentinel(\"sentinels\", this.options.name, (err, result) => {\n            if (err) {\n                client.disconnect();\n                return callback(err);\n            }\n            if (!Array.isArray(result)) {\n                return callback(null);\n            }\n            result\n                .map(utils_1.packObject)\n                .forEach(sentinel => {\n                const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n                if (flags.indexOf(\"disconnected\") === -1 &&\n                    sentinel.ip &&\n                    sentinel.port) {\n                    const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n                    if (this.sentinelIterator.add(endpoint)) {\n                        debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n                    }\n                }\n            });\n            debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n            callback(null);\n        });\n    }\n    resolveMaster(client, callback) {\n        client.sentinel(\"get-master-addr-by-name\", this.options.name, (err, result) => {\n            if (err) {\n                client.disconnect();\n                return callback(err);\n            }\n            this.updateSentinels(client, err => {\n                client.disconnect();\n                if (err) {\n                    return callback(err);\n                }\n                callback(null, this.sentinelNatResolve(Array.isArray(result)\n                    ? { host: result[0], port: Number(result[1]) }\n                    : null));\n            });\n        });\n    }\n    resolveSlave(client, callback) {\n        client.sentinel(\"slaves\", this.options.name, (err, result) => {\n            client.disconnect();\n            if (err) {\n                return callback(err);\n            }\n            if (!Array.isArray(result)) {\n                return callback(null, null);\n            }\n            const availableSlaves = result\n                .map(utils_1.packObject)\n                .filter(slave => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n            callback(null, this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves)));\n        });\n    }\n    sentinelNatResolve(item) {\n        if (!item || !this.options.natMap)\n            return item;\n        return this.options.natMap[`${item.host}:${item.port}`] || item;\n    }\n    resolve(endpoint, callback) {\n        var client = new redis_1.default({\n            port: endpoint.port || 26379,\n            host: endpoint.host,\n            password: this.options.sentinelPassword || null,\n            family: endpoint.family ||\n                (StandaloneConnector_1.isIIpcConnectionOptions(this.options)\n                    ? undefined\n                    : this.options.family),\n            tls: this.options.sentinelTLS,\n            retryStrategy: null,\n            enableReadyCheck: false,\n            connectTimeout: this.options.connectTimeout,\n            dropBufferSupport: true\n        });\n        // ignore the errors since resolve* methods will handle them\n        client.on(\"error\", noop);\n        if (this.options.role === \"slave\") {\n            this.resolveSlave(client, callback);\n        }\n        else {\n            this.resolveMaster(client, callback);\n        }\n    }\n}\nexports.default = SentinelConnector;\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n    if (availableSlaves.length === 0) {\n        return null;\n    }\n    let selectedSlave;\n    if (typeof preferredSlaves === \"function\") {\n        selectedSlave = preferredSlaves(availableSlaves);\n    }\n    else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n        const preferredSlavesArray = Array.isArray(preferredSlaves)\n            ? preferredSlaves\n            : [preferredSlaves];\n        // sort by priority\n        preferredSlavesArray.sort((a, b) => {\n            // default the priority to 1\n            if (!a.prio) {\n                a.prio = 1;\n            }\n            if (!b.prio) {\n                b.prio = 1;\n            }\n            // lowest priority first\n            if (a.prio < b.prio) {\n                return -1;\n            }\n            if (a.prio > b.prio) {\n                return 1;\n            }\n            return 0;\n        });\n        // loop over preferred slaves and return the first match\n        for (let p = 0; p < preferredSlavesArray.length; p++) {\n            for (let a = 0; a < availableSlaves.length; a++) {\n                const slave = availableSlaves[a];\n                if (slave.ip === preferredSlavesArray[p].ip) {\n                    if (slave.port === preferredSlavesArray[p].port) {\n                        selectedSlave = slave;\n                        break;\n                    }\n                }\n            }\n            if (selectedSlave) {\n                break;\n            }\n        }\n    }\n    // if none of the preferred slaves are available, a random available slave is returned\n    if (!selectedSlave) {\n        selectedSlave = utils_1.sample(availableSlaves);\n    }\n    return addressResponseToAddress(selectedSlave);\n}\nfunction addressResponseToAddress(input) {\n    return { host: input.ip, port: Number(input.port) };\n}\nfunction noop() { }\n"]},"metadata":{},"sourceType":"script"}