{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst command_1 = require(\"../command\");\n\nconst errors_1 = require(\"../errors\");\n\nconst utils_1 = require(\"../utils\");\n\nconst DataHandler_1 = require(\"../DataHandler\");\n\nconst debug = utils_1.Debug(\"connection\");\n\nfunction connectHandler(self) {\n  return function () {\n    self.setStatus(\"connect\");\n    self.resetCommandQueue(); // AUTH command should be processed before any other commands\n\n    let flushed = false;\n    const {\n      connectionEpoch\n    } = self;\n\n    if (self.condition.auth) {\n      self.auth(self.condition.auth, function (err) {\n        if (connectionEpoch !== self.connectionEpoch) {\n          return;\n        }\n\n        if (err) {\n          if (err.message.indexOf(\"no password is set\") === -1) {\n            flushed = true;\n            self.recoverFromFatalError(err, err);\n          } else {\n            console.warn(\"[WARN] Redis server does not require a password, but a password was supplied.\");\n          }\n        }\n      });\n    }\n\n    if (self.condition.select) {\n      self.select(self.condition.select);\n    }\n\n    if (!self.options.enableReadyCheck) {\n      exports.readyHandler(self)();\n    }\n    /*\n      No need to keep the reference of DataHandler here\n      because we don't need to do the cleanup.\n      `Stream#end()` will remove all listeners for us.\n    */\n\n\n    new DataHandler_1.default(self, {\n      stringNumbers: self.options.stringNumbers,\n      dropBufferSupport: self.options.dropBufferSupport\n    });\n\n    if (self.options.enableReadyCheck) {\n      self._readyCheck(function (err, info) {\n        if (connectionEpoch !== self.connectionEpoch) {\n          return;\n        }\n\n        if (err) {\n          if (!flushed) {\n            self.recoverFromFatalError(new Error(\"Ready check failed: \" + err.message), err);\n          }\n        } else {\n          self.serverInfo = info;\n\n          if (self.connector.check(info)) {\n            exports.readyHandler(self)();\n          } else {\n            self.disconnect(true);\n          }\n        }\n      });\n    }\n  };\n}\n\nexports.connectHandler = connectHandler;\n\nfunction closeHandler(self) {\n  return function () {\n    self.setStatus(\"close\");\n\n    if (!self.prevCondition) {\n      self.prevCondition = self.condition;\n    }\n\n    if (self.commandQueue.length) {\n      self.prevCommandQueue = self.commandQueue;\n    }\n\n    if (self.manuallyClosing) {\n      self.manuallyClosing = false;\n      debug(\"skip reconnecting since the connection is manually closed.\");\n      return close();\n    }\n\n    if (typeof self.options.retryStrategy !== \"function\") {\n      debug(\"skip reconnecting because `retryStrategy` is not a function\");\n      return close();\n    }\n\n    const retryDelay = self.options.retryStrategy(++self.retryAttempts);\n\n    if (typeof retryDelay !== \"number\") {\n      debug(\"skip reconnecting because `retryStrategy` doesn't return a number\");\n      return close();\n    }\n\n    debug(\"reconnect in %sms\", retryDelay);\n    self.setStatus(\"reconnecting\", retryDelay);\n    self.reconnectTimeout = setTimeout(function () {\n      self.reconnectTimeout = null;\n      self.connect().catch(utils_1.noop);\n    }, retryDelay);\n    const {\n      maxRetriesPerRequest\n    } = self.options;\n\n    if (typeof maxRetriesPerRequest === \"number\") {\n      if (maxRetriesPerRequest < 0) {\n        debug(\"maxRetriesPerRequest is negative, ignoring...\");\n      } else {\n        const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);\n\n        if (remainder === 0) {\n          debug(\"reach maxRetriesPerRequest limitation, flushing command queue...\");\n          self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));\n        }\n      }\n    }\n  };\n\n  function close() {\n    self.setStatus(\"end\");\n    self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n  }\n}\n\nexports.closeHandler = closeHandler;\n\nfunction errorHandler(self) {\n  return function (error) {\n    debug(\"error: %s\", error);\n    self.silentEmit(\"error\", error);\n  };\n}\n\nexports.errorHandler = errorHandler;\n\nfunction readyHandler(self) {\n  return function () {\n    self.setStatus(\"ready\");\n    self.retryAttempts = 0;\n\n    if (self.options.monitor) {\n      self.call(\"monitor\");\n      const {\n        sendCommand\n      } = self;\n\n      self.sendCommand = function (command) {\n        if (command_1.default.checkFlag(\"VALID_IN_MONITOR_MODE\", command.name)) {\n          return sendCommand.call(self, command);\n        }\n\n        command.reject(new Error(\"Connection is in monitoring mode, can't process commands.\"));\n        return command.promise;\n      };\n\n      self.once(\"close\", function () {\n        delete self.sendCommand;\n      });\n      self.setStatus(\"monitoring\");\n      return;\n    }\n\n    const finalSelect = self.prevCondition ? self.prevCondition.select : self.condition.select;\n\n    if (self.options.connectionName) {\n      debug(\"set the connection name [%s]\", self.options.connectionName);\n      self.client(\"setname\", self.options.connectionName).catch(utils_1.noop);\n    }\n\n    if (self.options.readOnly) {\n      debug(\"set the connection to readonly mode\");\n      self.readonly().catch(utils_1.noop);\n    }\n\n    if (self.prevCondition) {\n      const condition = self.prevCondition;\n      self.prevCondition = null;\n\n      if (condition.subscriber && self.options.autoResubscribe) {\n        // We re-select the previous db first since\n        // `SELECT` command is not valid in sub mode.\n        if (self.condition.select !== finalSelect) {\n          debug(\"connect to db [%d]\", finalSelect);\n          self.select(finalSelect);\n        }\n\n        const subscribeChannels = condition.subscriber.channels(\"subscribe\");\n\n        if (subscribeChannels.length) {\n          debug(\"subscribe %d channels\", subscribeChannels.length);\n          self.subscribe(subscribeChannels);\n        }\n\n        const psubscribeChannels = condition.subscriber.channels(\"psubscribe\");\n\n        if (psubscribeChannels.length) {\n          debug(\"psubscribe %d channels\", psubscribeChannels.length);\n          self.psubscribe(psubscribeChannels);\n        }\n      }\n    }\n\n    if (self.prevCommandQueue) {\n      if (self.options.autoResendUnfulfilledCommands) {\n        debug(\"resend %d unfulfilled commands\", self.prevCommandQueue.length);\n\n        while (self.prevCommandQueue.length > 0) {\n          const item = self.prevCommandQueue.shift();\n\n          if (item.select !== self.condition.select && item.command.name !== \"select\") {\n            self.select(item.select);\n          }\n\n          self.sendCommand(item.command, item.stream);\n        }\n      } else {\n        self.prevCommandQueue = null;\n      }\n    }\n\n    if (self.offlineQueue.length) {\n      debug(\"send %d commands in offline queue\", self.offlineQueue.length);\n      const offlineQueue = self.offlineQueue;\n      self.resetOfflineQueue();\n\n      while (offlineQueue.length > 0) {\n        const item = offlineQueue.shift();\n\n        if (item.select !== self.condition.select && item.command.name !== \"select\") {\n          self.select(item.select);\n        }\n\n        self.sendCommand(item.command, item.stream);\n      }\n    }\n\n    if (self.condition.select !== finalSelect) {\n      debug(\"connect to db [%d]\", finalSelect);\n      self.select(finalSelect);\n    }\n  };\n}\n\nexports.readyHandler = readyHandler;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/redis/event_handler.js"],"names":["Object","defineProperty","exports","value","command_1","require","errors_1","utils_1","DataHandler_1","debug","Debug","connectHandler","self","setStatus","resetCommandQueue","flushed","connectionEpoch","condition","auth","err","message","indexOf","recoverFromFatalError","console","warn","select","options","enableReadyCheck","readyHandler","default","stringNumbers","dropBufferSupport","_readyCheck","info","Error","serverInfo","connector","check","disconnect","closeHandler","prevCondition","commandQueue","length","prevCommandQueue","manuallyClosing","close","retryStrategy","retryDelay","retryAttempts","reconnectTimeout","setTimeout","connect","catch","noop","maxRetriesPerRequest","remainder","flushQueue","MaxRetriesPerRequestError","CONNECTION_CLOSED_ERROR_MSG","errorHandler","error","silentEmit","monitor","call","sendCommand","command","checkFlag","name","reject","promise","once","finalSelect","connectionName","client","readOnly","readonly","subscriber","autoResubscribe","subscribeChannels","channels","subscribe","psubscribeChannels","psubscribe","autoResendUnfulfilledCommands","item","shift","stream","offlineQueue","resetOfflineQueue"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst command_1 = require(\"../command\");\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"../utils\");\nconst DataHandler_1 = require(\"../DataHandler\");\nconst debug = utils_1.Debug(\"connection\");\nfunction connectHandler(self) {\n    return function () {\n        self.setStatus(\"connect\");\n        self.resetCommandQueue();\n        // AUTH command should be processed before any other commands\n        let flushed = false;\n        const { connectionEpoch } = self;\n        if (self.condition.auth) {\n            self.auth(self.condition.auth, function (err) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (err.message.indexOf(\"no password is set\") === -1) {\n                        flushed = true;\n                        self.recoverFromFatalError(err, err);\n                    }\n                    else {\n                        console.warn(\"[WARN] Redis server does not require a password, but a password was supplied.\");\n                    }\n                }\n            });\n        }\n        if (self.condition.select) {\n            self.select(self.condition.select);\n        }\n        if (!self.options.enableReadyCheck) {\n            exports.readyHandler(self)();\n        }\n        /*\n          No need to keep the reference of DataHandler here\n          because we don't need to do the cleanup.\n          `Stream#end()` will remove all listeners for us.\n        */\n        new DataHandler_1.default(self, {\n            stringNumbers: self.options.stringNumbers,\n            dropBufferSupport: self.options.dropBufferSupport\n        });\n        if (self.options.enableReadyCheck) {\n            self._readyCheck(function (err, info) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (!flushed) {\n                        self.recoverFromFatalError(new Error(\"Ready check failed: \" + err.message), err);\n                    }\n                }\n                else {\n                    self.serverInfo = info;\n                    if (self.connector.check(info)) {\n                        exports.readyHandler(self)();\n                    }\n                    else {\n                        self.disconnect(true);\n                    }\n                }\n            });\n        }\n    };\n}\nexports.connectHandler = connectHandler;\nfunction closeHandler(self) {\n    return function () {\n        self.setStatus(\"close\");\n        if (!self.prevCondition) {\n            self.prevCondition = self.condition;\n        }\n        if (self.commandQueue.length) {\n            self.prevCommandQueue = self.commandQueue;\n        }\n        if (self.manuallyClosing) {\n            self.manuallyClosing = false;\n            debug(\"skip reconnecting since the connection is manually closed.\");\n            return close();\n        }\n        if (typeof self.options.retryStrategy !== \"function\") {\n            debug(\"skip reconnecting because `retryStrategy` is not a function\");\n            return close();\n        }\n        const retryDelay = self.options.retryStrategy(++self.retryAttempts);\n        if (typeof retryDelay !== \"number\") {\n            debug(\"skip reconnecting because `retryStrategy` doesn't return a number\");\n            return close();\n        }\n        debug(\"reconnect in %sms\", retryDelay);\n        self.setStatus(\"reconnecting\", retryDelay);\n        self.reconnectTimeout = setTimeout(function () {\n            self.reconnectTimeout = null;\n            self.connect().catch(utils_1.noop);\n        }, retryDelay);\n        const { maxRetriesPerRequest } = self.options;\n        if (typeof maxRetriesPerRequest === \"number\") {\n            if (maxRetriesPerRequest < 0) {\n                debug(\"maxRetriesPerRequest is negative, ignoring...\");\n            }\n            else {\n                const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);\n                if (remainder === 0) {\n                    debug(\"reach maxRetriesPerRequest limitation, flushing command queue...\");\n                    self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));\n                }\n            }\n        }\n    };\n    function close() {\n        self.setStatus(\"end\");\n        self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n    }\n}\nexports.closeHandler = closeHandler;\nfunction errorHandler(self) {\n    return function (error) {\n        debug(\"error: %s\", error);\n        self.silentEmit(\"error\", error);\n    };\n}\nexports.errorHandler = errorHandler;\nfunction readyHandler(self) {\n    return function () {\n        self.setStatus(\"ready\");\n        self.retryAttempts = 0;\n        if (self.options.monitor) {\n            self.call(\"monitor\");\n            const { sendCommand } = self;\n            self.sendCommand = function (command) {\n                if (command_1.default.checkFlag(\"VALID_IN_MONITOR_MODE\", command.name)) {\n                    return sendCommand.call(self, command);\n                }\n                command.reject(new Error(\"Connection is in monitoring mode, can't process commands.\"));\n                return command.promise;\n            };\n            self.once(\"close\", function () {\n                delete self.sendCommand;\n            });\n            self.setStatus(\"monitoring\");\n            return;\n        }\n        const finalSelect = self.prevCondition\n            ? self.prevCondition.select\n            : self.condition.select;\n        if (self.options.connectionName) {\n            debug(\"set the connection name [%s]\", self.options.connectionName);\n            self.client(\"setname\", self.options.connectionName).catch(utils_1.noop);\n        }\n        if (self.options.readOnly) {\n            debug(\"set the connection to readonly mode\");\n            self.readonly().catch(utils_1.noop);\n        }\n        if (self.prevCondition) {\n            const condition = self.prevCondition;\n            self.prevCondition = null;\n            if (condition.subscriber && self.options.autoResubscribe) {\n                // We re-select the previous db first since\n                // `SELECT` command is not valid in sub mode.\n                if (self.condition.select !== finalSelect) {\n                    debug(\"connect to db [%d]\", finalSelect);\n                    self.select(finalSelect);\n                }\n                const subscribeChannels = condition.subscriber.channels(\"subscribe\");\n                if (subscribeChannels.length) {\n                    debug(\"subscribe %d channels\", subscribeChannels.length);\n                    self.subscribe(subscribeChannels);\n                }\n                const psubscribeChannels = condition.subscriber.channels(\"psubscribe\");\n                if (psubscribeChannels.length) {\n                    debug(\"psubscribe %d channels\", psubscribeChannels.length);\n                    self.psubscribe(psubscribeChannels);\n                }\n            }\n        }\n        if (self.prevCommandQueue) {\n            if (self.options.autoResendUnfulfilledCommands) {\n                debug(\"resend %d unfulfilled commands\", self.prevCommandQueue.length);\n                while (self.prevCommandQueue.length > 0) {\n                    const item = self.prevCommandQueue.shift();\n                    if (item.select !== self.condition.select &&\n                        item.command.name !== \"select\") {\n                        self.select(item.select);\n                    }\n                    self.sendCommand(item.command, item.stream);\n                }\n            }\n            else {\n                self.prevCommandQueue = null;\n            }\n        }\n        if (self.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", self.offlineQueue.length);\n            const offlineQueue = self.offlineQueue;\n            self.resetOfflineQueue();\n            while (offlineQueue.length > 0) {\n                const item = offlineQueue.shift();\n                if (item.select !== self.condition.select &&\n                    item.command.name !== \"select\") {\n                    self.select(item.select);\n                }\n                self.sendCommand(item.command, item.stream);\n            }\n        }\n        if (self.condition.select !== finalSelect) {\n            debug(\"connect to db [%d]\", finalSelect);\n            self.select(finalSelect);\n        }\n    };\n}\nexports.readyHandler = readyHandler;\n"]},"metadata":{},"sourceType":"script"}