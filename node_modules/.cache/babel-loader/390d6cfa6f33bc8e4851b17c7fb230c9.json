{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar ClusterAllFailedError_1 = require(\"../errors/ClusterAllFailedError\");\n\nvar utils_1 = require(\"../utils\");\n\nvar ConnectionPool_1 = require(\"./ConnectionPool\");\n\nvar util_1 = require(\"./util\");\n\nvar ClusterSubscriber_1 = require(\"./ClusterSubscriber\");\n\nvar DelayQueue_1 = require(\"./DelayQueue\");\n\nvar ScanStream_1 = require(\"../ScanStream\");\n\nvar redis_errors_1 = require(\"redis-errors\");\n\nvar standard_as_callback_1 = require(\"standard-as-callback\");\n\nvar PromiseContainer = require(\"../promiseContainer\");\n\nvar ClusterOptions_1 = require(\"./ClusterOptions\");\n\nvar utils_2 = require(\"../utils\");\n\nvar commands = require(\"redis-commands\");\n\nvar command_1 = require(\"../command\");\n\nvar redis_1 = require(\"../redis\");\n\nvar commander_1 = require(\"../commander\");\n\nvar Deque = require(\"denque\");\n\nvar debug = utils_1.Debug(\"cluster\");\n/**\n * Client for the official Redis Cluster\n *\n * @class Cluster\n * @extends {EventEmitter}\n */\n\nvar Cluster =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(Cluster, _events_1$EventEmitte);\n\n  /**\n   * Creates an instance of Cluster.\n   *\n   * @param {(Array<string | number | object>)} startupNodes\n   * @param {IClusterOptions} [options={}]\n   * @memberof Cluster\n   */\n  function Cluster(startupNodes) {\n    var _this2;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Cluster);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Cluster).call(this));\n    _this2.slots = [];\n    _this2.retryAttempts = 0;\n    _this2.delayQueue = new DelayQueue_1.default();\n    _this2.offlineQueue = new Deque();\n    _this2.isRefreshing = false;\n    /**\n     * Every time Cluster#connect() is called, this value will be\n     * auto-incrementing. The purpose of this value is used for\n     * discarding previous connect attampts when creating a new\n     * connection.\n     *\n     * @private\n     * @type {number}\n     * @memberof Cluster\n     */\n\n    _this2.connectionEpoch = 0;\n    commander_1.default.call(_assertThisInitialized(_this2));\n    _this2.startupNodes = startupNodes;\n    _this2.options = utils_1.defaults({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, _this2.options); // validate options\n\n    if (typeof _this2.options.scaleReads !== \"function\" && [\"all\", \"master\", \"slave\"].indexOf(_this2.options.scaleReads) === -1) {\n      throw new Error('Invalid option scaleReads \"' + _this2.options.scaleReads + '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n    }\n\n    _this2.connectionPool = new ConnectionPool_1.default(_this2.options.redisOptions);\n\n    _this2.connectionPool.on(\"-node\", function (redis, key) {\n      _this2.emit(\"-node\", redis);\n    });\n\n    _this2.connectionPool.on(\"+node\", function (redis) {\n      _this2.emit(\"+node\", redis);\n    });\n\n    _this2.connectionPool.on(\"drain\", function () {\n      _this2.setStatus(\"close\");\n    });\n\n    _this2.connectionPool.on(\"nodeError\", function (error, key) {\n      _this2.emit(\"node error\", error, key);\n    });\n\n    _this2.subscriber = new ClusterSubscriber_1.default(_this2.connectionPool, _assertThisInitialized(_this2));\n\n    if (_this2.options.lazyConnect) {\n      _this2.setStatus(\"wait\");\n    } else {\n      _this2.connect().catch(function (err) {\n        debug(\"connecting failed: %s\", err);\n      });\n    }\n\n    return _this2;\n  }\n\n  _createClass(Cluster, [{\n    key: \"resetOfflineQueue\",\n    value: function resetOfflineQueue() {\n      this.offlineQueue = new Deque();\n    }\n  }, {\n    key: \"clearNodesRefreshInterval\",\n    value: function clearNodesRefreshInterval() {\n      if (this.slotsTimer) {\n        clearTimeout(this.slotsTimer);\n        this.slotsTimer = null;\n      }\n    }\n  }, {\n    key: \"resetNodesRefreshInterval\",\n    value: function resetNodesRefreshInterval() {\n      var _this3 = this;\n\n      if (this.slotsTimer) {\n        return;\n      }\n\n      var nextRound = function nextRound() {\n        _this3.slotsTimer = setTimeout(function () {\n          debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n\n          _this3.refreshSlotsCache(function () {\n            nextRound();\n          });\n        }, _this3.options.slotsRefreshInterval);\n      };\n\n      nextRound();\n    }\n    /**\n     * Connect to a cluster\n     *\n     * @returns {Promise<void>}\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this4 = this;\n\n      var Promise = PromiseContainer.get();\n      return new Promise(function (resolve, reject) {\n        if (_this4.status === \"connecting\" || _this4.status === \"connect\" || _this4.status === \"ready\") {\n          reject(new Error(\"Redis is already connecting/connected\"));\n          return;\n        }\n\n        var epoch = ++_this4.connectionEpoch;\n\n        _this4.setStatus(\"connecting\");\n\n        _this4.resolveStartupNodeHostnames().then(function (nodes) {\n          if (_this4.connectionEpoch !== epoch) {\n            debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, _this4.connectionEpoch);\n            reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n            return;\n          }\n\n          if (_this4.status !== \"connecting\") {\n            debug(\"discard connecting after resolving startup nodes because the status changed to %s\", _this4.status);\n            reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n            return;\n          }\n\n          _this4.connectionPool.reset(nodes);\n\n          function readyHandler() {\n            this.setStatus(\"ready\");\n            this.retryAttempts = 0;\n            this.executeOfflineCommands();\n            this.resetNodesRefreshInterval();\n            resolve();\n          }\n\n          var closeListener;\n\n          var refreshListener = function refreshListener() {\n            _this4.removeListener(\"close\", closeListener);\n\n            _this4.manuallyClosing = false;\n\n            _this4.setStatus(\"connect\");\n\n            if (_this4.options.enableReadyCheck) {\n              _this4.readyCheck(function (err, fail) {\n                if (err || fail) {\n                  debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n\n                  if (_this4.status === \"connect\") {\n                    _this4.disconnect(true);\n                  }\n                } else {\n                  readyHandler.call(_this4);\n                }\n              });\n            } else {\n              readyHandler.call(_this4);\n            }\n          };\n\n          closeListener = function closeListener() {\n            this.removeListener(\"refresh\", refreshListener);\n            reject(new Error(\"None of startup nodes is available\"));\n          };\n\n          _this4.once(\"refresh\", refreshListener);\n\n          _this4.once(\"close\", closeListener);\n\n          _this4.once(\"close\", _this4.handleCloseEvent.bind(_this4));\n\n          _this4.refreshSlotsCache(function (err) {\n            if (err && err.message === \"Failed to refresh slots cache.\") {\n              redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n              this.connectionPool.reset([]);\n            }\n          }.bind(_this4));\n\n          _this4.subscriber.start();\n        }).catch(function (err) {\n          _this4.setStatus(\"close\");\n\n          _this4.handleCloseEvent(err);\n\n          reject(err);\n        });\n      });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     *\n     * @private\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"handleCloseEvent\",\n    value: function handleCloseEvent(reason) {\n      if (reason) {\n        debug(\"closed because %s\", reason);\n      }\n\n      var retryDelay;\n\n      if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === \"function\") {\n        retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n      }\n\n      if (typeof retryDelay === \"number\") {\n        this.setStatus(\"reconnecting\");\n        this.reconnectTimeout = setTimeout(function () {\n          this.reconnectTimeout = null;\n          debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n          this.connect().catch(function (err) {\n            debug(\"Got error %s when reconnecting. Ignoring...\", err);\n          });\n        }.bind(this), retryDelay);\n      } else {\n        this.setStatus(\"end\");\n        this.flushQueue(new Error(\"None of startup nodes is available\"));\n      }\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     *\n     * @param {boolean} [reconnect=false]\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var reconnect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var status = this.status;\n      this.setStatus(\"disconnecting\");\n\n      if (!reconnect) {\n        this.manuallyClosing = true;\n      }\n\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n        debug(\"Canceled reconnecting attempts\");\n      }\n\n      this.clearNodesRefreshInterval();\n      this.subscriber.stop();\n\n      if (status === \"wait\") {\n        this.setStatus(\"close\");\n        this.handleCloseEvent();\n      } else {\n        this.connectionPool.reset([]);\n      }\n    }\n    /**\n     * Quit the cluster gracefully.\n     *\n     * @param {CallbackFunction<'OK'>} [callback]\n     * @returns {Promise<'OK'>}\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"quit\",\n    value: function quit(callback) {\n      var status = this.status;\n      this.setStatus(\"disconnecting\");\n      this.manuallyClosing = true;\n\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n      }\n\n      this.clearNodesRefreshInterval();\n      this.subscriber.stop();\n      var Promise = PromiseContainer.get();\n\n      if (status === \"wait\") {\n        var ret = standard_as_callback_1.default(Promise.resolve(\"OK\"), callback); // use setImmediate to make sure \"close\" event\n        // being emitted after quit() is returned\n\n        setImmediate(function () {\n          this.setStatus(\"close\");\n          this.handleCloseEvent();\n        }.bind(this));\n        return ret;\n      }\n\n      return standard_as_callback_1.default(Promise.all(this.nodes().map(function (node) {\n        return node.quit().catch(function (err) {\n          // Ignore the error caused by disconnecting since\n          // we're disconnecting...\n          if (err.message === utils_2.CONNECTION_CLOSED_ERROR_MSG) {\n            return \"OK\";\n          }\n\n          throw err;\n        });\n      })).then(function () {\n        return \"OK\";\n      }), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     *\n     * @public\n     * @param {(Array<string | number | object>)} [overrideStartupNodes=[]]\n     * @param {IClusterOptions} [overrideOptions={}]\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"duplicate\",\n    value: function duplicate() {\n      var overrideStartupNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var overrideOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);\n      var options = Object.assign({}, this.options, overrideOptions);\n      return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     *\n     * @param {NodeRole} [role='all']\n     * @returns {any[]}\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"nodes\",\n    value: function nodes() {\n      var role = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"all\";\n\n      if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n        throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n      }\n\n      return this.connectionPool.getNodes(role);\n    }\n    /**\n     * Change cluster instance's status\n     *\n     * @private\n     * @param {ClusterStatus} status\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"setStatus\",\n    value: function setStatus(status) {\n      var _this5 = this;\n\n      debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n      this.status = status;\n      process.nextTick(function () {\n        _this5.emit(status);\n      });\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @private\n     * @param {CallbackFunction} [callback]\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"refreshSlotsCache\",\n    value: function refreshSlotsCache(callback) {\n      if (this.isRefreshing) {\n        if (typeof callback === \"function\") {\n          process.nextTick(callback);\n        }\n\n        return;\n      }\n\n      this.isRefreshing = true;\n\n      var _this = this;\n\n      var wrapper = function wrapper(error) {\n        _this.isRefreshing = false;\n\n        if (typeof callback === \"function\") {\n          callback(error);\n        }\n      };\n\n      var nodes = utils_2.shuffle(this.connectionPool.getNodes());\n      var lastNodeError = null;\n\n      function tryNode(index) {\n        if (index === nodes.length) {\n          var error = new ClusterAllFailedError_1.default(\"Failed to refresh slots cache.\", lastNodeError);\n          return wrapper(error);\n        }\n\n        var node = nodes[index];\n        var key = \"\".concat(node.options.host, \":\").concat(node.options.port);\n        debug(\"getting slot cache from %s\", key);\n\n        _this.getInfoFromNode(node, function (err) {\n          switch (_this.status) {\n            case \"close\":\n            case \"end\":\n              return wrapper(new Error(\"Cluster is disconnected.\"));\n\n            case \"disconnecting\":\n              return wrapper(new Error(\"Cluster is disconnecting.\"));\n          }\n\n          if (err) {\n            _this.emit(\"node error\", err, key);\n\n            lastNodeError = err;\n            tryNode(index + 1);\n          } else {\n            _this.emit(\"refresh\");\n\n            wrapper();\n          }\n        });\n      }\n\n      tryNode(0);\n    }\n    /**\n     * Flush offline queue with error.\n     *\n     * @param {Error} error\n     * @memberof Cluster\n     */\n\n  }, {\n    key: \"flushQueue\",\n    value: function flushQueue(error) {\n      var item;\n\n      while (this.offlineQueue.length > 0) {\n        item = this.offlineQueue.shift();\n        item.command.reject(error);\n      }\n    }\n  }, {\n    key: \"executeOfflineCommands\",\n    value: function executeOfflineCommands() {\n      if (this.offlineQueue.length) {\n        debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n        var offlineQueue = this.offlineQueue;\n        this.resetOfflineQueue();\n\n        while (offlineQueue.length > 0) {\n          var item = offlineQueue.shift();\n          this.sendCommand(item.command, item.stream, item.node);\n        }\n      }\n    }\n  }, {\n    key: \"natMapper\",\n    value: function natMapper(nodeKey) {\n      if (this.options.natMap && typeof this.options.natMap === \"object\") {\n        var key = typeof nodeKey === \"string\" ? nodeKey : \"\".concat(nodeKey.host, \":\").concat(nodeKey.port);\n        var mapped = this.options.natMap[key];\n\n        if (mapped) {\n          debug(\"NAT mapping %s -> %O\", key, mapped);\n          return Object.assign({}, mapped);\n        }\n      }\n\n      return typeof nodeKey === \"string\" ? util_1.nodeKeyToRedisOptions(nodeKey) : nodeKey;\n    }\n  }, {\n    key: \"sendCommand\",\n    value: function sendCommand(command, stream, node) {\n      if (this.status === \"wait\") {\n        this.connect().catch(utils_1.noop);\n      }\n\n      if (this.status === \"end\") {\n        command.reject(new Error(utils_2.CONNECTION_CLOSED_ERROR_MSG));\n        return command.promise;\n      }\n\n      var to = this.options.scaleReads;\n\n      if (to !== \"master\") {\n        var isCommandReadOnly = command.isReadOnly || commands.exists(command.name) && commands.hasFlag(command.name, \"readonly\");\n\n        if (!isCommandReadOnly) {\n          to = \"master\";\n        }\n      }\n\n      var targetSlot = node ? node.slot : command.getSlot();\n      var ttl = {};\n\n      var _this = this;\n\n      if (!node && !command.__is_reject_overwritten) {\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        command.__is_reject_overwritten = true;\n        var reject = command.reject;\n\n        command.reject = function (err) {\n          var partialTry = tryConnection.bind(null, true);\n\n          _this.handleError(err, ttl, {\n            moved: function moved(slot, key) {\n              debug(\"command %s is moved to %s\", command.name, key);\n              targetSlot = Number(slot);\n\n              if (_this.slots[slot]) {\n                _this.slots[slot][0] = key;\n              } else {\n                _this.slots[slot] = [key];\n              }\n\n              _this.connectionPool.findOrCreate(_this.natMapper(key));\n\n              tryConnection();\n              debug(\"refreshing slot caches... (triggered by MOVED error)\");\n\n              _this.refreshSlotsCache();\n            },\n            ask: function ask(slot, key) {\n              debug(\"command %s is required to ask %s:%s\", command.name, key);\n\n              var mapped = _this.natMapper(key);\n\n              _this.connectionPool.findOrCreate(mapped);\n\n              tryConnection(false, \"\".concat(mapped.host, \":\").concat(mapped.port));\n            },\n            tryagain: partialTry,\n            clusterDown: partialTry,\n            connectionClosed: partialTry,\n            maxRedirections: function maxRedirections(redirectionError) {\n              reject.call(command, redirectionError);\n            },\n            defaults: function defaults() {\n              reject.call(command, err);\n            }\n          });\n        };\n      }\n\n      tryConnection();\n\n      function tryConnection(random, asking) {\n        if (_this.status === \"end\") {\n          command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n          return;\n        }\n\n        var redis;\n\n        if (_this.status === \"ready\" || command.name === \"cluster\") {\n          if (node && node.redis) {\n            redis = node.redis;\n          } else if (command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) || command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n            redis = _this.subscriber.getInstance();\n\n            if (!redis) {\n              command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n              return;\n            }\n          } else {\n            if (!random) {\n              if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                var nodeKeys = _this.slots[targetSlot];\n\n                if (typeof to === \"function\") {\n                  var nodes = nodeKeys.map(function (key) {\n                    return _this.connectionPool.getInstanceByKey(key);\n                  });\n                  redis = to(nodes, command);\n\n                  if (Array.isArray(redis)) {\n                    redis = utils_2.sample(redis);\n                  }\n\n                  if (!redis) {\n                    redis = nodes[0];\n                  }\n                } else {\n                  var key;\n\n                  if (to === \"all\") {\n                    key = utils_2.sample(nodeKeys);\n                  } else if (to === \"slave\" && nodeKeys.length > 1) {\n                    key = utils_2.sample(nodeKeys, 1);\n                  } else {\n                    key = nodeKeys[0];\n                  }\n\n                  redis = _this.connectionPool.getInstanceByKey(key);\n                }\n              }\n\n              if (asking) {\n                redis = _this.connectionPool.getInstanceByKey(asking);\n                redis.asking();\n              }\n            }\n\n            if (!redis) {\n              redis = (typeof to === \"function\" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance(\"all\");\n            }\n          }\n\n          if (node && !node.redis) {\n            node.redis = redis;\n          }\n        }\n\n        if (redis) {\n          redis.sendCommand(command, stream);\n        } else if (_this.options.enableOfflineQueue) {\n          _this.offlineQueue.push({\n            command: command,\n            stream: stream,\n            node: node\n          });\n        } else {\n          command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n        }\n      }\n\n      return command.promise;\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(error, ttl, handlers) {\n      if (typeof ttl.value === \"undefined\") {\n        ttl.value = this.options.maxRedirections;\n      } else {\n        ttl.value -= 1;\n      }\n\n      if (ttl.value <= 0) {\n        handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n        return;\n      }\n\n      var errv = error.message.split(\" \");\n\n      if (errv[0] === \"MOVED\" || errv[0] === \"ASK\") {\n        handlers[errv[0] === \"MOVED\" ? \"moved\" : \"ask\"](errv[1], errv[2]);\n      } else if (errv[0] === \"TRYAGAIN\") {\n        this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n          timeout: this.options.retryDelayOnTryAgain\n        });\n      } else if (errv[0] === \"CLUSTERDOWN\" && this.options.retryDelayOnClusterDown > 0) {\n        this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n          timeout: this.options.retryDelayOnClusterDown,\n          callback: this.refreshSlotsCache.bind(this)\n        });\n      } else if (error.message === utils_2.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === \"ready\") {\n        this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n          timeout: this.options.retryDelayOnFailover,\n          callback: this.refreshSlotsCache.bind(this)\n        });\n      } else {\n        handlers.defaults();\n      }\n    }\n  }, {\n    key: \"getInfoFromNode\",\n    value: function getInfoFromNode(redis, callback) {\n      var _this6 = this;\n\n      if (!redis) {\n        return callback(new Error(\"Node is disconnected\"));\n      } // Use a duplication of the connection to avoid\n      // timeouts when the connection is in the blocking\n      // mode (e.g. waiting for BLPOP).\n\n\n      var duplicatedConnection = redis.duplicate({\n        enableOfflineQueue: true,\n        enableReadyCheck: false,\n        retryStrategy: null,\n        connectionName: \"ioredisClusterRefresher\"\n      }); // Ignore error events since we will handle\n      // exceptions for the CLUSTER SLOTS command.\n\n      duplicatedConnection.on(\"error\", utils_1.noop);\n      duplicatedConnection.cluster(\"slots\", utils_2.timeout(function (err, result) {\n        duplicatedConnection.disconnect();\n\n        if (err) {\n          return callback(err);\n        }\n\n        if (_this6.status === \"disconnecting\" || _this6.status === \"close\" || _this6.status === \"end\") {\n          debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, _this6.status);\n          callback();\n          return;\n        }\n\n        var nodes = [];\n        debug(\"cluster slots result count: %d\", result.length);\n\n        for (var i = 0; i < result.length; ++i) {\n          var items = result[i];\n          var slotRangeStart = items[0];\n          var slotRangeEnd = items[1];\n          var keys = [];\n\n          for (var j = 2; j < items.length; j++) {\n            if (!items[j][0]) {\n              continue;\n            }\n\n            items[j] = _this6.natMapper({\n              host: items[j][0],\n              port: items[j][1]\n            });\n            items[j].readOnly = j !== 2;\n            nodes.push(items[j]);\n            keys.push(items[j].host + \":\" + items[j].port);\n          }\n\n          debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n\n          for (var slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n            _this6.slots[slot] = keys;\n          }\n        }\n\n        _this6.connectionPool.reset(nodes);\n\n        callback();\n      }, this.options.slotsRefreshTimeout));\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     *\n     * @param {Function} callback\n     * @private\n     */\n\n  }, {\n    key: \"readyCheck\",\n    value: function readyCheck(callback) {\n      this.cluster(\"info\", function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (typeof res !== \"string\") {\n          return callback();\n        }\n\n        var state;\n        var lines = res.split(\"\\r\\n\");\n\n        for (var i = 0; i < lines.length; ++i) {\n          var parts = lines[i].split(\":\");\n\n          if (parts[0] === \"cluster_state\") {\n            state = parts[1];\n            break;\n          }\n        }\n\n        if (state === \"fail\") {\n          debug(\"cluster state not ok (%s)\", state);\n          callback(null, state);\n        } else {\n          callback();\n        }\n      });\n    }\n  }, {\n    key: \"dnsLookup\",\n    value: function dnsLookup(hostname) {\n      var _this7 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this7.options.dnsLookup(hostname, function (err, address) {\n          if (err) {\n            debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n            reject(err);\n          } else {\n            debug(\"resolved hostname %s to IP %s\", hostname, address);\n            resolve(address);\n          }\n        });\n      });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     *\n     * @private\n     * @returns {Promise<IRedisOptions[]>}\n     */\n\n  }, {\n    key: \"resolveStartupNodeHostnames\",\n    value: function resolveStartupNodeHostnames() {\n      var _this8 = this;\n\n      if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n        return Promise.reject(new Error(\"`startupNodes` should contain at least one node.\"));\n      }\n\n      var startupNodes = util_1.normalizeNodeOptions(this.startupNodes);\n      var hostnames = util_1.getUniqueHostnamesFromOptions(startupNodes);\n\n      if (hostnames.length === 0) {\n        return Promise.resolve(startupNodes);\n      }\n\n      return Promise.all(hostnames.map(function (hostname) {\n        return _this8.dnsLookup(hostname);\n      })).then(function (ips) {\n        var hostnameToIP = utils_2.zipMap(hostnames, ips);\n        return startupNodes.map(function (node) {\n          return hostnameToIP.has(node.host) ? Object.assign({}, node, {\n            host: hostnameToIP.get(node.host)\n          }) : node;\n        });\n      });\n    }\n  }]);\n\n  return Cluster;\n}(events_1.EventEmitter);\n\nObject.getOwnPropertyNames(commander_1.default.prototype).forEach(function (name) {\n  if (!Cluster.prototype.hasOwnProperty(name)) {\n    Cluster.prototype[name] = commander_1.default.prototype[name];\n  }\n});\nvar scanCommands = [\"sscan\", \"hscan\", \"zscan\", \"sscanBuffer\", \"hscanBuffer\", \"zscanBuffer\"];\nscanCommands.forEach(function (command) {\n  Cluster.prototype[command + \"Stream\"] = function (key, options) {\n    return new ScanStream_1.default(utils_1.defaults({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command\n    }, options));\n  };\n});\n\nrequire(\"../transaction\").addTransactionSupport(Cluster.prototype);\n\nexports.default = Cluster;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/cluster/index.js"],"names":["Object","defineProperty","exports","value","events_1","require","ClusterAllFailedError_1","utils_1","ConnectionPool_1","util_1","ClusterSubscriber_1","DelayQueue_1","ScanStream_1","redis_errors_1","standard_as_callback_1","PromiseContainer","ClusterOptions_1","utils_2","commands","command_1","redis_1","commander_1","Deque","debug","Debug","Cluster","startupNodes","options","slots","retryAttempts","delayQueue","default","offlineQueue","isRefreshing","connectionEpoch","call","defaults","DEFAULT_CLUSTER_OPTIONS","scaleReads","indexOf","Error","connectionPool","redisOptions","on","redis","key","emit","setStatus","error","subscriber","lazyConnect","connect","catch","err","slotsTimer","clearTimeout","nextRound","setTimeout","refreshSlotsCache","slotsRefreshInterval","Promise","get","resolve","reject","status","epoch","resolveStartupNodeHostnames","then","nodes","RedisError","reset","readyHandler","executeOfflineCommands","resetNodesRefreshInterval","closeListener","refreshListener","removeListener","manuallyClosing","enableReadyCheck","readyCheck","fail","disconnect","once","handleCloseEvent","bind","message","prototype","silentEmit","start","reason","retryDelay","clusterRetryStrategy","reconnectTimeout","flushQueue","reconnect","clearNodesRefreshInterval","stop","callback","ret","setImmediate","all","map","node","quit","CONNECTION_CLOSED_ERROR_MSG","overrideStartupNodes","overrideOptions","length","slice","assign","role","getNodes","process","nextTick","_this","wrapper","shuffle","lastNodeError","tryNode","index","host","port","getInfoFromNode","item","shift","command","resetOfflineQueue","sendCommand","stream","nodeKey","natMap","mapped","nodeKeyToRedisOptions","noop","promise","to","isCommandReadOnly","isReadOnly","exists","name","hasFlag","targetSlot","slot","getSlot","ttl","__is_reject_overwritten","partialTry","tryConnection","handleError","moved","Number","findOrCreate","natMapper","ask","tryagain","clusterDown","connectionClosed","maxRedirections","redirectionError","random","asking","AbortError","checkFlag","getInstance","nodeKeys","getInstanceByKey","Array","isArray","sample","getSampleInstance","enableOfflineQueue","push","handlers","errv","split","timeout","retryDelayOnTryAgain","retryDelayOnClusterDown","retryDelayOnFailover","duplicatedConnection","duplicate","retryStrategy","connectionName","cluster","result","i","items","slotRangeStart","slotRangeEnd","keys","j","readOnly","slotsRefreshTimeout","res","state","lines","parts","hostname","dnsLookup","address","normalizeNodeOptions","hostnames","getUniqueHostnamesFromOptions","ips","hostnameToIP","zipMap","has","EventEmitter","getOwnPropertyNames","forEach","hasOwnProperty","scanCommands","objectMode","addTransactionSupport"],"mappings":"AAAA;;;;;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,IAAMC,uBAAuB,GAAGD,OAAO,CAAC,iCAAD,CAAvC;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMG,gBAAgB,GAAGH,OAAO,CAAC,kBAAD,CAAhC;;AACA,IAAMI,MAAM,GAAGJ,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMK,mBAAmB,GAAGL,OAAO,CAAC,qBAAD,CAAnC;;AACA,IAAMM,YAAY,GAAGN,OAAO,CAAC,cAAD,CAA5B;;AACA,IAAMO,YAAY,GAAGP,OAAO,CAAC,eAAD,CAA5B;;AACA,IAAMQ,cAAc,GAAGR,OAAO,CAAC,cAAD,CAA9B;;AACA,IAAMS,sBAAsB,GAAGT,OAAO,CAAC,sBAAD,CAAtC;;AACA,IAAMU,gBAAgB,GAAGV,OAAO,CAAC,qBAAD,CAAhC;;AACA,IAAMW,gBAAgB,GAAGX,OAAO,CAAC,kBAAD,CAAhC;;AACA,IAAMY,OAAO,GAAGZ,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMa,QAAQ,GAAGb,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAMc,SAAS,GAAGd,OAAO,CAAC,YAAD,CAAzB;;AACA,IAAMe,OAAO,GAAGf,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMgB,WAAW,GAAGhB,OAAO,CAAC,cAAD,CAA3B;;AACA,IAAMiB,KAAK,GAAGjB,OAAO,CAAC,QAAD,CAArB;;AACA,IAAMkB,KAAK,GAAGhB,OAAO,CAACiB,KAAR,CAAc,SAAd,CAAd;AACA;;;;;;;IAMMC,O;;;;;AACF;;;;;;;AAOA,mBAAYC,YAAZ,EAAwC;AAAA;;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACpC;AACA,WAAKC,KAAL,GAAa,EAAb;AACA,WAAKC,aAAL,GAAqB,CAArB;AACA,WAAKC,UAAL,GAAkB,IAAInB,YAAY,CAACoB,OAAjB,EAAlB;AACA,WAAKC,YAAL,GAAoB,IAAIV,KAAJ,EAApB;AACA,WAAKW,YAAL,GAAoB,KAApB;AACA;;;;;;;;;;;AAUA,WAAKC,eAAL,GAAuB,CAAvB;AACAb,IAAAA,WAAW,CAACU,OAAZ,CAAoBI,IAApB;AACA,WAAKT,YAAL,GAAoBA,YAApB;AACA,WAAKC,OAAL,GAAepB,OAAO,CAAC6B,QAAR,CAAiB,EAAjB,EAAqBT,OAArB,EAA8BX,gBAAgB,CAACqB,uBAA/C,EAAwE,OAAKV,OAA7E,CAAf,CApBoC,CAqBpC;;AACA,QAAI,OAAO,OAAKA,OAAL,CAAaW,UAApB,KAAmC,UAAnC,IACA,CAAC,KAAD,EAAQ,QAAR,EAAkB,OAAlB,EAA2BC,OAA3B,CAAmC,OAAKZ,OAAL,CAAaW,UAAhD,MAAgE,CAAC,CADrE,EACwE;AACpE,YAAM,IAAIE,KAAJ,CAAU,gCACZ,OAAKb,OAAL,CAAaW,UADD,GAEZ,2DAFE,CAAN;AAGH;;AACD,WAAKG,cAAL,GAAsB,IAAIjC,gBAAgB,CAACuB,OAArB,CAA6B,OAAKJ,OAAL,CAAae,YAA1C,CAAtB;;AACA,WAAKD,cAAL,CAAoBE,EAApB,CAAuB,OAAvB,EAAgC,UAACC,KAAD,EAAQC,GAAR,EAAgB;AAC5C,aAAKC,IAAL,CAAU,OAAV,EAAmBF,KAAnB;AACH,KAFD;;AAGA,WAAKH,cAAL,CAAoBE,EAApB,CAAuB,OAAvB,EAAgC,UAAAC,KAAK,EAAI;AACrC,aAAKE,IAAL,CAAU,OAAV,EAAmBF,KAAnB;AACH,KAFD;;AAGA,WAAKH,cAAL,CAAoBE,EAApB,CAAuB,OAAvB,EAAgC,YAAM;AAClC,aAAKI,SAAL,CAAe,OAAf;AACH,KAFD;;AAGA,WAAKN,cAAL,CAAoBE,EAApB,CAAuB,WAAvB,EAAoC,UAACK,KAAD,EAAQH,GAAR,EAAgB;AAChD,aAAKC,IAAL,CAAU,YAAV,EAAwBE,KAAxB,EAA+BH,GAA/B;AACH,KAFD;;AAGA,WAAKI,UAAL,GAAkB,IAAIvC,mBAAmB,CAACqB,OAAxB,CAAgC,OAAKU,cAArC,iCAAlB;;AACA,QAAI,OAAKd,OAAL,CAAauB,WAAjB,EAA8B;AAC1B,aAAKH,SAAL,CAAe,MAAf;AACH,KAFD,MAGK;AACD,aAAKI,OAAL,GAAeC,KAAf,CAAqB,UAAAC,GAAG,EAAI;AACxB9B,QAAAA,KAAK,CAAC,uBAAD,EAA0B8B,GAA1B,CAAL;AACH,OAFD;AAGH;;AAjDmC;AAkDvC;;;;wCACmB;AAChB,WAAKrB,YAAL,GAAoB,IAAIV,KAAJ,EAApB;AACH;;;gDAC2B;AACxB,UAAI,KAAKgC,UAAT,EAAqB;AACjBC,QAAAA,YAAY,CAAC,KAAKD,UAAN,CAAZ;AACA,aAAKA,UAAL,GAAkB,IAAlB;AACH;AACJ;;;gDAC2B;AAAA;;AACxB,UAAI,KAAKA,UAAT,EAAqB;AACjB;AACH;;AACD,UAAME,SAAS,GAAG,SAAZA,SAAY,GAAM;AACpB,QAAA,MAAI,CAACF,UAAL,GAAkBG,UAAU,CAAC,YAAM;AAC/BlC,UAAAA,KAAK,CAAC,wEAAD,CAAL;;AACA,UAAA,MAAI,CAACmC,iBAAL,CAAuB,YAAM;AACzBF,YAAAA,SAAS;AACZ,WAFD;AAGH,SAL2B,EAKzB,MAAI,CAAC7B,OAAL,CAAagC,oBALY,CAA5B;AAMH,OAPD;;AAQAH,MAAAA,SAAS;AACZ;AACD;;;;;;;;;8BAMU;AAAA;;AACN,UAAMI,OAAO,GAAG7C,gBAAgB,CAAC8C,GAAjB,EAAhB;AACA,aAAO,IAAID,OAAJ,CAAY,UAACE,OAAD,EAAUC,MAAV,EAAqB;AACpC,YAAI,MAAI,CAACC,MAAL,KAAgB,YAAhB,IACA,MAAI,CAACA,MAAL,KAAgB,SADhB,IAEA,MAAI,CAACA,MAAL,KAAgB,OAFpB,EAE6B;AACzBD,UAAAA,MAAM,CAAC,IAAIvB,KAAJ,CAAU,uCAAV,CAAD,CAAN;AACA;AACH;;AACD,YAAMyB,KAAK,GAAG,EAAE,MAAI,CAAC/B,eAArB;;AACA,QAAA,MAAI,CAACa,SAAL,CAAe,YAAf;;AACA,QAAA,MAAI,CAACmB,2BAAL,GACKC,IADL,CACU,UAAAC,KAAK,EAAI;AACf,cAAI,MAAI,CAAClC,eAAL,KAAyB+B,KAA7B,EAAoC;AAChC1C,YAAAA,KAAK,CAAC,oFAAD,EAAuF0C,KAAvF,EAA8F,MAAI,CAAC/B,eAAnG,CAAL;AACA6B,YAAAA,MAAM,CAAC,IAAIlD,cAAc,CAACwD,UAAnB,CAA8B,0DAA9B,CAAD,CAAN;AACA;AACH;;AACD,cAAI,MAAI,CAACL,MAAL,KAAgB,YAApB,EAAkC;AAC9BzC,YAAAA,KAAK,CAAC,mFAAD,EAAsF,MAAI,CAACyC,MAA3F,CAAL;AACAD,YAAAA,MAAM,CAAC,IAAIlD,cAAc,CAACwD,UAAnB,CAA8B,uBAA9B,CAAD,CAAN;AACA;AACH;;AACD,UAAA,MAAI,CAAC5B,cAAL,CAAoB6B,KAApB,CAA0BF,KAA1B;;AACA,mBAASG,YAAT,GAAwB;AACpB,iBAAKxB,SAAL,CAAe,OAAf;AACA,iBAAKlB,aAAL,GAAqB,CAArB;AACA,iBAAK2C,sBAAL;AACA,iBAAKC,yBAAL;AACAX,YAAAA,OAAO;AACV;;AACD,cAAIY,aAAJ;;AACA,cAAMC,eAAe,GAAG,SAAlBA,eAAkB,GAAM;AAC1B,YAAA,MAAI,CAACC,cAAL,CAAoB,OAApB,EAA6BF,aAA7B;;AACA,YAAA,MAAI,CAACG,eAAL,GAAuB,KAAvB;;AACA,YAAA,MAAI,CAAC9B,SAAL,CAAe,SAAf;;AACA,gBAAI,MAAI,CAACpB,OAAL,CAAamD,gBAAjB,EAAmC;AAC/B,cAAA,MAAI,CAACC,UAAL,CAAgB,UAAC1B,GAAD,EAAM2B,IAAN,EAAe;AAC3B,oBAAI3B,GAAG,IAAI2B,IAAX,EAAiB;AACbzD,kBAAAA,KAAK,CAAC,0CAAD,EAA6C8B,GAAG,IAAI2B,IAApD,CAAL;;AACA,sBAAI,MAAI,CAAChB,MAAL,KAAgB,SAApB,EAA+B;AAC3B,oBAAA,MAAI,CAACiB,UAAL,CAAgB,IAAhB;AACH;AACJ,iBALD,MAMK;AACDV,kBAAAA,YAAY,CAACpC,IAAb,CAAkB,MAAlB;AACH;AACJ,eAVD;AAWH,aAZD,MAaK;AACDoC,cAAAA,YAAY,CAACpC,IAAb,CAAkB,MAAlB;AACH;AACJ,WApBD;;AAqBAuC,UAAAA,aAAa,GAAG,yBAAY;AACxB,iBAAKE,cAAL,CAAoB,SAApB,EAA+BD,eAA/B;AACAZ,YAAAA,MAAM,CAAC,IAAIvB,KAAJ,CAAU,oCAAV,CAAD,CAAN;AACH,WAHD;;AAIA,UAAA,MAAI,CAAC0C,IAAL,CAAU,SAAV,EAAqBP,eAArB;;AACA,UAAA,MAAI,CAACO,IAAL,CAAU,OAAV,EAAmBR,aAAnB;;AACA,UAAA,MAAI,CAACQ,IAAL,CAAU,OAAV,EAAmB,MAAI,CAACC,gBAAL,CAAsBC,IAAtB,CAA2B,MAA3B,CAAnB;;AACA,UAAA,MAAI,CAAC1B,iBAAL,CAAuB,UAAUL,GAAV,EAAe;AAClC,gBAAIA,GAAG,IAAIA,GAAG,CAACgC,OAAJ,KAAgB,gCAA3B,EAA6D;AACzDjE,cAAAA,OAAO,CAACW,OAAR,CAAgBuD,SAAhB,CAA0BC,UAA1B,CAAqCpD,IAArC,CAA0C,IAA1C,EAAgD,OAAhD,EAAyDkB,GAAzD;AACA,mBAAKZ,cAAL,CAAoB6B,KAApB,CAA0B,EAA1B;AACH;AACJ,WALsB,CAKrBc,IALqB,CAKhB,MALgB,CAAvB;;AAMA,UAAA,MAAI,CAACnC,UAAL,CAAgBuC,KAAhB;AACH,SAxDD,EAyDKpC,KAzDL,CAyDW,UAAAC,GAAG,EAAI;AACd,UAAA,MAAI,CAACN,SAAL,CAAe,OAAf;;AACA,UAAA,MAAI,CAACoC,gBAAL,CAAsB9B,GAAtB;;AACAU,UAAAA,MAAM,CAACV,GAAD,CAAN;AACH,SA7DD;AA8DH,OAvEM,CAAP;AAwEH;AACD;;;;;;;;;qCAMiBoC,M,EAAQ;AACrB,UAAIA,MAAJ,EAAY;AACRlE,QAAAA,KAAK,CAAC,mBAAD,EAAsBkE,MAAtB,CAAL;AACH;;AACD,UAAIC,UAAJ;;AACA,UAAI,CAAC,KAAKb,eAAN,IACA,OAAO,KAAKlD,OAAL,CAAagE,oBAApB,KAA6C,UADjD,EAC6D;AACzDD,QAAAA,UAAU,GAAG,KAAK/D,OAAL,CAAagE,oBAAb,CAAkCxD,IAAlC,CAAuC,IAAvC,EAA6C,EAAE,KAAKN,aAApD,EAAmE4D,MAAnE,CAAb;AACH;;AACD,UAAI,OAAOC,UAAP,KAAsB,QAA1B,EAAoC;AAChC,aAAK3C,SAAL,CAAe,cAAf;AACA,aAAK6C,gBAAL,GAAwBnC,UAAU,CAAC,YAAY;AAC3C,eAAKmC,gBAAL,GAAwB,IAAxB;AACArE,UAAAA,KAAK,CAAC,8CAAD,EAAiDmE,UAAjD,CAAL;AACA,eAAKvC,OAAL,GAAeC,KAAf,CAAqB,UAAUC,GAAV,EAAe;AAChC9B,YAAAA,KAAK,CAAC,6CAAD,EAAgD8B,GAAhD,CAAL;AACH,WAFD;AAGH,SANkC,CAMjC+B,IANiC,CAM5B,IAN4B,CAAD,EAMpBM,UANoB,CAAlC;AAOH,OATD,MAUK;AACD,aAAK3C,SAAL,CAAe,KAAf;AACA,aAAK8C,UAAL,CAAgB,IAAIrD,KAAJ,CAAU,oCAAV,CAAhB;AACH;AACJ;AACD;;;;;;;;;iCAM8B;AAAA,UAAnBsD,SAAmB,uEAAP,KAAO;AAC1B,UAAM9B,MAAM,GAAG,KAAKA,MAApB;AACA,WAAKjB,SAAL,CAAe,eAAf;;AACA,UAAI,CAAC+C,SAAL,EAAgB;AACZ,aAAKjB,eAAL,GAAuB,IAAvB;AACH;;AACD,UAAI,KAAKe,gBAAT,EAA2B;AACvBrC,QAAAA,YAAY,CAAC,KAAKqC,gBAAN,CAAZ;AACA,aAAKA,gBAAL,GAAwB,IAAxB;AACArE,QAAAA,KAAK,CAAC,gCAAD,CAAL;AACH;;AACD,WAAKwE,yBAAL;AACA,WAAK9C,UAAL,CAAgB+C,IAAhB;;AACA,UAAIhC,MAAM,KAAK,MAAf,EAAuB;AACnB,aAAKjB,SAAL,CAAe,OAAf;AACA,aAAKoC,gBAAL;AACH,OAHD,MAIK;AACD,aAAK1C,cAAL,CAAoB6B,KAApB,CAA0B,EAA1B;AACH;AACJ;AACD;;;;;;;;;;yBAOK2B,Q,EAAU;AACX,UAAMjC,MAAM,GAAG,KAAKA,MAApB;AACA,WAAKjB,SAAL,CAAe,eAAf;AACA,WAAK8B,eAAL,GAAuB,IAAvB;;AACA,UAAI,KAAKe,gBAAT,EAA2B;AACvBrC,QAAAA,YAAY,CAAC,KAAKqC,gBAAN,CAAZ;AACA,aAAKA,gBAAL,GAAwB,IAAxB;AACH;;AACD,WAAKG,yBAAL;AACA,WAAK9C,UAAL,CAAgB+C,IAAhB;AACA,UAAMpC,OAAO,GAAG7C,gBAAgB,CAAC8C,GAAjB,EAAhB;;AACA,UAAIG,MAAM,KAAK,MAAf,EAAuB;AACnB,YAAMkC,GAAG,GAAGpF,sBAAsB,CAACiB,OAAvB,CAA+B6B,OAAO,CAACE,OAAR,CAAgB,IAAhB,CAA/B,EAAsDmC,QAAtD,CAAZ,CADmB,CAEnB;AACA;;AACAE,QAAAA,YAAY,CAAC,YAAY;AACrB,eAAKpD,SAAL,CAAe,OAAf;AACA,eAAKoC,gBAAL;AACH,SAHY,CAGXC,IAHW,CAGN,IAHM,CAAD,CAAZ;AAIA,eAAOc,GAAP;AACH;;AACD,aAAOpF,sBAAsB,CAACiB,OAAvB,CAA+B6B,OAAO,CAACwC,GAAR,CAAY,KAAKhC,KAAL,GAAaiC,GAAb,CAAiB,UAAAC,IAAI;AAAA,eAAIA,IAAI,CAACC,IAAL,GAAYnD,KAAZ,CAAkB,UAAAC,GAAG,EAAI;AAChG;AACA;AACA,cAAIA,GAAG,CAACgC,OAAJ,KAAgBpE,OAAO,CAACuF,2BAA5B,EAAyD;AACrD,mBAAO,IAAP;AACH;;AACD,gBAAMnD,GAAN;AACH,SAP0E,CAAJ;AAAA,OAArB,CAAZ,EAOjCc,IAPiC,CAO5B;AAAA,eAAM,IAAN;AAAA,OAP4B,CAA/B,EAOgB8B,QAPhB,CAAP;AAQH;AACD;;;;;;;;;;;;;;;;;gCAc2D;AAAA,UAAjDQ,oBAAiD,uEAA1B,EAA0B;AAAA,UAAtBC,eAAsB,uEAAJ,EAAI;AACvD,UAAMhF,YAAY,GAAG+E,oBAAoB,CAACE,MAArB,GAA8B,CAA9B,GACfF,oBADe,GAEf,KAAK/E,YAAL,CAAkBkF,KAAlB,CAAwB,CAAxB,CAFN;AAGA,UAAMjF,OAAO,GAAG3B,MAAM,CAAC6G,MAAP,CAAc,EAAd,EAAkB,KAAKlF,OAAvB,EAAgC+E,eAAhC,CAAhB;AACA,aAAO,IAAIjF,OAAJ,CAAYC,YAAZ,EAA0BC,OAA1B,CAAP;AACH;AACD;;;;;;;;;;4BAOoB;AAAA,UAAdmF,IAAc,uEAAP,KAAO;;AAChB,UAAIA,IAAI,KAAK,KAAT,IAAkBA,IAAI,KAAK,QAA3B,IAAuCA,IAAI,KAAK,OAApD,EAA6D;AACzD,cAAM,IAAItE,KAAJ,CAAU,mBAAmBsE,IAAnB,GAA0B,wCAApC,CAAN;AACH;;AACD,aAAO,KAAKrE,cAAL,CAAoBsE,QAApB,CAA6BD,IAA7B,CAAP;AACH;AACD;;;;;;;;;;8BAOU9C,M,EAAQ;AAAA;;AACdzC,MAAAA,KAAK,CAAC,kBAAD,EAAqB,KAAKyC,MAAL,IAAe,SAApC,EAA+CA,MAA/C,CAAL;AACA,WAAKA,MAAL,GAAcA,MAAd;AACAgD,MAAAA,OAAO,CAACC,QAAR,CAAiB,YAAM;AACnB,QAAA,MAAI,CAACnE,IAAL,CAAUkB,MAAV;AACH,OAFD;AAGH;AACD;;;;;;;;;;sCAOkBiC,Q,EAAU;AACxB,UAAI,KAAKhE,YAAT,EAAuB;AACnB,YAAI,OAAOgE,QAAP,KAAoB,UAAxB,EAAoC;AAChCe,UAAAA,OAAO,CAACC,QAAR,CAAiBhB,QAAjB;AACH;;AACD;AACH;;AACD,WAAKhE,YAAL,GAAoB,IAApB;;AACA,UAAMiF,KAAK,GAAG,IAAd;;AACA,UAAMC,OAAO,GAAG,SAAVA,OAAU,CAAUnE,KAAV,EAAiB;AAC7BkE,QAAAA,KAAK,CAACjF,YAAN,GAAqB,KAArB;;AACA,YAAI,OAAOgE,QAAP,KAAoB,UAAxB,EAAoC;AAChCA,UAAAA,QAAQ,CAACjD,KAAD,CAAR;AACH;AACJ,OALD;;AAMA,UAAMoB,KAAK,GAAGnD,OAAO,CAACmG,OAAR,CAAgB,KAAK3E,cAAL,CAAoBsE,QAApB,EAAhB,CAAd;AACA,UAAIM,aAAa,GAAG,IAApB;;AACA,eAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACpB,YAAIA,KAAK,KAAKnD,KAAK,CAACuC,MAApB,EAA4B;AACxB,cAAM3D,KAAK,GAAG,IAAI1C,uBAAuB,CAACyB,OAA5B,CAAoC,gCAApC,EAAsEsF,aAAtE,CAAd;AACA,iBAAOF,OAAO,CAACnE,KAAD,CAAd;AACH;;AACD,YAAMsD,IAAI,GAAGlC,KAAK,CAACmD,KAAD,CAAlB;AACA,YAAM1E,GAAG,aAAMyD,IAAI,CAAC3E,OAAL,CAAa6F,IAAnB,cAA2BlB,IAAI,CAAC3E,OAAL,CAAa8F,IAAxC,CAAT;AACAlG,QAAAA,KAAK,CAAC,4BAAD,EAA+BsB,GAA/B,CAAL;;AACAqE,QAAAA,KAAK,CAACQ,eAAN,CAAsBpB,IAAtB,EAA4B,UAAUjD,GAAV,EAAe;AACvC,kBAAQ6D,KAAK,CAAClD,MAAd;AACI,iBAAK,OAAL;AACA,iBAAK,KAAL;AACI,qBAAOmD,OAAO,CAAC,IAAI3E,KAAJ,CAAU,0BAAV,CAAD,CAAd;;AACJ,iBAAK,eAAL;AACI,qBAAO2E,OAAO,CAAC,IAAI3E,KAAJ,CAAU,2BAAV,CAAD,CAAd;AALR;;AAOA,cAAIa,GAAJ,EAAS;AACL6D,YAAAA,KAAK,CAACpE,IAAN,CAAW,YAAX,EAAyBO,GAAzB,EAA8BR,GAA9B;;AACAwE,YAAAA,aAAa,GAAGhE,GAAhB;AACAiE,YAAAA,OAAO,CAACC,KAAK,GAAG,CAAT,CAAP;AACH,WAJD,MAKK;AACDL,YAAAA,KAAK,CAACpE,IAAN,CAAW,SAAX;;AACAqE,YAAAA,OAAO;AACV;AACJ,SAjBD;AAkBH;;AACDG,MAAAA,OAAO,CAAC,CAAD,CAAP;AACH;AACD;;;;;;;;;+BAMWtE,K,EAAO;AACd,UAAI2E,IAAJ;;AACA,aAAO,KAAK3F,YAAL,CAAkB2E,MAAlB,GAA2B,CAAlC,EAAqC;AACjCgB,QAAAA,IAAI,GAAG,KAAK3F,YAAL,CAAkB4F,KAAlB,EAAP;AACAD,QAAAA,IAAI,CAACE,OAAL,CAAa9D,MAAb,CAAoBf,KAApB;AACH;AACJ;;;6CACwB;AACrB,UAAI,KAAKhB,YAAL,CAAkB2E,MAAtB,EAA8B;AAC1BpF,QAAAA,KAAK,CAAC,mCAAD,EAAsC,KAAKS,YAAL,CAAkB2E,MAAxD,CAAL;AACA,YAAM3E,YAAY,GAAG,KAAKA,YAA1B;AACA,aAAK8F,iBAAL;;AACA,eAAO9F,YAAY,CAAC2E,MAAb,GAAsB,CAA7B,EAAgC;AAC5B,cAAMgB,IAAI,GAAG3F,YAAY,CAAC4F,KAAb,EAAb;AACA,eAAKG,WAAL,CAAiBJ,IAAI,CAACE,OAAtB,EAA+BF,IAAI,CAACK,MAApC,EAA4CL,IAAI,CAACrB,IAAjD;AACH;AACJ;AACJ;;;8BACS2B,O,EAAS;AACf,UAAI,KAAKtG,OAAL,CAAauG,MAAb,IAAuB,OAAO,KAAKvG,OAAL,CAAauG,MAApB,KAA+B,QAA1D,EAAoE;AAChE,YAAMrF,GAAG,GAAG,OAAOoF,OAAP,KAAmB,QAAnB,GACNA,OADM,aAEHA,OAAO,CAACT,IAFL,cAEaS,OAAO,CAACR,IAFrB,CAAZ;AAGA,YAAMU,MAAM,GAAG,KAAKxG,OAAL,CAAauG,MAAb,CAAoBrF,GAApB,CAAf;;AACA,YAAIsF,MAAJ,EAAY;AACR5G,UAAAA,KAAK,CAAC,sBAAD,EAAyBsB,GAAzB,EAA8BsF,MAA9B,CAAL;AACA,iBAAOnI,MAAM,CAAC6G,MAAP,CAAc,EAAd,EAAkBsB,MAAlB,CAAP;AACH;AACJ;;AACD,aAAO,OAAOF,OAAP,KAAmB,QAAnB,GACDxH,MAAM,CAAC2H,qBAAP,CAA6BH,OAA7B,CADC,GAEDA,OAFN;AAGH;;;gCACWJ,O,EAASG,M,EAAQ1B,I,EAAM;AAC/B,UAAI,KAAKtC,MAAL,KAAgB,MAApB,EAA4B;AACxB,aAAKb,OAAL,GAAeC,KAAf,CAAqB7C,OAAO,CAAC8H,IAA7B;AACH;;AACD,UAAI,KAAKrE,MAAL,KAAgB,KAApB,EAA2B;AACvB6D,QAAAA,OAAO,CAAC9D,MAAR,CAAe,IAAIvB,KAAJ,CAAUvB,OAAO,CAACuF,2BAAlB,CAAf;AACA,eAAOqB,OAAO,CAACS,OAAf;AACH;;AACD,UAAIC,EAAE,GAAG,KAAK5G,OAAL,CAAaW,UAAtB;;AACA,UAAIiG,EAAE,KAAK,QAAX,EAAqB;AACjB,YAAMC,iBAAiB,GAAGX,OAAO,CAACY,UAAR,IACrBvH,QAAQ,CAACwH,MAAT,CAAgBb,OAAO,CAACc,IAAxB,KACGzH,QAAQ,CAAC0H,OAAT,CAAiBf,OAAO,CAACc,IAAzB,EAA+B,UAA/B,CAFR;;AAGA,YAAI,CAACH,iBAAL,EAAwB;AACpBD,UAAAA,EAAE,GAAG,QAAL;AACH;AACJ;;AACD,UAAIM,UAAU,GAAGvC,IAAI,GAAGA,IAAI,CAACwC,IAAR,GAAejB,OAAO,CAACkB,OAAR,EAApC;AACA,UAAMC,GAAG,GAAG,EAAZ;;AACA,UAAM9B,KAAK,GAAG,IAAd;;AACA,UAAI,CAACZ,IAAD,IAAS,CAACuB,OAAO,CAACoB,uBAAtB,EAA+C;AAC3C;AACApB,QAAAA,OAAO,CAACoB,uBAAR,GAAkC,IAAlC;AACA,YAAMlF,MAAM,GAAG8D,OAAO,CAAC9D,MAAvB;;AACA8D,QAAAA,OAAO,CAAC9D,MAAR,GAAiB,UAAUV,GAAV,EAAe;AAC5B,cAAM6F,UAAU,GAAGC,aAAa,CAAC/D,IAAd,CAAmB,IAAnB,EAAyB,IAAzB,CAAnB;;AACA8B,UAAAA,KAAK,CAACkC,WAAN,CAAkB/F,GAAlB,EAAuB2F,GAAvB,EAA4B;AACxBK,YAAAA,KAAK,EAAE,eAAUP,IAAV,EAAgBjG,GAAhB,EAAqB;AACxBtB,cAAAA,KAAK,CAAC,2BAAD,EAA8BsG,OAAO,CAACc,IAAtC,EAA4C9F,GAA5C,CAAL;AACAgG,cAAAA,UAAU,GAAGS,MAAM,CAACR,IAAD,CAAnB;;AACA,kBAAI5B,KAAK,CAACtF,KAAN,CAAYkH,IAAZ,CAAJ,EAAuB;AACnB5B,gBAAAA,KAAK,CAACtF,KAAN,CAAYkH,IAAZ,EAAkB,CAAlB,IAAuBjG,GAAvB;AACH,eAFD,MAGK;AACDqE,gBAAAA,KAAK,CAACtF,KAAN,CAAYkH,IAAZ,IAAoB,CAACjG,GAAD,CAApB;AACH;;AACDqE,cAAAA,KAAK,CAACzE,cAAN,CAAqB8G,YAArB,CAAkCrC,KAAK,CAACsC,SAAN,CAAgB3G,GAAhB,CAAlC;;AACAsG,cAAAA,aAAa;AACb5H,cAAAA,KAAK,CAAC,sDAAD,CAAL;;AACA2F,cAAAA,KAAK,CAACxD,iBAAN;AACH,aAduB;AAexB+F,YAAAA,GAAG,EAAE,aAAUX,IAAV,EAAgBjG,GAAhB,EAAqB;AACtBtB,cAAAA,KAAK,CAAC,qCAAD,EAAwCsG,OAAO,CAACc,IAAhD,EAAsD9F,GAAtD,CAAL;;AACA,kBAAMsF,MAAM,GAAGjB,KAAK,CAACsC,SAAN,CAAgB3G,GAAhB,CAAf;;AACAqE,cAAAA,KAAK,CAACzE,cAAN,CAAqB8G,YAArB,CAAkCpB,MAAlC;;AACAgB,cAAAA,aAAa,CAAC,KAAD,YAAWhB,MAAM,CAACX,IAAlB,cAA0BW,MAAM,CAACV,IAAjC,EAAb;AACH,aApBuB;AAqBxBiC,YAAAA,QAAQ,EAAER,UArBc;AAsBxBS,YAAAA,WAAW,EAAET,UAtBW;AAuBxBU,YAAAA,gBAAgB,EAAEV,UAvBM;AAwBxBW,YAAAA,eAAe,EAAE,yBAAUC,gBAAV,EAA4B;AACzC/F,cAAAA,MAAM,CAAC5B,IAAP,CAAY0F,OAAZ,EAAqBiC,gBAArB;AACH,aA1BuB;AA2BxB1H,YAAAA,QAAQ,EAAE,oBAAY;AAClB2B,cAAAA,MAAM,CAAC5B,IAAP,CAAY0F,OAAZ,EAAqBxE,GAArB;AACH;AA7BuB,WAA5B;AA+BH,SAjCD;AAkCH;;AACD8F,MAAAA,aAAa;;AACb,eAASA,aAAT,CAAuBY,MAAvB,EAA+BC,MAA/B,EAAuC;AACnC,YAAI9C,KAAK,CAAClD,MAAN,KAAiB,KAArB,EAA4B;AACxB6D,UAAAA,OAAO,CAAC9D,MAAR,CAAe,IAAIlD,cAAc,CAACoJ,UAAnB,CAA8B,mBAA9B,CAAf;AACA;AACH;;AACD,YAAIrH,KAAJ;;AACA,YAAIsE,KAAK,CAAClD,MAAN,KAAiB,OAAjB,IAA4B6D,OAAO,CAACc,IAAR,KAAiB,SAAjD,EAA4D;AACxD,cAAIrC,IAAI,IAAIA,IAAI,CAAC1D,KAAjB,EAAwB;AACpBA,YAAAA,KAAK,GAAG0D,IAAI,CAAC1D,KAAb;AACH,WAFD,MAGK,IAAIzB,SAAS,CAACY,OAAV,CAAkBmI,SAAlB,CAA4B,uBAA5B,EAAqDrC,OAAO,CAACc,IAA7D,KACLxH,SAAS,CAACY,OAAV,CAAkBmI,SAAlB,CAA4B,sBAA5B,EAAoDrC,OAAO,CAACc,IAA5D,CADC,EACkE;AACnE/F,YAAAA,KAAK,GAAGsE,KAAK,CAACjE,UAAN,CAAiBkH,WAAjB,EAAR;;AACA,gBAAI,CAACvH,KAAL,EAAY;AACRiF,cAAAA,OAAO,CAAC9D,MAAR,CAAe,IAAIlD,cAAc,CAACoJ,UAAnB,CAA8B,+BAA9B,CAAf;AACA;AACH;AACJ,WAPI,MAQA;AACD,gBAAI,CAACF,MAAL,EAAa;AACT,kBAAI,OAAOlB,UAAP,KAAsB,QAAtB,IAAkC3B,KAAK,CAACtF,KAAN,CAAYiH,UAAZ,CAAtC,EAA+D;AAC3D,oBAAMuB,QAAQ,GAAGlD,KAAK,CAACtF,KAAN,CAAYiH,UAAZ,CAAjB;;AACA,oBAAI,OAAON,EAAP,KAAc,UAAlB,EAA8B;AAC1B,sBAAMnE,KAAK,GAAGgG,QAAQ,CAAC/D,GAAT,CAAa,UAAUxD,GAAV,EAAe;AACtC,2BAAOqE,KAAK,CAACzE,cAAN,CAAqB4H,gBAArB,CAAsCxH,GAAtC,CAAP;AACH,mBAFa,CAAd;AAGAD,kBAAAA,KAAK,GAAG2F,EAAE,CAACnE,KAAD,EAAQyD,OAAR,CAAV;;AACA,sBAAIyC,KAAK,CAACC,OAAN,CAAc3H,KAAd,CAAJ,EAA0B;AACtBA,oBAAAA,KAAK,GAAG3B,OAAO,CAACuJ,MAAR,CAAe5H,KAAf,CAAR;AACH;;AACD,sBAAI,CAACA,KAAL,EAAY;AACRA,oBAAAA,KAAK,GAAGwB,KAAK,CAAC,CAAD,CAAb;AACH;AACJ,iBAXD,MAYK;AACD,sBAAIvB,GAAJ;;AACA,sBAAI0F,EAAE,KAAK,KAAX,EAAkB;AACd1F,oBAAAA,GAAG,GAAG5B,OAAO,CAACuJ,MAAR,CAAeJ,QAAf,CAAN;AACH,mBAFD,MAGK,IAAI7B,EAAE,KAAK,OAAP,IAAkB6B,QAAQ,CAACzD,MAAT,GAAkB,CAAxC,EAA2C;AAC5C9D,oBAAAA,GAAG,GAAG5B,OAAO,CAACuJ,MAAR,CAAeJ,QAAf,EAAyB,CAAzB,CAAN;AACH,mBAFI,MAGA;AACDvH,oBAAAA,GAAG,GAAGuH,QAAQ,CAAC,CAAD,CAAd;AACH;;AACDxH,kBAAAA,KAAK,GAAGsE,KAAK,CAACzE,cAAN,CAAqB4H,gBAArB,CAAsCxH,GAAtC,CAAR;AACH;AACJ;;AACD,kBAAImH,MAAJ,EAAY;AACRpH,gBAAAA,KAAK,GAAGsE,KAAK,CAACzE,cAAN,CAAqB4H,gBAArB,CAAsCL,MAAtC,CAAR;AACApH,gBAAAA,KAAK,CAACoH,MAAN;AACH;AACJ;;AACD,gBAAI,CAACpH,KAAL,EAAY;AACRA,cAAAA,KAAK,GACD,CAAC,OAAO2F,EAAP,KAAc,UAAd,GACK,IADL,GAEKrB,KAAK,CAACzE,cAAN,CAAqBgI,iBAArB,CAAuClC,EAAvC,CAFN,KAGIrB,KAAK,CAACzE,cAAN,CAAqBgI,iBAArB,CAAuC,KAAvC,CAJR;AAKH;AACJ;;AACD,cAAInE,IAAI,IAAI,CAACA,IAAI,CAAC1D,KAAlB,EAAyB;AACrB0D,YAAAA,IAAI,CAAC1D,KAAL,GAAaA,KAAb;AACH;AACJ;;AACD,YAAIA,KAAJ,EAAW;AACPA,UAAAA,KAAK,CAACmF,WAAN,CAAkBF,OAAlB,EAA2BG,MAA3B;AACH,SAFD,MAGK,IAAId,KAAK,CAACvF,OAAN,CAAc+I,kBAAlB,EAAsC;AACvCxD,UAAAA,KAAK,CAAClF,YAAN,CAAmB2I,IAAnB,CAAwB;AACpB9C,YAAAA,OAAO,EAAEA,OADW;AAEpBG,YAAAA,MAAM,EAAEA,MAFY;AAGpB1B,YAAAA,IAAI,EAAEA;AAHc,WAAxB;AAKH,SANI,MAOA;AACDuB,UAAAA,OAAO,CAAC9D,MAAR,CAAe,IAAIvB,KAAJ,CAAU,6DAAV,CAAf;AACH;AACJ;;AACD,aAAOqF,OAAO,CAACS,OAAf;AACH;;;gCACWtF,K,EAAOgG,G,EAAK4B,Q,EAAU;AAC9B,UAAI,OAAO5B,GAAG,CAAC7I,KAAX,KAAqB,WAAzB,EAAsC;AAClC6I,QAAAA,GAAG,CAAC7I,KAAJ,GAAY,KAAKwB,OAAL,CAAakI,eAAzB;AACH,OAFD,MAGK;AACDb,QAAAA,GAAG,CAAC7I,KAAJ,IAAa,CAAb;AACH;;AACD,UAAI6I,GAAG,CAAC7I,KAAJ,IAAa,CAAjB,EAAoB;AAChByK,QAAAA,QAAQ,CAACf,eAAT,CAAyB,IAAIrH,KAAJ,CAAU,gDAAgDQ,KAA1D,CAAzB;AACA;AACH;;AACD,UAAM6H,IAAI,GAAG7H,KAAK,CAACqC,OAAN,CAAcyF,KAAd,CAAoB,GAApB,CAAb;;AACA,UAAID,IAAI,CAAC,CAAD,CAAJ,KAAY,OAAZ,IAAuBA,IAAI,CAAC,CAAD,CAAJ,KAAY,KAAvC,EAA8C;AAC1CD,QAAAA,QAAQ,CAACC,IAAI,CAAC,CAAD,CAAJ,KAAY,OAAZ,GAAsB,OAAtB,GAAgC,KAAjC,CAAR,CAAgDA,IAAI,CAAC,CAAD,CAApD,EAAyDA,IAAI,CAAC,CAAD,CAA7D;AACH,OAFD,MAGK,IAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,UAAhB,EAA4B;AAC7B,aAAK/I,UAAL,CAAgB6I,IAAhB,CAAqB,UAArB,EAAiCC,QAAQ,CAAClB,QAA1C,EAAoD;AAChDqB,UAAAA,OAAO,EAAE,KAAKpJ,OAAL,CAAaqJ;AAD0B,SAApD;AAGH,OAJI,MAKA,IAAIH,IAAI,CAAC,CAAD,CAAJ,KAAY,aAAZ,IACL,KAAKlJ,OAAL,CAAasJ,uBAAb,GAAuC,CADtC,EACyC;AAC1C,aAAKnJ,UAAL,CAAgB6I,IAAhB,CAAqB,aAArB,EAAoCC,QAAQ,CAAChB,gBAA7C,EAA+D;AAC3DmB,UAAAA,OAAO,EAAE,KAAKpJ,OAAL,CAAasJ,uBADqC;AAE3DhF,UAAAA,QAAQ,EAAE,KAAKvC,iBAAL,CAAuB0B,IAAvB,CAA4B,IAA5B;AAFiD,SAA/D;AAIH,OANI,MAOA,IAAIpC,KAAK,CAACqC,OAAN,KAAkBpE,OAAO,CAACuF,2BAA1B,IACL,KAAK7E,OAAL,CAAauJ,oBAAb,GAAoC,CAD/B,IAEL,KAAKlH,MAAL,KAAgB,OAFf,EAEwB;AACzB,aAAKlC,UAAL,CAAgB6I,IAAhB,CAAqB,UAArB,EAAiCC,QAAQ,CAAChB,gBAA1C,EAA4D;AACxDmB,UAAAA,OAAO,EAAE,KAAKpJ,OAAL,CAAauJ,oBADkC;AAExDjF,UAAAA,QAAQ,EAAE,KAAKvC,iBAAL,CAAuB0B,IAAvB,CAA4B,IAA5B;AAF8C,SAA5D;AAIH,OAPI,MAQA;AACDwF,QAAAA,QAAQ,CAACxI,QAAT;AACH;AACJ;;;oCACeQ,K,EAAOqD,Q,EAAU;AAAA;;AAC7B,UAAI,CAACrD,KAAL,EAAY;AACR,eAAOqD,QAAQ,CAAC,IAAIzD,KAAJ,CAAU,sBAAV,CAAD,CAAf;AACH,OAH4B,CAI7B;AACA;AACA;;;AACA,UAAM2I,oBAAoB,GAAGvI,KAAK,CAACwI,SAAN,CAAgB;AACzCV,QAAAA,kBAAkB,EAAE,IADqB;AAEzC5F,QAAAA,gBAAgB,EAAE,KAFuB;AAGzCuG,QAAAA,aAAa,EAAE,IAH0B;AAIzCC,QAAAA,cAAc,EAAE;AAJyB,OAAhB,CAA7B,CAP6B,CAa7B;AACA;;AACAH,MAAAA,oBAAoB,CAACxI,EAArB,CAAwB,OAAxB,EAAiCpC,OAAO,CAAC8H,IAAzC;AACA8C,MAAAA,oBAAoB,CAACI,OAArB,CAA6B,OAA7B,EAAsCtK,OAAO,CAAC8J,OAAR,CAAgB,UAAC1H,GAAD,EAAMmI,MAAN,EAAiB;AACnEL,QAAAA,oBAAoB,CAAClG,UAArB;;AACA,YAAI5B,GAAJ,EAAS;AACL,iBAAO4C,QAAQ,CAAC5C,GAAD,CAAf;AACH;;AACD,YAAI,MAAI,CAACW,MAAL,KAAgB,eAAhB,IACA,MAAI,CAACA,MAAL,KAAgB,OADhB,IAEA,MAAI,CAACA,MAAL,KAAgB,KAFpB,EAE2B;AACvBzC,UAAAA,KAAK,CAAC,qEAAD,EAAwEiK,MAAM,CAAC7E,MAA/E,EAAuF,MAAI,CAAC3C,MAA5F,CAAL;AACAiC,UAAAA,QAAQ;AACR;AACH;;AACD,YAAM7B,KAAK,GAAG,EAAd;AACA7C,QAAAA,KAAK,CAAC,gCAAD,EAAmCiK,MAAM,CAAC7E,MAA1C,CAAL;;AACA,aAAK,IAAI8E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAAM,CAAC7E,MAA3B,EAAmC,EAAE8E,CAArC,EAAwC;AACpC,cAAMC,KAAK,GAAGF,MAAM,CAACC,CAAD,CAApB;AACA,cAAME,cAAc,GAAGD,KAAK,CAAC,CAAD,CAA5B;AACA,cAAME,YAAY,GAAGF,KAAK,CAAC,CAAD,CAA1B;AACA,cAAMG,IAAI,GAAG,EAAb;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,KAAK,CAAC/E,MAA1B,EAAkCmF,CAAC,EAAnC,EAAuC;AACnC,gBAAI,CAACJ,KAAK,CAACI,CAAD,CAAL,CAAS,CAAT,CAAL,EAAkB;AACd;AACH;;AACDJ,YAAAA,KAAK,CAACI,CAAD,CAAL,GAAW,MAAI,CAACtC,SAAL,CAAe;AAAEhC,cAAAA,IAAI,EAAEkE,KAAK,CAACI,CAAD,CAAL,CAAS,CAAT,CAAR;AAAqBrE,cAAAA,IAAI,EAAEiE,KAAK,CAACI,CAAD,CAAL,CAAS,CAAT;AAA3B,aAAf,CAAX;AACAJ,YAAAA,KAAK,CAACI,CAAD,CAAL,CAASC,QAAT,GAAoBD,CAAC,KAAK,CAA1B;AACA1H,YAAAA,KAAK,CAACuG,IAAN,CAAWe,KAAK,CAACI,CAAD,CAAhB;AACAD,YAAAA,IAAI,CAAClB,IAAL,CAAUe,KAAK,CAACI,CAAD,CAAL,CAAStE,IAAT,GAAgB,GAAhB,GAAsBkE,KAAK,CAACI,CAAD,CAAL,CAASrE,IAAzC;AACH;;AACDlG,UAAAA,KAAK,CAAC,qDAAD,EAAwDkK,CAAxD,EAA2DE,cAA3D,EAA2EC,YAA3E,EAAyFC,IAAzF,CAAL;;AACA,eAAK,IAAI/C,IAAI,GAAG6C,cAAhB,EAAgC7C,IAAI,IAAI8C,YAAxC,EAAsD9C,IAAI,EAA1D,EAA8D;AAC1D,YAAA,MAAI,CAAClH,KAAL,CAAWkH,IAAX,IAAmB+C,IAAnB;AACH;AACJ;;AACD,QAAA,MAAI,CAACpJ,cAAL,CAAoB6B,KAApB,CAA0BF,KAA1B;;AACA6B,QAAAA,QAAQ;AACX,OAnCqC,EAmCnC,KAAKtE,OAAL,CAAaqK,mBAnCsB,CAAtC;AAoCH;AACD;;;;;;;;;+BAMW/F,Q,EAAU;AACjB,WAAKsF,OAAL,CAAa,MAAb,EAAqB,UAAUlI,GAAV,EAAe4I,GAAf,EAAoB;AACrC,YAAI5I,GAAJ,EAAS;AACL,iBAAO4C,QAAQ,CAAC5C,GAAD,CAAf;AACH;;AACD,YAAI,OAAO4I,GAAP,KAAe,QAAnB,EAA6B;AACzB,iBAAOhG,QAAQ,EAAf;AACH;;AACD,YAAIiG,KAAJ;AACA,YAAMC,KAAK,GAAGF,GAAG,CAACnB,KAAJ,CAAU,MAAV,CAAd;;AACA,aAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,KAAK,CAACxF,MAA1B,EAAkC,EAAE8E,CAApC,EAAuC;AACnC,cAAMW,KAAK,GAAGD,KAAK,CAACV,CAAD,CAAL,CAASX,KAAT,CAAe,GAAf,CAAd;;AACA,cAAIsB,KAAK,CAAC,CAAD,CAAL,KAAa,eAAjB,EAAkC;AAC9BF,YAAAA,KAAK,GAAGE,KAAK,CAAC,CAAD,CAAb;AACA;AACH;AACJ;;AACD,YAAIF,KAAK,KAAK,MAAd,EAAsB;AAClB3K,UAAAA,KAAK,CAAC,2BAAD,EAA8B2K,KAA9B,CAAL;AACAjG,UAAAA,QAAQ,CAAC,IAAD,EAAOiG,KAAP,CAAR;AACH,SAHD,MAIK;AACDjG,UAAAA,QAAQ;AACX;AACJ,OAvBD;AAwBH;;;8BACSoG,Q,EAAU;AAAA;;AAChB,aAAO,IAAIzI,OAAJ,CAAY,UAACE,OAAD,EAAUC,MAAV,EAAqB;AACpC,QAAA,MAAI,CAACpC,OAAL,CAAa2K,SAAb,CAAuBD,QAAvB,EAAiC,UAAChJ,GAAD,EAAMkJ,OAAN,EAAkB;AAC/C,cAAIlJ,GAAJ,EAAS;AACL9B,YAAAA,KAAK,CAAC,yCAAD,EAA4C8K,QAA5C,EAAsDhJ,GAAG,CAACgC,OAA1D,CAAL;AACAtB,YAAAA,MAAM,CAACV,GAAD,CAAN;AACH,WAHD,MAIK;AACD9B,YAAAA,KAAK,CAAC,+BAAD,EAAkC8K,QAAlC,EAA4CE,OAA5C,CAAL;AACAzI,YAAAA,OAAO,CAACyI,OAAD,CAAP;AACH;AACJ,SATD;AAUH,OAXM,CAAP;AAYH;AACD;;;;;;;;;;;;kDAS8B;AAAA;;AAC1B,UAAI,CAACjC,KAAK,CAACC,OAAN,CAAc,KAAK7I,YAAnB,CAAD,IAAqC,KAAKA,YAAL,CAAkBiF,MAAlB,KAA6B,CAAtE,EAAyE;AACrE,eAAO/C,OAAO,CAACG,MAAR,CAAe,IAAIvB,KAAJ,CAAU,kDAAV,CAAf,CAAP;AACH;;AACD,UAAMd,YAAY,GAAGjB,MAAM,CAAC+L,oBAAP,CAA4B,KAAK9K,YAAjC,CAArB;AACA,UAAM+K,SAAS,GAAGhM,MAAM,CAACiM,6BAAP,CAAqChL,YAArC,CAAlB;;AACA,UAAI+K,SAAS,CAAC9F,MAAV,KAAqB,CAAzB,EAA4B;AACxB,eAAO/C,OAAO,CAACE,OAAR,CAAgBpC,YAAhB,CAAP;AACH;;AACD,aAAOkC,OAAO,CAACwC,GAAR,CAAYqG,SAAS,CAACpG,GAAV,CAAc,UAAAgG,QAAQ;AAAA,eAAI,MAAI,CAACC,SAAL,CAAeD,QAAf,CAAJ;AAAA,OAAtB,CAAZ,EAAiElI,IAAjE,CAAsE,UAAAwI,GAAG,EAAI;AAChF,YAAMC,YAAY,GAAG3L,OAAO,CAAC4L,MAAR,CAAeJ,SAAf,EAA0BE,GAA1B,CAArB;AACA,eAAOjL,YAAY,CAAC2E,GAAb,CAAiB,UAAAC,IAAI;AAAA,iBAAIsG,YAAY,CAACE,GAAb,CAAiBxG,IAAI,CAACkB,IAAtB,IAC1BxH,MAAM,CAAC6G,MAAP,CAAc,EAAd,EAAkBP,IAAlB,EAAwB;AAAEkB,YAAAA,IAAI,EAAEoF,YAAY,CAAC/I,GAAb,CAAiByC,IAAI,CAACkB,IAAtB;AAAR,WAAxB,CAD0B,GAE1BlB,IAFsB;AAAA,SAArB,CAAP;AAGH,OALM,CAAP;AAMH;;;;EA5rBiBlG,QAAQ,CAAC2M,Y;;AA8rB/B/M,MAAM,CAACgN,mBAAP,CAA2B3L,WAAW,CAACU,OAAZ,CAAoBuD,SAA/C,EAA0D2H,OAA1D,CAAkE,UAAAtE,IAAI,EAAI;AACtE,MAAI,CAAClH,OAAO,CAAC6D,SAAR,CAAkB4H,cAAlB,CAAiCvE,IAAjC,CAAL,EAA6C;AACzClH,IAAAA,OAAO,CAAC6D,SAAR,CAAkBqD,IAAlB,IAA0BtH,WAAW,CAACU,OAAZ,CAAoBuD,SAApB,CAA8BqD,IAA9B,CAA1B;AACH;AACJ,CAJD;AAKA,IAAMwE,YAAY,GAAG,CACjB,OADiB,EAEjB,OAFiB,EAGjB,OAHiB,EAIjB,aAJiB,EAKjB,aALiB,EAMjB,aANiB,CAArB;AAQAA,YAAY,CAACF,OAAb,CAAqB,UAAApF,OAAO,EAAI;AAC5BpG,EAAAA,OAAO,CAAC6D,SAAR,CAAkBuC,OAAO,GAAG,QAA5B,IAAwC,UAAUhF,GAAV,EAAelB,OAAf,EAAwB;AAC5D,WAAO,IAAIf,YAAY,CAACmB,OAAjB,CAAyBxB,OAAO,CAAC6B,QAAR,CAAiB;AAC7CgL,MAAAA,UAAU,EAAE,IADiC;AAE7CvK,MAAAA,GAAG,EAAEA,GAFwC;AAG7CD,MAAAA,KAAK,EAAE,IAHsC;AAI7CiF,MAAAA,OAAO,EAAEA;AAJoC,KAAjB,EAK7BlG,OAL6B,CAAzB,CAAP;AAMH,GAPD;AAQH,CATD;;AAUAtB,OAAO,CAAC,gBAAD,CAAP,CAA0BgN,qBAA1B,CAAgD5L,OAAO,CAAC6D,SAAxD;;AACApF,OAAO,CAAC6B,OAAR,GAAkBN,OAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst ClusterAllFailedError_1 = require(\"../errors/ClusterAllFailedError\");\nconst utils_1 = require(\"../utils\");\nconst ConnectionPool_1 = require(\"./ConnectionPool\");\nconst util_1 = require(\"./util\");\nconst ClusterSubscriber_1 = require(\"./ClusterSubscriber\");\nconst DelayQueue_1 = require(\"./DelayQueue\");\nconst ScanStream_1 = require(\"../ScanStream\");\nconst redis_errors_1 = require(\"redis-errors\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst PromiseContainer = require(\"../promiseContainer\");\nconst ClusterOptions_1 = require(\"./ClusterOptions\");\nconst utils_2 = require(\"../utils\");\nconst commands = require(\"redis-commands\");\nconst command_1 = require(\"../command\");\nconst redis_1 = require(\"../redis\");\nconst commander_1 = require(\"../commander\");\nconst Deque = require(\"denque\");\nconst debug = utils_1.Debug(\"cluster\");\n/**\n * Client for the official Redis Cluster\n *\n * @class Cluster\n * @extends {EventEmitter}\n */\nclass Cluster extends events_1.EventEmitter {\n    /**\n     * Creates an instance of Cluster.\n     *\n     * @param {(Array<string | number | object>)} startupNodes\n     * @param {IClusterOptions} [options={}]\n     * @memberof Cluster\n     */\n    constructor(startupNodes, options = {}) {\n        super();\n        this.slots = [];\n        this.retryAttempts = 0;\n        this.delayQueue = new DelayQueue_1.default();\n        this.offlineQueue = new Deque();\n        this.isRefreshing = false;\n        /**\n         * Every time Cluster#connect() is called, this value will be\n         * auto-incrementing. The purpose of this value is used for\n         * discarding previous connect attampts when creating a new\n         * connection.\n         *\n         * @private\n         * @type {number}\n         * @memberof Cluster\n         */\n        this.connectionEpoch = 0;\n        commander_1.default.call(this);\n        this.startupNodes = startupNodes;\n        this.options = utils_1.defaults({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n        // validate options\n        if (typeof this.options.scaleReads !== \"function\" &&\n            [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n            throw new Error('Invalid option scaleReads \"' +\n                this.options.scaleReads +\n                '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n        }\n        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n        this.connectionPool.on(\"-node\", (redis, key) => {\n            this.emit(\"-node\", redis);\n        });\n        this.connectionPool.on(\"+node\", redis => {\n            this.emit(\"+node\", redis);\n        });\n        this.connectionPool.on(\"drain\", () => {\n            this.setStatus(\"close\");\n        });\n        this.connectionPool.on(\"nodeError\", (error, key) => {\n            this.emit(\"node error\", error, key);\n        });\n        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch(err => {\n                debug(\"connecting failed: %s\", err);\n            });\n        }\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    clearNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            clearTimeout(this.slotsTimer);\n            this.slotsTimer = null;\n        }\n    }\n    resetNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            return;\n        }\n        const nextRound = () => {\n            this.slotsTimer = setTimeout(() => {\n                debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n                this.refreshSlotsCache(() => {\n                    nextRound();\n                });\n            }, this.options.slotsRefreshInterval);\n        };\n        nextRound();\n    }\n    /**\n     * Connect to a cluster\n     *\n     * @returns {Promise<void>}\n     * @memberof Cluster\n     */\n    connect() {\n        const Promise = PromiseContainer.get();\n        return new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            const epoch = ++this.connectionEpoch;\n            this.setStatus(\"connecting\");\n            this.resolveStartupNodeHostnames()\n                .then(nodes => {\n                if (this.connectionEpoch !== epoch) {\n                    debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n                    reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n                    return;\n                }\n                if (this.status !== \"connecting\") {\n                    debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n                    reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n                    return;\n                }\n                this.connectionPool.reset(nodes);\n                function readyHandler() {\n                    this.setStatus(\"ready\");\n                    this.retryAttempts = 0;\n                    this.executeOfflineCommands();\n                    this.resetNodesRefreshInterval();\n                    resolve();\n                }\n                let closeListener;\n                const refreshListener = () => {\n                    this.removeListener(\"close\", closeListener);\n                    this.manuallyClosing = false;\n                    this.setStatus(\"connect\");\n                    if (this.options.enableReadyCheck) {\n                        this.readyCheck((err, fail) => {\n                            if (err || fail) {\n                                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                                if (this.status === \"connect\") {\n                                    this.disconnect(true);\n                                }\n                            }\n                            else {\n                                readyHandler.call(this);\n                            }\n                        });\n                    }\n                    else {\n                        readyHandler.call(this);\n                    }\n                };\n                closeListener = function () {\n                    this.removeListener(\"refresh\", refreshListener);\n                    reject(new Error(\"None of startup nodes is available\"));\n                };\n                this.once(\"refresh\", refreshListener);\n                this.once(\"close\", closeListener);\n                this.once(\"close\", this.handleCloseEvent.bind(this));\n                this.refreshSlotsCache(function (err) {\n                    if (err && err.message === \"Failed to refresh slots cache.\") {\n                        redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n                        this.connectionPool.reset([]);\n                    }\n                }.bind(this));\n                this.subscriber.start();\n            })\n                .catch(err => {\n                this.setStatus(\"close\");\n                this.handleCloseEvent(err);\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     *\n     * @private\n     * @memberof Cluster\n     */\n    handleCloseEvent(reason) {\n        if (reason) {\n            debug(\"closed because %s\", reason);\n        }\n        let retryDelay;\n        if (!this.manuallyClosing &&\n            typeof this.options.clusterRetryStrategy === \"function\") {\n            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n        }\n        if (typeof retryDelay === \"number\") {\n            this.setStatus(\"reconnecting\");\n            this.reconnectTimeout = setTimeout(function () {\n                this.reconnectTimeout = null;\n                debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n                this.connect().catch(function (err) {\n                    debug(\"Got error %s when reconnecting. Ignoring...\", err);\n                });\n            }.bind(this), retryDelay);\n        }\n        else {\n            this.setStatus(\"end\");\n            this.flushQueue(new Error(\"None of startup nodes is available\"));\n        }\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     *\n     * @param {boolean} [reconnect=false]\n     * @memberof Cluster\n     */\n    disconnect(reconnect = false) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n            debug(\"Canceled reconnecting attempts\");\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (status === \"wait\") {\n            this.setStatus(\"close\");\n            this.handleCloseEvent();\n        }\n        else {\n            this.connectionPool.reset([]);\n        }\n    }\n    /**\n     * Quit the cluster gracefully.\n     *\n     * @param {CallbackFunction<'OK'>} [callback]\n     * @returns {Promise<'OK'>}\n     * @memberof Cluster\n     */\n    quit(callback) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        this.manuallyClosing = true;\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        const Promise = PromiseContainer.get();\n        if (status === \"wait\") {\n            const ret = standard_as_callback_1.default(Promise.resolve(\"OK\"), callback);\n            // use setImmediate to make sure \"close\" event\n            // being emitted after quit() is returned\n            setImmediate(function () {\n                this.setStatus(\"close\");\n                this.handleCloseEvent();\n            }.bind(this));\n            return ret;\n        }\n        return standard_as_callback_1.default(Promise.all(this.nodes().map(node => node.quit().catch(err => {\n            // Ignore the error caused by disconnecting since\n            // we're disconnecting...\n            if (err.message === utils_2.CONNECTION_CLOSED_ERROR_MSG) {\n                return \"OK\";\n            }\n            throw err;\n        }))).then(() => \"OK\"), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     *\n     * @public\n     * @param {(Array<string | number | object>)} [overrideStartupNodes=[]]\n     * @param {IClusterOptions} [overrideOptions={}]\n     * @memberof Cluster\n     */\n    duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n        const startupNodes = overrideStartupNodes.length > 0\n            ? overrideStartupNodes\n            : this.startupNodes.slice(0);\n        const options = Object.assign({}, this.options, overrideOptions);\n        return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     *\n     * @param {NodeRole} [role='all']\n     * @returns {any[]}\n     * @memberof Cluster\n     */\n    nodes(role = \"all\") {\n        if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n            throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n        }\n        return this.connectionPool.getNodes(role);\n    }\n    /**\n     * Change cluster instance's status\n     *\n     * @private\n     * @param {ClusterStatus} status\n     * @memberof Cluster\n     */\n    setStatus(status) {\n        debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n        this.status = status;\n        process.nextTick(() => {\n            this.emit(status);\n        });\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @private\n     * @param {CallbackFunction} [callback]\n     * @memberof Cluster\n     */\n    refreshSlotsCache(callback) {\n        if (this.isRefreshing) {\n            if (typeof callback === \"function\") {\n                process.nextTick(callback);\n            }\n            return;\n        }\n        this.isRefreshing = true;\n        const _this = this;\n        const wrapper = function (error) {\n            _this.isRefreshing = false;\n            if (typeof callback === \"function\") {\n                callback(error);\n            }\n        };\n        const nodes = utils_2.shuffle(this.connectionPool.getNodes());\n        let lastNodeError = null;\n        function tryNode(index) {\n            if (index === nodes.length) {\n                const error = new ClusterAllFailedError_1.default(\"Failed to refresh slots cache.\", lastNodeError);\n                return wrapper(error);\n            }\n            const node = nodes[index];\n            const key = `${node.options.host}:${node.options.port}`;\n            debug(\"getting slot cache from %s\", key);\n            _this.getInfoFromNode(node, function (err) {\n                switch (_this.status) {\n                    case \"close\":\n                    case \"end\":\n                        return wrapper(new Error(\"Cluster is disconnected.\"));\n                    case \"disconnecting\":\n                        return wrapper(new Error(\"Cluster is disconnecting.\"));\n                }\n                if (err) {\n                    _this.emit(\"node error\", err, key);\n                    lastNodeError = err;\n                    tryNode(index + 1);\n                }\n                else {\n                    _this.emit(\"refresh\");\n                    wrapper();\n                }\n            });\n        }\n        tryNode(0);\n    }\n    /**\n     * Flush offline queue with error.\n     *\n     * @param {Error} error\n     * @memberof Cluster\n     */\n    flushQueue(error) {\n        let item;\n        while (this.offlineQueue.length > 0) {\n            item = this.offlineQueue.shift();\n            item.command.reject(error);\n        }\n    }\n    executeOfflineCommands() {\n        if (this.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n            const offlineQueue = this.offlineQueue;\n            this.resetOfflineQueue();\n            while (offlineQueue.length > 0) {\n                const item = offlineQueue.shift();\n                this.sendCommand(item.command, item.stream, item.node);\n            }\n        }\n    }\n    natMapper(nodeKey) {\n        if (this.options.natMap && typeof this.options.natMap === \"object\") {\n            const key = typeof nodeKey === \"string\"\n                ? nodeKey\n                : `${nodeKey.host}:${nodeKey.port}`;\n            const mapped = this.options.natMap[key];\n            if (mapped) {\n                debug(\"NAT mapping %s -> %O\", key, mapped);\n                return Object.assign({}, mapped);\n            }\n        }\n        return typeof nodeKey === \"string\"\n            ? util_1.nodeKeyToRedisOptions(nodeKey)\n            : nodeKey;\n    }\n    sendCommand(command, stream, node) {\n        if (this.status === \"wait\") {\n            this.connect().catch(utils_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_2.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        let to = this.options.scaleReads;\n        if (to !== \"master\") {\n            const isCommandReadOnly = command.isReadOnly ||\n                (commands.exists(command.name) &&\n                    commands.hasFlag(command.name, \"readonly\"));\n            if (!isCommandReadOnly) {\n                to = \"master\";\n            }\n        }\n        let targetSlot = node ? node.slot : command.getSlot();\n        const ttl = {};\n        const _this = this;\n        if (!node && !command.__is_reject_overwritten) {\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            command.__is_reject_overwritten = true;\n            const reject = command.reject;\n            command.reject = function (err) {\n                const partialTry = tryConnection.bind(null, true);\n                _this.handleError(err, ttl, {\n                    moved: function (slot, key) {\n                        debug(\"command %s is moved to %s\", command.name, key);\n                        targetSlot = Number(slot);\n                        if (_this.slots[slot]) {\n                            _this.slots[slot][0] = key;\n                        }\n                        else {\n                            _this.slots[slot] = [key];\n                        }\n                        _this.connectionPool.findOrCreate(_this.natMapper(key));\n                        tryConnection();\n                        debug(\"refreshing slot caches... (triggered by MOVED error)\");\n                        _this.refreshSlotsCache();\n                    },\n                    ask: function (slot, key) {\n                        debug(\"command %s is required to ask %s:%s\", command.name, key);\n                        const mapped = _this.natMapper(key);\n                        _this.connectionPool.findOrCreate(mapped);\n                        tryConnection(false, `${mapped.host}:${mapped.port}`);\n                    },\n                    tryagain: partialTry,\n                    clusterDown: partialTry,\n                    connectionClosed: partialTry,\n                    maxRedirections: function (redirectionError) {\n                        reject.call(command, redirectionError);\n                    },\n                    defaults: function () {\n                        reject.call(command, err);\n                    }\n                });\n            };\n        }\n        tryConnection();\n        function tryConnection(random, asking) {\n            if (_this.status === \"end\") {\n                command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n                return;\n            }\n            let redis;\n            if (_this.status === \"ready\" || command.name === \"cluster\") {\n                if (node && node.redis) {\n                    redis = node.redis;\n                }\n                else if (command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) ||\n                    command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n                    redis = _this.subscriber.getInstance();\n                    if (!redis) {\n                        command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n                        return;\n                    }\n                }\n                else {\n                    if (!random) {\n                        if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                            const nodeKeys = _this.slots[targetSlot];\n                            if (typeof to === \"function\") {\n                                const nodes = nodeKeys.map(function (key) {\n                                    return _this.connectionPool.getInstanceByKey(key);\n                                });\n                                redis = to(nodes, command);\n                                if (Array.isArray(redis)) {\n                                    redis = utils_2.sample(redis);\n                                }\n                                if (!redis) {\n                                    redis = nodes[0];\n                                }\n                            }\n                            else {\n                                let key;\n                                if (to === \"all\") {\n                                    key = utils_2.sample(nodeKeys);\n                                }\n                                else if (to === \"slave\" && nodeKeys.length > 1) {\n                                    key = utils_2.sample(nodeKeys, 1);\n                                }\n                                else {\n                                    key = nodeKeys[0];\n                                }\n                                redis = _this.connectionPool.getInstanceByKey(key);\n                            }\n                        }\n                        if (asking) {\n                            redis = _this.connectionPool.getInstanceByKey(asking);\n                            redis.asking();\n                        }\n                    }\n                    if (!redis) {\n                        redis =\n                            (typeof to === \"function\"\n                                ? null\n                                : _this.connectionPool.getSampleInstance(to)) ||\n                                _this.connectionPool.getSampleInstance(\"all\");\n                    }\n                }\n                if (node && !node.redis) {\n                    node.redis = redis;\n                }\n            }\n            if (redis) {\n                redis.sendCommand(command, stream);\n            }\n            else if (_this.options.enableOfflineQueue) {\n                _this.offlineQueue.push({\n                    command: command,\n                    stream: stream,\n                    node: node\n                });\n            }\n            else {\n                command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n            }\n        }\n        return command.promise;\n    }\n    handleError(error, ttl, handlers) {\n        if (typeof ttl.value === \"undefined\") {\n            ttl.value = this.options.maxRedirections;\n        }\n        else {\n            ttl.value -= 1;\n        }\n        if (ttl.value <= 0) {\n            handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n            return;\n        }\n        const errv = error.message.split(\" \");\n        if (errv[0] === \"MOVED\" || errv[0] === \"ASK\") {\n            handlers[errv[0] === \"MOVED\" ? \"moved\" : \"ask\"](errv[1], errv[2]);\n        }\n        else if (errv[0] === \"TRYAGAIN\") {\n            this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n                timeout: this.options.retryDelayOnTryAgain\n            });\n        }\n        else if (errv[0] === \"CLUSTERDOWN\" &&\n            this.options.retryDelayOnClusterDown > 0) {\n            this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnClusterDown,\n                callback: this.refreshSlotsCache.bind(this)\n            });\n        }\n        else if (error.message === utils_2.CONNECTION_CLOSED_ERROR_MSG &&\n            this.options.retryDelayOnFailover > 0 &&\n            this.status === \"ready\") {\n            this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnFailover,\n                callback: this.refreshSlotsCache.bind(this)\n            });\n        }\n        else {\n            handlers.defaults();\n        }\n    }\n    getInfoFromNode(redis, callback) {\n        if (!redis) {\n            return callback(new Error(\"Node is disconnected\"));\n        }\n        // Use a duplication of the connection to avoid\n        // timeouts when the connection is in the blocking\n        // mode (e.g. waiting for BLPOP).\n        const duplicatedConnection = redis.duplicate({\n            enableOfflineQueue: true,\n            enableReadyCheck: false,\n            retryStrategy: null,\n            connectionName: \"ioredisClusterRefresher\"\n        });\n        // Ignore error events since we will handle\n        // exceptions for the CLUSTER SLOTS command.\n        duplicatedConnection.on(\"error\", utils_1.noop);\n        duplicatedConnection.cluster(\"slots\", utils_2.timeout((err, result) => {\n            duplicatedConnection.disconnect();\n            if (err) {\n                return callback(err);\n            }\n            if (this.status === \"disconnecting\" ||\n                this.status === \"close\" ||\n                this.status === \"end\") {\n                debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n                callback();\n                return;\n            }\n            const nodes = [];\n            debug(\"cluster slots result count: %d\", result.length);\n            for (let i = 0; i < result.length; ++i) {\n                const items = result[i];\n                const slotRangeStart = items[0];\n                const slotRangeEnd = items[1];\n                const keys = [];\n                for (let j = 2; j < items.length; j++) {\n                    if (!items[j][0]) {\n                        continue;\n                    }\n                    items[j] = this.natMapper({ host: items[j][0], port: items[j][1] });\n                    items[j].readOnly = j !== 2;\n                    nodes.push(items[j]);\n                    keys.push(items[j].host + \":\" + items[j].port);\n                }\n                debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n                for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n                    this.slots[slot] = keys;\n                }\n            }\n            this.connectionPool.reset(nodes);\n            callback();\n        }, this.options.slotsRefreshTimeout));\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     *\n     * @param {Function} callback\n     * @private\n     */\n    readyCheck(callback) {\n        this.cluster(\"info\", function (err, res) {\n            if (err) {\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback();\n            }\n            let state;\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const parts = lines[i].split(\":\");\n                if (parts[0] === \"cluster_state\") {\n                    state = parts[1];\n                    break;\n                }\n            }\n            if (state === \"fail\") {\n                debug(\"cluster state not ok (%s)\", state);\n                callback(null, state);\n            }\n            else {\n                callback();\n            }\n        });\n    }\n    dnsLookup(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.dnsLookup(hostname, (err, address) => {\n                if (err) {\n                    debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n                    reject(err);\n                }\n                else {\n                    debug(\"resolved hostname %s to IP %s\", hostname, address);\n                    resolve(address);\n                }\n            });\n        });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     *\n     * @private\n     * @returns {Promise<IRedisOptions[]>}\n     */\n    resolveStartupNodeHostnames() {\n        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n            return Promise.reject(new Error(\"`startupNodes` should contain at least one node.\"));\n        }\n        const startupNodes = util_1.normalizeNodeOptions(this.startupNodes);\n        const hostnames = util_1.getUniqueHostnamesFromOptions(startupNodes);\n        if (hostnames.length === 0) {\n            return Promise.resolve(startupNodes);\n        }\n        return Promise.all(hostnames.map(hostname => this.dnsLookup(hostname))).then(ips => {\n            const hostnameToIP = utils_2.zipMap(hostnames, ips);\n            return startupNodes.map(node => hostnameToIP.has(node.host)\n                ? Object.assign({}, node, { host: hostnameToIP.get(node.host) })\n                : node);\n        });\n    }\n}\nObject.getOwnPropertyNames(commander_1.default.prototype).forEach(name => {\n    if (!Cluster.prototype.hasOwnProperty(name)) {\n        Cluster.prototype[name] = commander_1.default.prototype[name];\n    }\n});\nconst scanCommands = [\n    \"sscan\",\n    \"hscan\",\n    \"zscan\",\n    \"sscanBuffer\",\n    \"hscanBuffer\",\n    \"zscanBuffer\"\n];\nscanCommands.forEach(command => {\n    Cluster.prototype[command + \"Stream\"] = function (key, options) {\n        return new ScanStream_1.default(utils_1.defaults({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command\n        }, options));\n    };\n});\nrequire(\"../transaction\").addTransactionSupport(Cluster.prototype);\nexports.default = Cluster;\n"]},"metadata":{},"sourceType":"script"}