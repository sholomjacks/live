{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar url_1 = require(\"url\");\n\nvar lodash_1 = require(\"./lodash\");\n\nexports.defaults = lodash_1.defaults;\nexports.noop = lodash_1.noop;\nexports.flatten = lodash_1.flatten;\n\nvar debug_1 = require(\"./debug\");\n\nexports.Debug = debug_1.default;\n/**\n * Test if two buffers are equal\n *\n * @export\n * @param {Buffer} a\n * @param {Buffer} b\n * @returns {boolean} Whether the two buffers are equal\n */\n\nfunction bufferEqual(a, b) {\n  if (typeof a.equals === \"function\") {\n    return a.equals(b);\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.bufferEqual = bufferEqual;\n/**\n * Convert a buffer to string, supports buffer array\n *\n * @param {*} value - The input value\n * @param {string} encoding - string encoding\n * @return {*} The result\n * @example\n * ```js\n * var input = [Buffer.from('foo'), [Buffer.from('bar')]]\n * var res = convertBufferToString(input, 'utf8')\n * expect(res).to.eql(['foo', ['bar']])\n * ```\n * @private\n */\n\nfunction convertBufferToString(value, encoding) {\n  if (value instanceof Buffer) {\n    return value.toString(encoding);\n  }\n\n  if (Array.isArray(value)) {\n    var length = value.length;\n    var res = Array(length);\n\n    for (var i = 0; i < length; ++i) {\n      res[i] = value[i] instanceof Buffer && encoding === \"utf8\" ? value[i].toString() : convertBufferToString(value[i], encoding);\n    }\n\n    return res;\n  }\n\n  return value;\n}\n\nexports.convertBufferToString = convertBufferToString;\n/**\n * Convert a list of results to node-style\n *\n * @param {Array} arr - The input value\n * @return {Array} The output value\n * @example\n * ```js\n * var input = ['a', 'b', new Error('c'), 'd']\n * var output = exports.wrapMultiResult(input)\n * expect(output).to.eql([[null, 'a'], [null, 'b'], [new Error('c')], [null, 'd'])\n * ```\n * @private\n */\n\nfunction wrapMultiResult(arr) {\n  // When using WATCH/EXEC transactions, the EXEC will return\n  // a null instead of an array\n  if (!arr) {\n    return null;\n  }\n\n  var result = [];\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    var item = arr[i];\n\n    if (item instanceof Error) {\n      result.push([item]);\n    } else {\n      result.push([null, item]);\n    }\n  }\n\n  return result;\n}\n\nexports.wrapMultiResult = wrapMultiResult;\n/**\n * Detect the argument is a int\n *\n * @param {string} value\n * @return {boolean} Whether the value is a int\n * @example\n * ```js\n * > isInt('123')\n * true\n * > isInt('123.3')\n * false\n * > isInt('1x')\n * false\n * > isInt(123)\n * true\n * > isInt(true)\n * false\n * ```\n * @private\n */\n\nfunction isInt(value) {\n  var x = parseFloat(value);\n  return !isNaN(value) && (x | 0) === x;\n}\n\nexports.isInt = isInt;\n/**\n * Pack an array to an Object\n *\n * @param {array} array\n * @return {object}\n * @example\n * ```js\n * > packObject(['a', 'b', 'c', 'd'])\n * { a: 'b', c: 'd' }\n * ```\n */\n\nfunction packObject(array) {\n  var result = {};\n  var length = array.length;\n\n  for (var i = 1; i < length; i += 2) {\n    result[array[i - 1]] = array[i];\n  }\n\n  return result;\n}\n\nexports.packObject = packObject;\n/**\n * Return a callback with timeout\n *\n * @param {function} callback\n * @param {number} timeout\n * @return {function}\n */\n\nfunction timeout(callback, timeout) {\n  var timer;\n\n  var run = function run() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n      callback.apply(this, arguments);\n    }\n  };\n\n  timer = setTimeout(run, timeout, new Error(\"timeout\"));\n  return run;\n}\n\nexports.timeout = timeout;\n/**\n * Convert an object to an array\n *\n * @param {object} obj\n * @return {array}\n * @example\n * ```js\n * > convertObjectToArray({ a: '1' })\n * ['a', '1']\n * ```\n */\n\nfunction convertObjectToArray(obj) {\n  var result = [];\n  var keys = Object.keys(obj);\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n    result.push(keys[i], obj[keys[i]]);\n  }\n\n  return result;\n}\n\nexports.convertObjectToArray = convertObjectToArray;\n/**\n * Convert a map to an array\n *\n * @param {Map} map\n * @return {array}\n * @example\n * ```js\n * > convertObjectToArray(new Map([[1, '2']]))\n * [1, '2']\n * ```\n */\n\nfunction convertMapToArray(map) {\n  var result = [];\n  var pos = 0;\n  map.forEach(function (value, key) {\n    result[pos] = key;\n    result[pos + 1] = value;\n    pos += 2;\n  });\n  return result;\n}\n\nexports.convertMapToArray = convertMapToArray;\n/**\n * Convert a non-string arg to a string\n *\n * @param {*} arg\n * @return {string}\n */\n\nfunction toArg(arg) {\n  if (arg === null || typeof arg === \"undefined\") {\n    return \"\";\n  }\n\n  return String(arg);\n}\n\nexports.toArg = toArg;\n/**\n * Optimize error stack\n *\n * @param {Error} error - actually error\n * @param {string} friendlyStack - the stack that more meaningful\n * @param {string} filterPath - only show stacks with the specified path\n */\n\nfunction optimizeErrorStack(error, friendlyStack, filterPath) {\n  var stacks = friendlyStack.split(\"\\n\");\n  var lines = \"\";\n  var i;\n\n  for (i = 1; i < stacks.length; ++i) {\n    if (stacks[i].indexOf(filterPath) === -1) {\n      break;\n    }\n  }\n\n  for (var j = i; j < stacks.length; ++j) {\n    lines += \"\\n\" + stacks[j];\n  }\n\n  var pos = error.stack.indexOf(\"\\n\");\n  error.stack = error.stack.slice(0, pos) + lines;\n  return error;\n}\n\nexports.optimizeErrorStack = optimizeErrorStack;\n/**\n * Parse the redis protocol url\n *\n * @param {string} url - the redis protocol url\n * @return {Object}\n */\n\nfunction parseURL(url) {\n  if (isInt(url)) {\n    return {\n      port: url\n    };\n  }\n\n  var parsed = url_1.parse(url, true, true);\n\n  if (!parsed.slashes && url[0] !== \"/\") {\n    url = \"//\" + url;\n    parsed = url_1.parse(url, true, true);\n  }\n\n  var result = {};\n\n  if (parsed.auth) {\n    result.password = parsed.auth.split(\":\")[1];\n  }\n\n  if (parsed.pathname) {\n    if (parsed.protocol === \"redis:\" || parsed.protocol === \"rediss:\") {\n      if (parsed.pathname.length > 1) {\n        result.db = parsed.pathname.slice(1);\n      }\n    } else {\n      result.path = parsed.pathname;\n    }\n  }\n\n  if (parsed.host) {\n    result.host = parsed.hostname;\n  }\n\n  if (parsed.port) {\n    result.port = parsed.port;\n  }\n\n  lodash_1.defaults(result, parsed.query);\n  return result;\n}\n\nexports.parseURL = parseURL;\n/**\n * Get a random element from `array`\n *\n * @export\n * @template T\n * @param {T[]} array the array\n * @param {number} [from=0] start index\n * @returns {T}\n */\n\nfunction sample(array) {\n  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var length = array.length;\n\n  if (from >= length) {\n    return;\n  }\n\n  return array[from + Math.floor(Math.random() * (length - from))];\n}\n\nexports.sample = sample;\n/**\n * Shuffle the array using the Fisher-Yates Shuffle.\n * This method will mutate the original array.\n *\n * @export\n * @template T\n * @param {T[]} array\n * @returns {T[]}\n */\n\nfunction shuffle(array) {\n  var counter = array.length; // While there are elements in the array\n\n  while (counter > 0) {\n    // Pick a random index\n    var index = Math.floor(Math.random() * counter); // Decrease counter by 1\n\n    counter--; // And swap the last element with it\n\n    var _ref = [array[index], array[counter]];\n    array[counter] = _ref[0];\n    array[index] = _ref[1];\n  }\n\n  return array;\n}\n\nexports.shuffle = shuffle;\n/**\n * Error message for connection being disconnected\n */\n\nexports.CONNECTION_CLOSED_ERROR_MSG = \"Connection is closed.\";\n\nfunction zipMap(keys, values) {\n  var map = new Map();\n  keys.forEach(function (key, index) {\n    map.set(key, values[index]);\n  });\n  return map;\n}\n\nexports.zipMap = zipMap;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/utils/index.js"],"names":["Object","defineProperty","exports","value","url_1","require","lodash_1","defaults","noop","flatten","debug_1","Debug","default","bufferEqual","a","b","equals","length","i","convertBufferToString","encoding","Buffer","toString","Array","isArray","res","wrapMultiResult","arr","result","item","Error","push","isInt","x","parseFloat","isNaN","packObject","array","timeout","callback","timer","run","clearTimeout","apply","arguments","setTimeout","convertObjectToArray","obj","keys","l","convertMapToArray","map","pos","forEach","key","toArg","arg","String","optimizeErrorStack","error","friendlyStack","filterPath","stacks","split","lines","indexOf","j","stack","slice","parseURL","url","port","parsed","parse","slashes","auth","password","pathname","protocol","db","path","host","hostname","query","sample","from","Math","floor","random","shuffle","counter","index","CONNECTION_CLOSED_ERROR_MSG","zipMap","values","Map","set"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nconst lodash_1 = require(\"./lodash\");\nexports.defaults = lodash_1.defaults;\nexports.noop = lodash_1.noop;\nexports.flatten = lodash_1.flatten;\nconst debug_1 = require(\"./debug\");\nexports.Debug = debug_1.default;\n/**\n * Test if two buffers are equal\n *\n * @export\n * @param {Buffer} a\n * @param {Buffer} b\n * @returns {boolean} Whether the two buffers are equal\n */\nfunction bufferEqual(a, b) {\n    if (typeof a.equals === \"function\") {\n        return a.equals(b);\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.bufferEqual = bufferEqual;\n/**\n * Convert a buffer to string, supports buffer array\n *\n * @param {*} value - The input value\n * @param {string} encoding - string encoding\n * @return {*} The result\n * @example\n * ```js\n * var input = [Buffer.from('foo'), [Buffer.from('bar')]]\n * var res = convertBufferToString(input, 'utf8')\n * expect(res).to.eql(['foo', ['bar']])\n * ```\n * @private\n */\nfunction convertBufferToString(value, encoding) {\n    if (value instanceof Buffer) {\n        return value.toString(encoding);\n    }\n    if (Array.isArray(value)) {\n        var length = value.length;\n        var res = Array(length);\n        for (var i = 0; i < length; ++i) {\n            res[i] =\n                value[i] instanceof Buffer && encoding === \"utf8\"\n                    ? value[i].toString()\n                    : convertBufferToString(value[i], encoding);\n        }\n        return res;\n    }\n    return value;\n}\nexports.convertBufferToString = convertBufferToString;\n/**\n * Convert a list of results to node-style\n *\n * @param {Array} arr - The input value\n * @return {Array} The output value\n * @example\n * ```js\n * var input = ['a', 'b', new Error('c'), 'd']\n * var output = exports.wrapMultiResult(input)\n * expect(output).to.eql([[null, 'a'], [null, 'b'], [new Error('c')], [null, 'd'])\n * ```\n * @private\n */\nfunction wrapMultiResult(arr) {\n    // When using WATCH/EXEC transactions, the EXEC will return\n    // a null instead of an array\n    if (!arr) {\n        return null;\n    }\n    var result = [];\n    var length = arr.length;\n    for (var i = 0; i < length; ++i) {\n        var item = arr[i];\n        if (item instanceof Error) {\n            result.push([item]);\n        }\n        else {\n            result.push([null, item]);\n        }\n    }\n    return result;\n}\nexports.wrapMultiResult = wrapMultiResult;\n/**\n * Detect the argument is a int\n *\n * @param {string} value\n * @return {boolean} Whether the value is a int\n * @example\n * ```js\n * > isInt('123')\n * true\n * > isInt('123.3')\n * false\n * > isInt('1x')\n * false\n * > isInt(123)\n * true\n * > isInt(true)\n * false\n * ```\n * @private\n */\nfunction isInt(value) {\n    var x = parseFloat(value);\n    return !isNaN(value) && (x | 0) === x;\n}\nexports.isInt = isInt;\n/**\n * Pack an array to an Object\n *\n * @param {array} array\n * @return {object}\n * @example\n * ```js\n * > packObject(['a', 'b', 'c', 'd'])\n * { a: 'b', c: 'd' }\n * ```\n */\nfunction packObject(array) {\n    var result = {};\n    var length = array.length;\n    for (var i = 1; i < length; i += 2) {\n        result[array[i - 1]] = array[i];\n    }\n    return result;\n}\nexports.packObject = packObject;\n/**\n * Return a callback with timeout\n *\n * @param {function} callback\n * @param {number} timeout\n * @return {function}\n */\nfunction timeout(callback, timeout) {\n    var timer;\n    var run = function () {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n            callback.apply(this, arguments);\n        }\n    };\n    timer = setTimeout(run, timeout, new Error(\"timeout\"));\n    return run;\n}\nexports.timeout = timeout;\n/**\n * Convert an object to an array\n *\n * @param {object} obj\n * @return {array}\n * @example\n * ```js\n * > convertObjectToArray({ a: '1' })\n * ['a', '1']\n * ```\n */\nfunction convertObjectToArray(obj) {\n    var result = [];\n    var keys = Object.keys(obj);\n    for (var i = 0, l = keys.length; i < l; i++) {\n        result.push(keys[i], obj[keys[i]]);\n    }\n    return result;\n}\nexports.convertObjectToArray = convertObjectToArray;\n/**\n * Convert a map to an array\n *\n * @param {Map} map\n * @return {array}\n * @example\n * ```js\n * > convertObjectToArray(new Map([[1, '2']]))\n * [1, '2']\n * ```\n */\nfunction convertMapToArray(map) {\n    const result = [];\n    let pos = 0;\n    map.forEach(function (value, key) {\n        result[pos] = key;\n        result[pos + 1] = value;\n        pos += 2;\n    });\n    return result;\n}\nexports.convertMapToArray = convertMapToArray;\n/**\n * Convert a non-string arg to a string\n *\n * @param {*} arg\n * @return {string}\n */\nfunction toArg(arg) {\n    if (arg === null || typeof arg === \"undefined\") {\n        return \"\";\n    }\n    return String(arg);\n}\nexports.toArg = toArg;\n/**\n * Optimize error stack\n *\n * @param {Error} error - actually error\n * @param {string} friendlyStack - the stack that more meaningful\n * @param {string} filterPath - only show stacks with the specified path\n */\nfunction optimizeErrorStack(error, friendlyStack, filterPath) {\n    var stacks = friendlyStack.split(\"\\n\");\n    var lines = \"\";\n    var i;\n    for (i = 1; i < stacks.length; ++i) {\n        if (stacks[i].indexOf(filterPath) === -1) {\n            break;\n        }\n    }\n    for (var j = i; j < stacks.length; ++j) {\n        lines += \"\\n\" + stacks[j];\n    }\n    var pos = error.stack.indexOf(\"\\n\");\n    error.stack = error.stack.slice(0, pos) + lines;\n    return error;\n}\nexports.optimizeErrorStack = optimizeErrorStack;\n/**\n * Parse the redis protocol url\n *\n * @param {string} url - the redis protocol url\n * @return {Object}\n */\nfunction parseURL(url) {\n    if (isInt(url)) {\n        return { port: url };\n    }\n    var parsed = url_1.parse(url, true, true);\n    if (!parsed.slashes && url[0] !== \"/\") {\n        url = \"//\" + url;\n        parsed = url_1.parse(url, true, true);\n    }\n    var result = {};\n    if (parsed.auth) {\n        result.password = parsed.auth.split(\":\")[1];\n    }\n    if (parsed.pathname) {\n        if (parsed.protocol === \"redis:\" || parsed.protocol === \"rediss:\") {\n            if (parsed.pathname.length > 1) {\n                result.db = parsed.pathname.slice(1);\n            }\n        }\n        else {\n            result.path = parsed.pathname;\n        }\n    }\n    if (parsed.host) {\n        result.host = parsed.hostname;\n    }\n    if (parsed.port) {\n        result.port = parsed.port;\n    }\n    lodash_1.defaults(result, parsed.query);\n    return result;\n}\nexports.parseURL = parseURL;\n/**\n * Get a random element from `array`\n *\n * @export\n * @template T\n * @param {T[]} array the array\n * @param {number} [from=0] start index\n * @returns {T}\n */\nfunction sample(array, from = 0) {\n    const length = array.length;\n    if (from >= length) {\n        return;\n    }\n    return array[from + Math.floor(Math.random() * (length - from))];\n}\nexports.sample = sample;\n/**\n * Shuffle the array using the Fisher-Yates Shuffle.\n * This method will mutate the original array.\n *\n * @export\n * @template T\n * @param {T[]} array\n * @returns {T[]}\n */\nfunction shuffle(array) {\n    let counter = array.length;\n    // While there are elements in the array\n    while (counter > 0) {\n        // Pick a random index\n        const index = Math.floor(Math.random() * counter);\n        // Decrease counter by 1\n        counter--;\n        // And swap the last element with it\n        [array[counter], array[index]] = [array[index], array[counter]];\n    }\n    return array;\n}\nexports.shuffle = shuffle;\n/**\n * Error message for connection being disconnected\n */\nexports.CONNECTION_CLOSED_ERROR_MSG = \"Connection is closed.\";\nfunction zipMap(keys, values) {\n    const map = new Map();\n    keys.forEach((key, index) => {\n        map.set(key, values[index]);\n    });\n    return map;\n}\nexports.zipMap = zipMap;\n"]},"metadata":{},"sourceType":"script"}