{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"../utils\");\n\nconst net_1 = require(\"net\");\n\nfunction getNodeKey(node) {\n  node.port = node.port || 6379;\n  node.host = node.host || \"127.0.0.1\";\n  return node.host + \":\" + node.port;\n}\n\nexports.getNodeKey = getNodeKey;\n\nfunction nodeKeyToRedisOptions(nodeKey) {\n  const portIndex = nodeKey.lastIndexOf(\":\");\n\n  if (portIndex === -1) {\n    throw new Error(`Invalid node key ${nodeKey}`);\n  }\n\n  return {\n    host: nodeKey.slice(0, portIndex),\n    port: Number(nodeKey.slice(portIndex + 1))\n  };\n}\n\nexports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;\n\nfunction normalizeNodeOptions(nodes) {\n  return nodes.map(node => {\n    const options = {};\n\n    if (typeof node === \"object\") {\n      Object.assign(options, node);\n    } else if (typeof node === \"string\") {\n      Object.assign(options, utils_1.parseURL(node));\n    } else if (typeof node === \"number\") {\n      options.port = node;\n    } else {\n      throw new Error(\"Invalid argument \" + node);\n    }\n\n    if (typeof options.port === \"string\") {\n      options.port = parseInt(options.port, 10);\n    } // Cluster mode only support db 0\n\n\n    delete options.db;\n\n    if (!options.port) {\n      options.port = 6379;\n    }\n\n    if (!options.host) {\n      options.host = \"127.0.0.1\";\n    }\n\n    return options;\n  });\n}\n\nexports.normalizeNodeOptions = normalizeNodeOptions;\n\nfunction getUniqueHostnamesFromOptions(nodes) {\n  const uniqueHostsMap = {};\n  nodes.forEach(node => {\n    uniqueHostsMap[node.host] = true;\n  });\n  return Object.keys(uniqueHostsMap).filter(host => !net_1.isIP(host));\n}\n\nexports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/cluster/util.js"],"names":["Object","defineProperty","exports","value","utils_1","require","net_1","getNodeKey","node","port","host","nodeKeyToRedisOptions","nodeKey","portIndex","lastIndexOf","Error","slice","Number","normalizeNodeOptions","nodes","map","options","assign","parseURL","parseInt","db","getUniqueHostnamesFromOptions","uniqueHostsMap","forEach","keys","filter","isIP"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"../utils\");\nconst net_1 = require(\"net\");\nfunction getNodeKey(node) {\n    node.port = node.port || 6379;\n    node.host = node.host || \"127.0.0.1\";\n    return node.host + \":\" + node.port;\n}\nexports.getNodeKey = getNodeKey;\nfunction nodeKeyToRedisOptions(nodeKey) {\n    const portIndex = nodeKey.lastIndexOf(\":\");\n    if (portIndex === -1) {\n        throw new Error(`Invalid node key ${nodeKey}`);\n    }\n    return {\n        host: nodeKey.slice(0, portIndex),\n        port: Number(nodeKey.slice(portIndex + 1))\n    };\n}\nexports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;\nfunction normalizeNodeOptions(nodes) {\n    return nodes.map(node => {\n        const options = {};\n        if (typeof node === \"object\") {\n            Object.assign(options, node);\n        }\n        else if (typeof node === \"string\") {\n            Object.assign(options, utils_1.parseURL(node));\n        }\n        else if (typeof node === \"number\") {\n            options.port = node;\n        }\n        else {\n            throw new Error(\"Invalid argument \" + node);\n        }\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        // Cluster mode only support db 0\n        delete options.db;\n        if (!options.port) {\n            options.port = 6379;\n        }\n        if (!options.host) {\n            options.host = \"127.0.0.1\";\n        }\n        return options;\n    });\n}\nexports.normalizeNodeOptions = normalizeNodeOptions;\nfunction getUniqueHostnamesFromOptions(nodes) {\n    const uniqueHostsMap = {};\n    nodes.forEach(node => {\n        uniqueHostsMap[node.host] = true;\n    });\n    return Object.keys(uniqueHostsMap).filter(host => !net_1.isIP(host));\n}\nexports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;\n"]},"metadata":{},"sourceType":"script"}