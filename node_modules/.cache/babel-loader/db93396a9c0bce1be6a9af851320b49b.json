{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst commands = require(\"redis-commands\");\n\nconst calculateSlot = require(\"cluster-key-slot\");\n\nconst standard_as_callback_1 = require(\"standard-as-callback\");\n\nconst utils_1 = require(\"./utils\");\n\nconst lodash_1 = require(\"./utils/lodash\");\n\nconst promiseContainer_1 = require(\"./promiseContainer\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * @export\n * @class Command\n *\n * @example\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n * @see {@link Redis#sendCommand} which can send a Command instance to Redis\n */\n\n\nclass Command {\n  /**\n   * Creates an instance of Command.\n   * @param {string} name Command name\n   * @param {(Array<string | Buffer | number>)} [args=[]] An array of command arguments\n   * @param {ICommandOptions} [options={}]\n   * @param {CallbackFunction} [callback] The callback that handles the response.\n   * If omit, the response will be handled via Promise\n   * @memberof Command\n   */\n  constructor(name, args = [], options = {}, callback) {\n    this.name = name;\n    this.transformed = false;\n    this.isCustomCommand = false;\n    this.replyEncoding = options.replyEncoding;\n    this.errorStack = options.errorStack;\n    this.args = lodash_1.flatten(args);\n    this.callback = callback;\n    this.initPromise();\n\n    if (options.keyPrefix) {\n      this._iterateKeys(key => options.keyPrefix + key);\n    }\n\n    if (options.readOnly) {\n      this.isReadOnly = true;\n    }\n  }\n\n  static getFlagMap() {\n    if (!this.flagMap) {\n      this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {\n        map[flagName] = {};\n        Command.FLAGS[flagName].forEach(commandName => {\n          map[flagName][commandName] = true;\n        });\n        return map;\n      }, {});\n    }\n\n    return this.flagMap;\n  }\n  /**\n   * Check whether the command has the flag\n   *\n   * @param {string} flagName\n   * @param {string} commandName\n   * @return {boolean}\n   */\n\n\n  static checkFlag(flagName, commandName) {\n    return !!this.getFlagMap()[flagName][commandName];\n  }\n\n  static setArgumentTransformer(name, func) {\n    this._transformer.argument[name] = func;\n  }\n\n  static setReplyTransformer(name, func) {\n    this._transformer.reply[name] = func;\n  }\n\n  initPromise() {\n    const Promise = promiseContainer_1.get();\n    const promise = new Promise((resolve, reject) => {\n      if (!this.transformed) {\n        this.transformed = true;\n        const transformer = Command._transformer.argument[this.name];\n\n        if (transformer) {\n          this.args = transformer(this.args);\n        }\n\n        this.stringifyArguments();\n      }\n\n      this.resolve = this._convertValue(resolve);\n\n      if (this.errorStack) {\n        this.reject = err => {\n          reject(utils_1.optimizeErrorStack(err, this.errorStack, __dirname));\n        };\n      } else {\n        this.reject = reject;\n      }\n    });\n    this.promise = standard_as_callback_1.default(promise, this.callback);\n  }\n\n  getSlot() {\n    if (typeof this.slot === \"undefined\") {\n      const key = this.getKeys()[0];\n      this.slot = key == null ? null : calculateSlot(key);\n    }\n\n    return this.slot;\n  }\n\n  getKeys() {\n    return this._iterateKeys();\n  }\n  /**\n   * Iterate through the command arguments that are considered keys.\n   *\n   * @param {Function} [transform=(key) => key] The transformation that should be applied to\n   * each key. The transformations will persist.\n   * @returns {string[]} The keys of the command.\n   * @memberof Command\n   */\n\n\n  _iterateKeys(transform = key => key) {\n    if (typeof this.keys === \"undefined\") {\n      this.keys = [];\n\n      if (commands.exists(this.name)) {\n        const keyIndexes = commands.getKeyIndexes(this.name, this.args);\n\n        for (const index of keyIndexes) {\n          this.args[index] = transform(this.args[index]);\n          this.keys.push(this.args[index]);\n        }\n      }\n    }\n\n    return this.keys;\n  }\n  /**\n   * Convert command to writable buffer or string\n   *\n   * @return {string|Buffer}\n   * @see {@link Redis#sendCommand}\n   * @public\n   */\n\n\n  toWritable() {\n    let bufferMode = false;\n\n    for (const arg of this.args) {\n      if (arg instanceof Buffer) {\n        bufferMode = true;\n        break;\n      }\n    }\n\n    let result;\n    let commandStr = \"*\" + (this.args.length + 1) + \"\\r\\n$\" + Buffer.byteLength(this.name) + \"\\r\\n\" + this.name + \"\\r\\n\";\n\n    if (bufferMode) {\n      const buffers = new MixedBuffers();\n      buffers.push(commandStr);\n\n      for (const arg of this.args) {\n        if (arg instanceof Buffer) {\n          if (arg.length === 0) {\n            buffers.push(\"$0\\r\\n\\r\\n\");\n          } else {\n            buffers.push(\"$\" + arg.length + \"\\r\\n\");\n            buffers.push(arg);\n            buffers.push(\"\\r\\n\");\n          }\n        } else {\n          buffers.push(\"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\");\n        }\n      }\n\n      result = buffers.toBuffer();\n    } else {\n      result = commandStr;\n\n      for (const arg of this.args) {\n        result += \"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\";\n      }\n    }\n\n    return result;\n  }\n\n  stringifyArguments() {\n    for (let i = 0; i < this.args.length; ++i) {\n      const arg = this.args[i];\n\n      if (!(arg instanceof Buffer) && typeof arg !== \"string\") {\n        this.args[i] = utils_1.toArg(arg);\n      }\n    }\n  }\n  /**\n   * Convert the value from buffer to the target encoding.\n   *\n   * @private\n   * @param {Function} resolve The resolve function of the Promise\n   * @returns {Function} A funtion to transform and resolve a value\n   * @memberof Command\n   */\n\n\n  _convertValue(resolve) {\n    return value => {\n      try {\n        resolve(this.transformReply(value));\n      } catch (err) {\n        this.reject(err);\n      }\n\n      return this.promise;\n    };\n  }\n  /**\n   * Convert buffer/buffer[] to string/string[],\n   * and apply reply transformer.\n   *\n   * @memberof Command\n   */\n\n\n  transformReply(result) {\n    if (this.replyEncoding) {\n      result = utils_1.convertBufferToString(result, this.replyEncoding);\n    }\n\n    const transformer = Command._transformer.reply[this.name];\n\n    if (transformer) {\n      result = transformer(result);\n    }\n\n    return result;\n  }\n\n}\n\nCommand.FLAGS = {\n  VALID_IN_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\", \"unsubscribe\", \"punsubscribe\", \"ping\", \"quit\"],\n  VALID_IN_MONITOR_MODE: [\"monitor\", \"auth\"],\n  ENTER_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\"],\n  EXIT_SUBSCRIBER_MODE: [\"unsubscribe\", \"punsubscribe\"],\n  WILL_DISCONNECT: [\"quit\"]\n};\nCommand._transformer = {\n  argument: {},\n  reply: {}\n};\nexports.default = Command;\n\nconst msetArgumentTransformer = function (args) {\n  if (args.length === 1) {\n    if (typeof Map !== \"undefined\" && args[0] instanceof Map) {\n      return utils_1.convertMapToArray(args[0]);\n    }\n\n    if (typeof args[0] === \"object\" && args[0] !== null) {\n      return utils_1.convertObjectToArray(args[0]);\n    }\n  }\n\n  return args;\n};\n\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      return [args[0]].concat(utils_1.convertMapToArray(args[1]));\n    }\n\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils_1.convertObjectToArray(args[1]));\n    }\n  }\n\n  return args;\n});\nCommand.setReplyTransformer(\"hgetall\", function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n\n    return obj;\n  }\n\n  return result;\n});\nCommand.setArgumentTransformer(\"hset\", function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n      return [args[0]].concat(utils_1.convertMapToArray(args[1]));\n    }\n\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat(utils_1.convertObjectToArray(args[1]));\n    }\n  }\n\n  return args;\n});\n\nclass MixedBuffers {\n  constructor() {\n    this.length = 0;\n    this.items = [];\n  }\n\n  push(x) {\n    this.length += Buffer.byteLength(x);\n    this.items.push(x);\n  }\n\n  toBuffer() {\n    const result = Buffer.allocUnsafe(this.length);\n    let offset = 0;\n\n    for (const item of this.items) {\n      const length = Buffer.byteLength(item);\n      Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);\n      offset += length;\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/command.js"],"names":["Object","defineProperty","exports","value","commands","require","calculateSlot","standard_as_callback_1","utils_1","lodash_1","promiseContainer_1","Command","constructor","name","args","options","callback","transformed","isCustomCommand","replyEncoding","errorStack","flatten","initPromise","keyPrefix","_iterateKeys","key","readOnly","isReadOnly","getFlagMap","flagMap","keys","FLAGS","reduce","map","flagName","forEach","commandName","checkFlag","setArgumentTransformer","func","_transformer","argument","setReplyTransformer","reply","Promise","get","promise","resolve","reject","transformer","stringifyArguments","_convertValue","err","optimizeErrorStack","__dirname","default","getSlot","slot","getKeys","transform","exists","keyIndexes","getKeyIndexes","index","push","toWritable","bufferMode","arg","Buffer","result","commandStr","length","byteLength","buffers","MixedBuffers","toBuffer","i","toArg","transformReply","convertBufferToString","VALID_IN_SUBSCRIBER_MODE","VALID_IN_MONITOR_MODE","ENTER_SUBSCRIBER_MODE","EXIT_SUBSCRIBER_MODE","WILL_DISCONNECT","msetArgumentTransformer","Map","convertMapToArray","convertObjectToArray","concat","Array","isArray","obj","items","x","allocUnsafe","offset","item","isBuffer","copy","write"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commands = require(\"redis-commands\");\nconst calculateSlot = require(\"cluster-key-slot\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst utils_1 = require(\"./utils\");\nconst lodash_1 = require(\"./utils/lodash\");\nconst promiseContainer_1 = require(\"./promiseContainer\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * @export\n * @class Command\n *\n * @example\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n * @see {@link Redis#sendCommand} which can send a Command instance to Redis\n */\nclass Command {\n    /**\n     * Creates an instance of Command.\n     * @param {string} name Command name\n     * @param {(Array<string | Buffer | number>)} [args=[]] An array of command arguments\n     * @param {ICommandOptions} [options={}]\n     * @param {CallbackFunction} [callback] The callback that handles the response.\n     * If omit, the response will be handled via Promise\n     * @memberof Command\n     */\n    constructor(name, args = [], options = {}, callback) {\n        this.name = name;\n        this.transformed = false;\n        this.isCustomCommand = false;\n        this.replyEncoding = options.replyEncoding;\n        this.errorStack = options.errorStack;\n        this.args = lodash_1.flatten(args);\n        this.callback = callback;\n        this.initPromise();\n        if (options.keyPrefix) {\n            this._iterateKeys(key => options.keyPrefix + key);\n        }\n        if (options.readOnly) {\n            this.isReadOnly = true;\n        }\n    }\n    static getFlagMap() {\n        if (!this.flagMap) {\n            this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {\n                map[flagName] = {};\n                Command.FLAGS[flagName].forEach(commandName => {\n                    map[flagName][commandName] = true;\n                });\n                return map;\n            }, {});\n        }\n        return this.flagMap;\n    }\n    /**\n     * Check whether the command has the flag\n     *\n     * @param {string} flagName\n     * @param {string} commandName\n     * @return {boolean}\n     */\n    static checkFlag(flagName, commandName) {\n        return !!this.getFlagMap()[flagName][commandName];\n    }\n    static setArgumentTransformer(name, func) {\n        this._transformer.argument[name] = func;\n    }\n    static setReplyTransformer(name, func) {\n        this._transformer.reply[name] = func;\n    }\n    initPromise() {\n        const Promise = promiseContainer_1.get();\n        const promise = new Promise((resolve, reject) => {\n            if (!this.transformed) {\n                this.transformed = true;\n                const transformer = Command._transformer.argument[this.name];\n                if (transformer) {\n                    this.args = transformer(this.args);\n                }\n                this.stringifyArguments();\n            }\n            this.resolve = this._convertValue(resolve);\n            if (this.errorStack) {\n                this.reject = err => {\n                    reject(utils_1.optimizeErrorStack(err, this.errorStack, __dirname));\n                };\n            }\n            else {\n                this.reject = reject;\n            }\n        });\n        this.promise = standard_as_callback_1.default(promise, this.callback);\n    }\n    getSlot() {\n        if (typeof this.slot === \"undefined\") {\n            const key = this.getKeys()[0];\n            this.slot = key == null ? null : calculateSlot(key);\n        }\n        return this.slot;\n    }\n    getKeys() {\n        return this._iterateKeys();\n    }\n    /**\n     * Iterate through the command arguments that are considered keys.\n     *\n     * @param {Function} [transform=(key) => key] The transformation that should be applied to\n     * each key. The transformations will persist.\n     * @returns {string[]} The keys of the command.\n     * @memberof Command\n     */\n    _iterateKeys(transform = key => key) {\n        if (typeof this.keys === \"undefined\") {\n            this.keys = [];\n            if (commands.exists(this.name)) {\n                const keyIndexes = commands.getKeyIndexes(this.name, this.args);\n                for (const index of keyIndexes) {\n                    this.args[index] = transform(this.args[index]);\n                    this.keys.push(this.args[index]);\n                }\n            }\n        }\n        return this.keys;\n    }\n    /**\n     * Convert command to writable buffer or string\n     *\n     * @return {string|Buffer}\n     * @see {@link Redis#sendCommand}\n     * @public\n     */\n    toWritable() {\n        let bufferMode = false;\n        for (const arg of this.args) {\n            if (arg instanceof Buffer) {\n                bufferMode = true;\n                break;\n            }\n        }\n        let result;\n        let commandStr = \"*\" +\n            (this.args.length + 1) +\n            \"\\r\\n$\" +\n            Buffer.byteLength(this.name) +\n            \"\\r\\n\" +\n            this.name +\n            \"\\r\\n\";\n        if (bufferMode) {\n            const buffers = new MixedBuffers();\n            buffers.push(commandStr);\n            for (const arg of this.args) {\n                if (arg instanceof Buffer) {\n                    if (arg.length === 0) {\n                        buffers.push(\"$0\\r\\n\\r\\n\");\n                    }\n                    else {\n                        buffers.push(\"$\" + arg.length + \"\\r\\n\");\n                        buffers.push(arg);\n                        buffers.push(\"\\r\\n\");\n                    }\n                }\n                else {\n                    buffers.push(\"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\");\n                }\n            }\n            result = buffers.toBuffer();\n        }\n        else {\n            result = commandStr;\n            for (const arg of this.args) {\n                result +=\n                    \"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\";\n            }\n        }\n        return result;\n    }\n    stringifyArguments() {\n        for (let i = 0; i < this.args.length; ++i) {\n            const arg = this.args[i];\n            if (!(arg instanceof Buffer) && typeof arg !== \"string\") {\n                this.args[i] = utils_1.toArg(arg);\n            }\n        }\n    }\n    /**\n     * Convert the value from buffer to the target encoding.\n     *\n     * @private\n     * @param {Function} resolve The resolve function of the Promise\n     * @returns {Function} A funtion to transform and resolve a value\n     * @memberof Command\n     */\n    _convertValue(resolve) {\n        return value => {\n            try {\n                resolve(this.transformReply(value));\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            return this.promise;\n        };\n    }\n    /**\n     * Convert buffer/buffer[] to string/string[],\n     * and apply reply transformer.\n     *\n     * @memberof Command\n     */\n    transformReply(result) {\n        if (this.replyEncoding) {\n            result = utils_1.convertBufferToString(result, this.replyEncoding);\n        }\n        const transformer = Command._transformer.reply[this.name];\n        if (transformer) {\n            result = transformer(result);\n        }\n        return result;\n    }\n}\nCommand.FLAGS = {\n    VALID_IN_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"ping\",\n        \"quit\"\n    ],\n    VALID_IN_MONITOR_MODE: [\"monitor\", \"auth\"],\n    ENTER_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\"],\n    EXIT_SUBSCRIBER_MODE: [\"unsubscribe\", \"punsubscribe\"],\n    WILL_DISCONNECT: [\"quit\"]\n};\nCommand._transformer = {\n    argument: {},\n    reply: {}\n};\nexports.default = Command;\nconst msetArgumentTransformer = function (args) {\n    if (args.length === 1) {\n        if (typeof Map !== \"undefined\" && args[0] instanceof Map) {\n            return utils_1.convertMapToArray(args[0]);\n        }\n        if (typeof args[0] === \"object\" && args[0] !== null) {\n            return utils_1.convertObjectToArray(args[0]);\n        }\n    }\n    return args;\n};\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", function (args) {\n    if (args.length === 2) {\n        if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n            return [args[0]].concat(utils_1.convertMapToArray(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [args[0]].concat(utils_1.convertObjectToArray(args[1]));\n        }\n    }\n    return args;\n});\nCommand.setReplyTransformer(\"hgetall\", function (result) {\n    if (Array.isArray(result)) {\n        var obj = {};\n        for (var i = 0; i < result.length; i += 2) {\n            obj[result[i]] = result[i + 1];\n        }\n        return obj;\n    }\n    return result;\n});\nCommand.setArgumentTransformer(\"hset\", function (args) {\n    if (args.length === 2) {\n        if (typeof Map !== \"undefined\" && args[1] instanceof Map) {\n            return [args[0]].concat(utils_1.convertMapToArray(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [args[0]].concat(utils_1.convertObjectToArray(args[1]));\n        }\n    }\n    return args;\n});\nclass MixedBuffers {\n    constructor() {\n        this.length = 0;\n        this.items = [];\n    }\n    push(x) {\n        this.length += Buffer.byteLength(x);\n        this.items.push(x);\n    }\n    toBuffer() {\n        const result = Buffer.allocUnsafe(this.length);\n        let offset = 0;\n        for (const item of this.items) {\n            const length = Buffer.byteLength(item);\n            Buffer.isBuffer(item)\n                ? item.copy(result, offset)\n                : result.write(item, offset, length);\n            offset += length;\n        }\n        return result;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}