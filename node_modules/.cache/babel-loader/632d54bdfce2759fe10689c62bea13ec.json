{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util_1 = require(\"./util\");\n\nconst utils_1 = require(\"../utils\");\n\nconst redis_1 = require(\"../redis\");\n\nconst debug = utils_1.Debug(\"cluster:subscriber\");\nconst SUBSCRIBER_CONNECTION_NAME = \"ioredisClusterSubscriber\";\n\nclass ClusterSubscriber {\n  constructor(connectionPool, emitter) {\n    this.connectionPool = connectionPool;\n    this.emitter = emitter;\n    this.started = false;\n    this.subscriber = null;\n    this.connectionPool.on(\"-node\", (_, key) => {\n      if (!this.started || !this.subscriber) {\n        return;\n      }\n\n      if (util_1.getNodeKey(this.subscriber.options) === key) {\n        debug(\"subscriber has left, selecting a new one...\");\n        this.selectSubscriber();\n      }\n    });\n    this.connectionPool.on(\"+node\", () => {\n      if (!this.started || this.subscriber) {\n        return;\n      }\n\n      debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n      this.selectSubscriber();\n    });\n  }\n\n  getInstance() {\n    return this.subscriber;\n  }\n\n  selectSubscriber() {\n    const lastActiveSubscriber = this.lastActiveSubscriber; // Disconnect the previous subscriber even if there\n    // will not be a new one.\n\n    if (lastActiveSubscriber) {\n      lastActiveSubscriber.disconnect();\n    }\n\n    const sampleNode = utils_1.sample(this.connectionPool.getNodes());\n\n    if (!sampleNode) {\n      debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n      this.subscriber = null;\n      return;\n    }\n\n    const {\n      options\n    } = sampleNode;\n    debug(\"selected a subscriber %s:%s\", options.host, options.port);\n    /*\n     * Create a specialized Redis connection for the subscription.\n     * Note that auto reconnection is enabled here.\n     *\n     * `enableReadyCheck` is also enabled because although subscription is allowed\n     * while redis is loading data from the disk, we can check if the password\n     * provided for the subscriber is correct, and if not, the current subscriber\n     * will be disconnected and a new subscriber will be selected.\n     */\n\n    this.subscriber = new redis_1.default({\n      port: options.port,\n      host: options.host,\n      password: options.password,\n      enableReadyCheck: true,\n      connectionName: SUBSCRIBER_CONNECTION_NAME,\n      lazyConnect: true,\n      tls: options.tls\n    }); // Ignore the errors since they're handled in the connection pool.\n\n    this.subscriber.on(\"error\", utils_1.noop); // Re-subscribe previous channels\n\n    var previousChannels = {\n      subscribe: [],\n      psubscribe: []\n    };\n\n    if (lastActiveSubscriber) {\n      const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n\n      if (condition && condition.subscriber) {\n        previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n        previousChannels.psubscribe = condition.subscriber.channels(\"psubscribe\");\n      }\n    }\n\n    if (previousChannels.subscribe.length || previousChannels.psubscribe.length) {\n      var pending = 0;\n\n      for (const type of [\"subscribe\", \"psubscribe\"]) {\n        var channels = previousChannels[type];\n\n        if (channels.length) {\n          pending += 1;\n          debug(\"%s %d channels\", type, channels.length);\n          this.subscriber[type](channels).then(() => {\n            if (! --pending) {\n              this.lastActiveSubscriber = this.subscriber;\n            }\n          }).catch(utils_1.noop);\n        }\n      }\n    } else {\n      this.lastActiveSubscriber = this.subscriber;\n    }\n\n    for (const event of [\"message\", \"messageBuffer\"]) {\n      this.subscriber.on(event, (arg1, arg2) => {\n        this.emitter.emit(event, arg1, arg2);\n      });\n    }\n\n    for (const event of [\"pmessage\", \"pmessageBuffer\"]) {\n      this.subscriber.on(event, (arg1, arg2, arg3) => {\n        this.emitter.emit(event, arg1, arg2, arg3);\n      });\n    }\n  }\n\n  start() {\n    this.started = true;\n    this.selectSubscriber();\n    debug(\"started\");\n  }\n\n  stop() {\n    this.started = false;\n\n    if (this.subscriber) {\n      this.subscriber.disconnect();\n      this.subscriber = null;\n    }\n\n    debug(\"stopped\");\n  }\n\n}\n\nexports.default = ClusterSubscriber;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/cluster/ClusterSubscriber.js"],"names":["Object","defineProperty","exports","value","util_1","require","utils_1","redis_1","debug","Debug","SUBSCRIBER_CONNECTION_NAME","ClusterSubscriber","constructor","connectionPool","emitter","started","subscriber","on","_","key","getNodeKey","options","selectSubscriber","getInstance","lastActiveSubscriber","disconnect","sampleNode","sample","getNodes","host","port","default","password","enableReadyCheck","connectionName","lazyConnect","tls","noop","previousChannels","subscribe","psubscribe","condition","prevCondition","channels","length","pending","type","then","catch","event","arg1","arg2","emit","arg3","start","stop"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\nconst utils_1 = require(\"../utils\");\nconst redis_1 = require(\"../redis\");\nconst debug = utils_1.Debug(\"cluster:subscriber\");\nconst SUBSCRIBER_CONNECTION_NAME = \"ioredisClusterSubscriber\";\nclass ClusterSubscriber {\n    constructor(connectionPool, emitter) {\n        this.connectionPool = connectionPool;\n        this.emitter = emitter;\n        this.started = false;\n        this.subscriber = null;\n        this.connectionPool.on(\"-node\", (_, key) => {\n            if (!this.started || !this.subscriber) {\n                return;\n            }\n            if (util_1.getNodeKey(this.subscriber.options) === key) {\n                debug(\"subscriber has left, selecting a new one...\");\n                this.selectSubscriber();\n            }\n        });\n        this.connectionPool.on(\"+node\", () => {\n            if (!this.started || this.subscriber) {\n                return;\n            }\n            debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n            this.selectSubscriber();\n        });\n    }\n    getInstance() {\n        return this.subscriber;\n    }\n    selectSubscriber() {\n        const lastActiveSubscriber = this.lastActiveSubscriber;\n        // Disconnect the previous subscriber even if there\n        // will not be a new one.\n        if (lastActiveSubscriber) {\n            lastActiveSubscriber.disconnect();\n        }\n        const sampleNode = utils_1.sample(this.connectionPool.getNodes());\n        if (!sampleNode) {\n            debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n            this.subscriber = null;\n            return;\n        }\n        const { options } = sampleNode;\n        debug(\"selected a subscriber %s:%s\", options.host, options.port);\n        /*\n         * Create a specialized Redis connection for the subscription.\n         * Note that auto reconnection is enabled here.\n         *\n         * `enableReadyCheck` is also enabled because although subscription is allowed\n         * while redis is loading data from the disk, we can check if the password\n         * provided for the subscriber is correct, and if not, the current subscriber\n         * will be disconnected and a new subscriber will be selected.\n         */\n        this.subscriber = new redis_1.default({\n            port: options.port,\n            host: options.host,\n            password: options.password,\n            enableReadyCheck: true,\n            connectionName: SUBSCRIBER_CONNECTION_NAME,\n            lazyConnect: true,\n            tls: options.tls\n        });\n        // Ignore the errors since they're handled in the connection pool.\n        this.subscriber.on(\"error\", utils_1.noop);\n        // Re-subscribe previous channels\n        var previousChannels = { subscribe: [], psubscribe: [] };\n        if (lastActiveSubscriber) {\n            const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n            if (condition && condition.subscriber) {\n                previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n                previousChannels.psubscribe = condition.subscriber.channels(\"psubscribe\");\n            }\n        }\n        if (previousChannels.subscribe.length ||\n            previousChannels.psubscribe.length) {\n            var pending = 0;\n            for (const type of [\"subscribe\", \"psubscribe\"]) {\n                var channels = previousChannels[type];\n                if (channels.length) {\n                    pending += 1;\n                    debug(\"%s %d channels\", type, channels.length);\n                    this.subscriber[type](channels)\n                        .then(() => {\n                        if (!--pending) {\n                            this.lastActiveSubscriber = this.subscriber;\n                        }\n                    })\n                        .catch(utils_1.noop);\n                }\n            }\n        }\n        else {\n            this.lastActiveSubscriber = this.subscriber;\n        }\n        for (const event of [\"message\", \"messageBuffer\"]) {\n            this.subscriber.on(event, (arg1, arg2) => {\n                this.emitter.emit(event, arg1, arg2);\n            });\n        }\n        for (const event of [\"pmessage\", \"pmessageBuffer\"]) {\n            this.subscriber.on(event, (arg1, arg2, arg3) => {\n                this.emitter.emit(event, arg1, arg2, arg3);\n            });\n        }\n    }\n    start() {\n        this.started = true;\n        this.selectSubscriber();\n        debug(\"started\");\n    }\n    stop() {\n        this.started = false;\n        if (this.subscriber) {\n            this.subscriber.disconnect();\n            this.subscriber = null;\n        }\n        debug(\"stopped\");\n    }\n}\nexports.default = ClusterSubscriber;\n"]},"metadata":{},"sourceType":"script"}