{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst ClusterAllFailedError_1 = require(\"../errors/ClusterAllFailedError\");\n\nconst utils_1 = require(\"../utils\");\n\nconst ConnectionPool_1 = require(\"./ConnectionPool\");\n\nconst util_1 = require(\"./util\");\n\nconst ClusterSubscriber_1 = require(\"./ClusterSubscriber\");\n\nconst DelayQueue_1 = require(\"./DelayQueue\");\n\nconst ScanStream_1 = require(\"../ScanStream\");\n\nconst redis_errors_1 = require(\"redis-errors\");\n\nconst standard_as_callback_1 = require(\"standard-as-callback\");\n\nconst PromiseContainer = require(\"../promiseContainer\");\n\nconst ClusterOptions_1 = require(\"./ClusterOptions\");\n\nconst utils_2 = require(\"../utils\");\n\nconst commands = require(\"redis-commands\");\n\nconst command_1 = require(\"../command\");\n\nconst redis_1 = require(\"../redis\");\n\nconst commander_1 = require(\"../commander\");\n\nconst Deque = require(\"denque\");\n\nconst debug = utils_1.Debug(\"cluster\");\n/**\n * Client for the official Redis Cluster\n *\n * @class Cluster\n * @extends {EventEmitter}\n */\n\nclass Cluster extends events_1.EventEmitter {\n  /**\n   * Creates an instance of Cluster.\n   *\n   * @param {(Array<string | number | object>)} startupNodes\n   * @param {IClusterOptions} [options={}]\n   * @memberof Cluster\n   */\n  constructor(startupNodes, options = {}) {\n    super();\n    this.slots = [];\n    this.retryAttempts = 0;\n    this.delayQueue = new DelayQueue_1.default();\n    this.offlineQueue = new Deque();\n    this.isRefreshing = false;\n    /**\n     * Every time Cluster#connect() is called, this value will be\n     * auto-incrementing. The purpose of this value is used for\n     * discarding previous connect attampts when creating a new\n     * connection.\n     *\n     * @private\n     * @type {number}\n     * @memberof Cluster\n     */\n\n    this.connectionEpoch = 0;\n    commander_1.default.call(this);\n    this.startupNodes = startupNodes;\n    this.options = utils_1.defaults({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options); // validate options\n\n    if (typeof this.options.scaleReads !== \"function\" && [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n      throw new Error('Invalid option scaleReads \"' + this.options.scaleReads + '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n    }\n\n    this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n    this.connectionPool.on(\"-node\", (redis, key) => {\n      this.emit(\"-node\", redis);\n    });\n    this.connectionPool.on(\"+node\", redis => {\n      this.emit(\"+node\", redis);\n    });\n    this.connectionPool.on(\"drain\", () => {\n      this.setStatus(\"close\");\n    });\n    this.connectionPool.on(\"nodeError\", (error, key) => {\n      this.emit(\"node error\", error, key);\n    });\n    this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n\n    if (this.options.lazyConnect) {\n      this.setStatus(\"wait\");\n    } else {\n      this.connect().catch(err => {\n        debug(\"connecting failed: %s\", err);\n      });\n    }\n  }\n\n  resetOfflineQueue() {\n    this.offlineQueue = new Deque();\n  }\n\n  clearNodesRefreshInterval() {\n    if (this.slotsTimer) {\n      clearTimeout(this.slotsTimer);\n      this.slotsTimer = null;\n    }\n  }\n\n  resetNodesRefreshInterval() {\n    if (this.slotsTimer) {\n      return;\n    }\n\n    const nextRound = () => {\n      this.slotsTimer = setTimeout(() => {\n        debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n        this.refreshSlotsCache(() => {\n          nextRound();\n        });\n      }, this.options.slotsRefreshInterval);\n    };\n\n    nextRound();\n  }\n  /**\n   * Connect to a cluster\n   *\n   * @returns {Promise<void>}\n   * @memberof Cluster\n   */\n\n\n  connect() {\n    const Promise = PromiseContainer.get();\n    return new Promise((resolve, reject) => {\n      if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n        reject(new Error(\"Redis is already connecting/connected\"));\n        return;\n      }\n\n      const epoch = ++this.connectionEpoch;\n      this.setStatus(\"connecting\");\n      this.resolveStartupNodeHostnames().then(nodes => {\n        if (this.connectionEpoch !== epoch) {\n          debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n          reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n          return;\n        }\n\n        if (this.status !== \"connecting\") {\n          debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n          reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n          return;\n        }\n\n        this.connectionPool.reset(nodes);\n\n        function readyHandler() {\n          this.setStatus(\"ready\");\n          this.retryAttempts = 0;\n          this.executeOfflineCommands();\n          this.resetNodesRefreshInterval();\n          resolve();\n        }\n\n        let closeListener;\n\n        const refreshListener = () => {\n          this.removeListener(\"close\", closeListener);\n          this.manuallyClosing = false;\n          this.setStatus(\"connect\");\n\n          if (this.options.enableReadyCheck) {\n            this.readyCheck((err, fail) => {\n              if (err || fail) {\n                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n\n                if (this.status === \"connect\") {\n                  this.disconnect(true);\n                }\n              } else {\n                readyHandler.call(this);\n              }\n            });\n          } else {\n            readyHandler.call(this);\n          }\n        };\n\n        closeListener = function () {\n          this.removeListener(\"refresh\", refreshListener);\n          reject(new Error(\"None of startup nodes is available\"));\n        };\n\n        this.once(\"refresh\", refreshListener);\n        this.once(\"close\", closeListener);\n        this.once(\"close\", this.handleCloseEvent.bind(this));\n        this.refreshSlotsCache(function (err) {\n          if (err && err.message === \"Failed to refresh slots cache.\") {\n            redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n            this.connectionPool.reset([]);\n          }\n        }.bind(this));\n        this.subscriber.start();\n      }).catch(err => {\n        this.setStatus(\"close\");\n        this.handleCloseEvent(err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Called when closed to check whether a reconnection should be made\n   *\n   * @private\n   * @memberof Cluster\n   */\n\n\n  handleCloseEvent(reason) {\n    if (reason) {\n      debug(\"closed because %s\", reason);\n    }\n\n    let retryDelay;\n\n    if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === \"function\") {\n      retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n    }\n\n    if (typeof retryDelay === \"number\") {\n      this.setStatus(\"reconnecting\");\n      this.reconnectTimeout = setTimeout(function () {\n        this.reconnectTimeout = null;\n        debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n        this.connect().catch(function (err) {\n          debug(\"Got error %s when reconnecting. Ignoring...\", err);\n        });\n      }.bind(this), retryDelay);\n    } else {\n      this.setStatus(\"end\");\n      this.flushQueue(new Error(\"None of startup nodes is available\"));\n    }\n  }\n  /**\n   * Disconnect from every node in the cluster.\n   *\n   * @param {boolean} [reconnect=false]\n   * @memberof Cluster\n   */\n\n\n  disconnect(reconnect = false) {\n    const status = this.status;\n    this.setStatus(\"disconnecting\");\n\n    if (!reconnect) {\n      this.manuallyClosing = true;\n    }\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n      debug(\"Canceled reconnecting attempts\");\n    }\n\n    this.clearNodesRefreshInterval();\n    this.subscriber.stop();\n\n    if (status === \"wait\") {\n      this.setStatus(\"close\");\n      this.handleCloseEvent();\n    } else {\n      this.connectionPool.reset([]);\n    }\n  }\n  /**\n   * Quit the cluster gracefully.\n   *\n   * @param {CallbackFunction<'OK'>} [callback]\n   * @returns {Promise<'OK'>}\n   * @memberof Cluster\n   */\n\n\n  quit(callback) {\n    const status = this.status;\n    this.setStatus(\"disconnecting\");\n    this.manuallyClosing = true;\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n\n    this.clearNodesRefreshInterval();\n    this.subscriber.stop();\n    const Promise = PromiseContainer.get();\n\n    if (status === \"wait\") {\n      const ret = standard_as_callback_1.default(Promise.resolve(\"OK\"), callback); // use setImmediate to make sure \"close\" event\n      // being emitted after quit() is returned\n\n      setImmediate(function () {\n        this.setStatus(\"close\");\n        this.handleCloseEvent();\n      }.bind(this));\n      return ret;\n    }\n\n    return standard_as_callback_1.default(Promise.all(this.nodes().map(node => node.quit().catch(err => {\n      // Ignore the error caused by disconnecting since\n      // we're disconnecting...\n      if (err.message === utils_2.CONNECTION_CLOSED_ERROR_MSG) {\n        return \"OK\";\n      }\n\n      throw err;\n    }))).then(() => \"OK\"), callback);\n  }\n  /**\n   * Create a new instance with the same startup nodes and options as the current one.\n   *\n   * @example\n   * ```js\n   * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n   * var anotherCluster = cluster.duplicate();\n   * ```\n   *\n   * @public\n   * @param {(Array<string | number | object>)} [overrideStartupNodes=[]]\n   * @param {IClusterOptions} [overrideOptions={}]\n   * @memberof Cluster\n   */\n\n\n  duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n    const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);\n    const options = Object.assign({}, this.options, overrideOptions);\n    return new Cluster(startupNodes, options);\n  }\n  /**\n   * Get nodes with the specified role\n   *\n   * @param {NodeRole} [role='all']\n   * @returns {any[]}\n   * @memberof Cluster\n   */\n\n\n  nodes(role = \"all\") {\n    if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n      throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n    }\n\n    return this.connectionPool.getNodes(role);\n  }\n  /**\n   * Change cluster instance's status\n   *\n   * @private\n   * @param {ClusterStatus} status\n   * @memberof Cluster\n   */\n\n\n  setStatus(status) {\n    debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n    this.status = status;\n    process.nextTick(() => {\n      this.emit(status);\n    });\n  }\n  /**\n   * Refresh the slot cache\n   *\n   * @private\n   * @param {CallbackFunction} [callback]\n   * @memberof Cluster\n   */\n\n\n  refreshSlotsCache(callback) {\n    if (this.isRefreshing) {\n      if (typeof callback === \"function\") {\n        process.nextTick(callback);\n      }\n\n      return;\n    }\n\n    this.isRefreshing = true;\n\n    const _this = this;\n\n    const wrapper = function (error) {\n      _this.isRefreshing = false;\n\n      if (typeof callback === \"function\") {\n        callback(error);\n      }\n    };\n\n    const nodes = utils_2.shuffle(this.connectionPool.getNodes());\n    let lastNodeError = null;\n\n    function tryNode(index) {\n      if (index === nodes.length) {\n        const error = new ClusterAllFailedError_1.default(\"Failed to refresh slots cache.\", lastNodeError);\n        return wrapper(error);\n      }\n\n      const node = nodes[index];\n      const key = `${node.options.host}:${node.options.port}`;\n      debug(\"getting slot cache from %s\", key);\n\n      _this.getInfoFromNode(node, function (err) {\n        switch (_this.status) {\n          case \"close\":\n          case \"end\":\n            return wrapper(new Error(\"Cluster is disconnected.\"));\n\n          case \"disconnecting\":\n            return wrapper(new Error(\"Cluster is disconnecting.\"));\n        }\n\n        if (err) {\n          _this.emit(\"node error\", err, key);\n\n          lastNodeError = err;\n          tryNode(index + 1);\n        } else {\n          _this.emit(\"refresh\");\n\n          wrapper();\n        }\n      });\n    }\n\n    tryNode(0);\n  }\n  /**\n   * Flush offline queue with error.\n   *\n   * @param {Error} error\n   * @memberof Cluster\n   */\n\n\n  flushQueue(error) {\n    let item;\n\n    while (this.offlineQueue.length > 0) {\n      item = this.offlineQueue.shift();\n      item.command.reject(error);\n    }\n  }\n\n  executeOfflineCommands() {\n    if (this.offlineQueue.length) {\n      debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n      const offlineQueue = this.offlineQueue;\n      this.resetOfflineQueue();\n\n      while (offlineQueue.length > 0) {\n        const item = offlineQueue.shift();\n        this.sendCommand(item.command, item.stream, item.node);\n      }\n    }\n  }\n\n  natMapper(nodeKey) {\n    if (this.options.natMap && typeof this.options.natMap === \"object\") {\n      const key = typeof nodeKey === \"string\" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;\n      const mapped = this.options.natMap[key];\n\n      if (mapped) {\n        debug(\"NAT mapping %s -> %O\", key, mapped);\n        return Object.assign({}, mapped);\n      }\n    }\n\n    return typeof nodeKey === \"string\" ? util_1.nodeKeyToRedisOptions(nodeKey) : nodeKey;\n  }\n\n  sendCommand(command, stream, node) {\n    if (this.status === \"wait\") {\n      this.connect().catch(utils_1.noop);\n    }\n\n    if (this.status === \"end\") {\n      command.reject(new Error(utils_2.CONNECTION_CLOSED_ERROR_MSG));\n      return command.promise;\n    }\n\n    let to = this.options.scaleReads;\n\n    if (to !== \"master\") {\n      const isCommandReadOnly = command.isReadOnly || commands.exists(command.name) && commands.hasFlag(command.name, \"readonly\");\n\n      if (!isCommandReadOnly) {\n        to = \"master\";\n      }\n    }\n\n    let targetSlot = node ? node.slot : command.getSlot();\n    const ttl = {};\n\n    const _this = this;\n\n    if (!node && !command.__is_reject_overwritten) {\n      // eslint-disable-next-line @typescript-eslint/camelcase\n      command.__is_reject_overwritten = true;\n      const reject = command.reject;\n\n      command.reject = function (err) {\n        const partialTry = tryConnection.bind(null, true);\n\n        _this.handleError(err, ttl, {\n          moved: function (slot, key) {\n            debug(\"command %s is moved to %s\", command.name, key);\n            targetSlot = Number(slot);\n\n            if (_this.slots[slot]) {\n              _this.slots[slot][0] = key;\n            } else {\n              _this.slots[slot] = [key];\n            }\n\n            _this.connectionPool.findOrCreate(_this.natMapper(key));\n\n            tryConnection();\n            debug(\"refreshing slot caches... (triggered by MOVED error)\");\n\n            _this.refreshSlotsCache();\n          },\n          ask: function (slot, key) {\n            debug(\"command %s is required to ask %s:%s\", command.name, key);\n\n            const mapped = _this.natMapper(key);\n\n            _this.connectionPool.findOrCreate(mapped);\n\n            tryConnection(false, `${mapped.host}:${mapped.port}`);\n          },\n          tryagain: partialTry,\n          clusterDown: partialTry,\n          connectionClosed: partialTry,\n          maxRedirections: function (redirectionError) {\n            reject.call(command, redirectionError);\n          },\n          defaults: function () {\n            reject.call(command, err);\n          }\n        });\n      };\n    }\n\n    tryConnection();\n\n    function tryConnection(random, asking) {\n      if (_this.status === \"end\") {\n        command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n        return;\n      }\n\n      let redis;\n\n      if (_this.status === \"ready\" || command.name === \"cluster\") {\n        if (node && node.redis) {\n          redis = node.redis;\n        } else if (command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) || command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n          redis = _this.subscriber.getInstance();\n\n          if (!redis) {\n            command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n            return;\n          }\n        } else {\n          if (!random) {\n            if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n              const nodeKeys = _this.slots[targetSlot];\n\n              if (typeof to === \"function\") {\n                const nodes = nodeKeys.map(function (key) {\n                  return _this.connectionPool.getInstanceByKey(key);\n                });\n                redis = to(nodes, command);\n\n                if (Array.isArray(redis)) {\n                  redis = utils_2.sample(redis);\n                }\n\n                if (!redis) {\n                  redis = nodes[0];\n                }\n              } else {\n                let key;\n\n                if (to === \"all\") {\n                  key = utils_2.sample(nodeKeys);\n                } else if (to === \"slave\" && nodeKeys.length > 1) {\n                  key = utils_2.sample(nodeKeys, 1);\n                } else {\n                  key = nodeKeys[0];\n                }\n\n                redis = _this.connectionPool.getInstanceByKey(key);\n              }\n            }\n\n            if (asking) {\n              redis = _this.connectionPool.getInstanceByKey(asking);\n              redis.asking();\n            }\n          }\n\n          if (!redis) {\n            redis = (typeof to === \"function\" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance(\"all\");\n          }\n        }\n\n        if (node && !node.redis) {\n          node.redis = redis;\n        }\n      }\n\n      if (redis) {\n        redis.sendCommand(command, stream);\n      } else if (_this.options.enableOfflineQueue) {\n        _this.offlineQueue.push({\n          command: command,\n          stream: stream,\n          node: node\n        });\n      } else {\n        command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n      }\n    }\n\n    return command.promise;\n  }\n\n  handleError(error, ttl, handlers) {\n    if (typeof ttl.value === \"undefined\") {\n      ttl.value = this.options.maxRedirections;\n    } else {\n      ttl.value -= 1;\n    }\n\n    if (ttl.value <= 0) {\n      handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n      return;\n    }\n\n    const errv = error.message.split(\" \");\n\n    if (errv[0] === \"MOVED\" || errv[0] === \"ASK\") {\n      handlers[errv[0] === \"MOVED\" ? \"moved\" : \"ask\"](errv[1], errv[2]);\n    } else if (errv[0] === \"TRYAGAIN\") {\n      this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n        timeout: this.options.retryDelayOnTryAgain\n      });\n    } else if (errv[0] === \"CLUSTERDOWN\" && this.options.retryDelayOnClusterDown > 0) {\n      this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n        timeout: this.options.retryDelayOnClusterDown,\n        callback: this.refreshSlotsCache.bind(this)\n      });\n    } else if (error.message === utils_2.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === \"ready\") {\n      this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n        timeout: this.options.retryDelayOnFailover,\n        callback: this.refreshSlotsCache.bind(this)\n      });\n    } else {\n      handlers.defaults();\n    }\n  }\n\n  getInfoFromNode(redis, callback) {\n    if (!redis) {\n      return callback(new Error(\"Node is disconnected\"));\n    } // Use a duplication of the connection to avoid\n    // timeouts when the connection is in the blocking\n    // mode (e.g. waiting for BLPOP).\n\n\n    const duplicatedConnection = redis.duplicate({\n      enableOfflineQueue: true,\n      enableReadyCheck: false,\n      retryStrategy: null,\n      connectionName: \"ioredisClusterRefresher\"\n    }); // Ignore error events since we will handle\n    // exceptions for the CLUSTER SLOTS command.\n\n    duplicatedConnection.on(\"error\", utils_1.noop);\n    duplicatedConnection.cluster(\"slots\", utils_2.timeout((err, result) => {\n      duplicatedConnection.disconnect();\n\n      if (err) {\n        return callback(err);\n      }\n\n      if (this.status === \"disconnecting\" || this.status === \"close\" || this.status === \"end\") {\n        debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n        callback();\n        return;\n      }\n\n      const nodes = [];\n      debug(\"cluster slots result count: %d\", result.length);\n\n      for (let i = 0; i < result.length; ++i) {\n        const items = result[i];\n        const slotRangeStart = items[0];\n        const slotRangeEnd = items[1];\n        const keys = [];\n\n        for (let j = 2; j < items.length; j++) {\n          if (!items[j][0]) {\n            continue;\n          }\n\n          items[j] = this.natMapper({\n            host: items[j][0],\n            port: items[j][1]\n          });\n          items[j].readOnly = j !== 2;\n          nodes.push(items[j]);\n          keys.push(items[j].host + \":\" + items[j].port);\n        }\n\n        debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n\n        for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n          this.slots[slot] = keys;\n        }\n      }\n\n      this.connectionPool.reset(nodes);\n      callback();\n    }, this.options.slotsRefreshTimeout));\n  }\n  /**\n   * Check whether Cluster is able to process commands\n   *\n   * @param {Function} callback\n   * @private\n   */\n\n\n  readyCheck(callback) {\n    this.cluster(\"info\", function (err, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (typeof res !== \"string\") {\n        return callback();\n      }\n\n      let state;\n      const lines = res.split(\"\\r\\n\");\n\n      for (let i = 0; i < lines.length; ++i) {\n        const parts = lines[i].split(\":\");\n\n        if (parts[0] === \"cluster_state\") {\n          state = parts[1];\n          break;\n        }\n      }\n\n      if (state === \"fail\") {\n        debug(\"cluster state not ok (%s)\", state);\n        callback(null, state);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  dnsLookup(hostname) {\n    return new Promise((resolve, reject) => {\n      this.options.dnsLookup(hostname, (err, address) => {\n        if (err) {\n          debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n          reject(err);\n        } else {\n          debug(\"resolved hostname %s to IP %s\", hostname, address);\n          resolve(address);\n        }\n      });\n    });\n  }\n  /**\n   * Normalize startup nodes, and resolving hostnames to IPs.\n   *\n   * This process happens every time when #connect() is called since\n   * #startupNodes and DNS records may chanage.\n   *\n   * @private\n   * @returns {Promise<IRedisOptions[]>}\n   */\n\n\n  resolveStartupNodeHostnames() {\n    if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n      return Promise.reject(new Error(\"`startupNodes` should contain at least one node.\"));\n    }\n\n    const startupNodes = util_1.normalizeNodeOptions(this.startupNodes);\n    const hostnames = util_1.getUniqueHostnamesFromOptions(startupNodes);\n\n    if (hostnames.length === 0) {\n      return Promise.resolve(startupNodes);\n    }\n\n    return Promise.all(hostnames.map(hostname => this.dnsLookup(hostname))).then(ips => {\n      const hostnameToIP = utils_2.zipMap(hostnames, ips);\n      return startupNodes.map(node => hostnameToIP.has(node.host) ? Object.assign({}, node, {\n        host: hostnameToIP.get(node.host)\n      }) : node);\n    });\n  }\n\n}\n\nObject.getOwnPropertyNames(commander_1.default.prototype).forEach(name => {\n  if (!Cluster.prototype.hasOwnProperty(name)) {\n    Cluster.prototype[name] = commander_1.default.prototype[name];\n  }\n});\nconst scanCommands = [\"sscan\", \"hscan\", \"zscan\", \"sscanBuffer\", \"hscanBuffer\", \"zscanBuffer\"];\nscanCommands.forEach(command => {\n  Cluster.prototype[command + \"Stream\"] = function (key, options) {\n    return new ScanStream_1.default(utils_1.defaults({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command\n    }, options));\n  };\n});\n\nrequire(\"../transaction\").addTransactionSupport(Cluster.prototype);\n\nexports.default = Cluster;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/cluster/index.js"],"names":["Object","defineProperty","exports","value","events_1","require","ClusterAllFailedError_1","utils_1","ConnectionPool_1","util_1","ClusterSubscriber_1","DelayQueue_1","ScanStream_1","redis_errors_1","standard_as_callback_1","PromiseContainer","ClusterOptions_1","utils_2","commands","command_1","redis_1","commander_1","Deque","debug","Debug","Cluster","EventEmitter","constructor","startupNodes","options","slots","retryAttempts","delayQueue","default","offlineQueue","isRefreshing","connectionEpoch","call","defaults","DEFAULT_CLUSTER_OPTIONS","scaleReads","indexOf","Error","connectionPool","redisOptions","on","redis","key","emit","setStatus","error","subscriber","lazyConnect","connect","catch","err","resetOfflineQueue","clearNodesRefreshInterval","slotsTimer","clearTimeout","resetNodesRefreshInterval","nextRound","setTimeout","refreshSlotsCache","slotsRefreshInterval","Promise","get","resolve","reject","status","epoch","resolveStartupNodeHostnames","then","nodes","RedisError","reset","readyHandler","executeOfflineCommands","closeListener","refreshListener","removeListener","manuallyClosing","enableReadyCheck","readyCheck","fail","disconnect","once","handleCloseEvent","bind","message","prototype","silentEmit","start","reason","retryDelay","clusterRetryStrategy","reconnectTimeout","flushQueue","reconnect","stop","quit","callback","ret","setImmediate","all","map","node","CONNECTION_CLOSED_ERROR_MSG","duplicate","overrideStartupNodes","overrideOptions","length","slice","assign","role","getNodes","process","nextTick","_this","wrapper","shuffle","lastNodeError","tryNode","index","host","port","getInfoFromNode","item","shift","command","sendCommand","stream","natMapper","nodeKey","natMap","mapped","nodeKeyToRedisOptions","noop","promise","to","isCommandReadOnly","isReadOnly","exists","name","hasFlag","targetSlot","slot","getSlot","ttl","__is_reject_overwritten","partialTry","tryConnection","handleError","moved","Number","findOrCreate","ask","tryagain","clusterDown","connectionClosed","maxRedirections","redirectionError","random","asking","AbortError","checkFlag","getInstance","nodeKeys","getInstanceByKey","Array","isArray","sample","getSampleInstance","enableOfflineQueue","push","handlers","errv","split","timeout","retryDelayOnTryAgain","retryDelayOnClusterDown","retryDelayOnFailover","duplicatedConnection","retryStrategy","connectionName","cluster","result","i","items","slotRangeStart","slotRangeEnd","keys","j","readOnly","slotsRefreshTimeout","res","state","lines","parts","dnsLookup","hostname","address","normalizeNodeOptions","hostnames","getUniqueHostnamesFromOptions","ips","hostnameToIP","zipMap","has","getOwnPropertyNames","forEach","hasOwnProperty","scanCommands","objectMode","addTransactionSupport"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst ClusterAllFailedError_1 = require(\"../errors/ClusterAllFailedError\");\nconst utils_1 = require(\"../utils\");\nconst ConnectionPool_1 = require(\"./ConnectionPool\");\nconst util_1 = require(\"./util\");\nconst ClusterSubscriber_1 = require(\"./ClusterSubscriber\");\nconst DelayQueue_1 = require(\"./DelayQueue\");\nconst ScanStream_1 = require(\"../ScanStream\");\nconst redis_errors_1 = require(\"redis-errors\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst PromiseContainer = require(\"../promiseContainer\");\nconst ClusterOptions_1 = require(\"./ClusterOptions\");\nconst utils_2 = require(\"../utils\");\nconst commands = require(\"redis-commands\");\nconst command_1 = require(\"../command\");\nconst redis_1 = require(\"../redis\");\nconst commander_1 = require(\"../commander\");\nconst Deque = require(\"denque\");\nconst debug = utils_1.Debug(\"cluster\");\n/**\n * Client for the official Redis Cluster\n *\n * @class Cluster\n * @extends {EventEmitter}\n */\nclass Cluster extends events_1.EventEmitter {\n    /**\n     * Creates an instance of Cluster.\n     *\n     * @param {(Array<string | number | object>)} startupNodes\n     * @param {IClusterOptions} [options={}]\n     * @memberof Cluster\n     */\n    constructor(startupNodes, options = {}) {\n        super();\n        this.slots = [];\n        this.retryAttempts = 0;\n        this.delayQueue = new DelayQueue_1.default();\n        this.offlineQueue = new Deque();\n        this.isRefreshing = false;\n        /**\n         * Every time Cluster#connect() is called, this value will be\n         * auto-incrementing. The purpose of this value is used for\n         * discarding previous connect attampts when creating a new\n         * connection.\n         *\n         * @private\n         * @type {number}\n         * @memberof Cluster\n         */\n        this.connectionEpoch = 0;\n        commander_1.default.call(this);\n        this.startupNodes = startupNodes;\n        this.options = utils_1.defaults({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n        // validate options\n        if (typeof this.options.scaleReads !== \"function\" &&\n            [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n            throw new Error('Invalid option scaleReads \"' +\n                this.options.scaleReads +\n                '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n        }\n        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n        this.connectionPool.on(\"-node\", (redis, key) => {\n            this.emit(\"-node\", redis);\n        });\n        this.connectionPool.on(\"+node\", redis => {\n            this.emit(\"+node\", redis);\n        });\n        this.connectionPool.on(\"drain\", () => {\n            this.setStatus(\"close\");\n        });\n        this.connectionPool.on(\"nodeError\", (error, key) => {\n            this.emit(\"node error\", error, key);\n        });\n        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch(err => {\n                debug(\"connecting failed: %s\", err);\n            });\n        }\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    clearNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            clearTimeout(this.slotsTimer);\n            this.slotsTimer = null;\n        }\n    }\n    resetNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            return;\n        }\n        const nextRound = () => {\n            this.slotsTimer = setTimeout(() => {\n                debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n                this.refreshSlotsCache(() => {\n                    nextRound();\n                });\n            }, this.options.slotsRefreshInterval);\n        };\n        nextRound();\n    }\n    /**\n     * Connect to a cluster\n     *\n     * @returns {Promise<void>}\n     * @memberof Cluster\n     */\n    connect() {\n        const Promise = PromiseContainer.get();\n        return new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            const epoch = ++this.connectionEpoch;\n            this.setStatus(\"connecting\");\n            this.resolveStartupNodeHostnames()\n                .then(nodes => {\n                if (this.connectionEpoch !== epoch) {\n                    debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n                    reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n                    return;\n                }\n                if (this.status !== \"connecting\") {\n                    debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n                    reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n                    return;\n                }\n                this.connectionPool.reset(nodes);\n                function readyHandler() {\n                    this.setStatus(\"ready\");\n                    this.retryAttempts = 0;\n                    this.executeOfflineCommands();\n                    this.resetNodesRefreshInterval();\n                    resolve();\n                }\n                let closeListener;\n                const refreshListener = () => {\n                    this.removeListener(\"close\", closeListener);\n                    this.manuallyClosing = false;\n                    this.setStatus(\"connect\");\n                    if (this.options.enableReadyCheck) {\n                        this.readyCheck((err, fail) => {\n                            if (err || fail) {\n                                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                                if (this.status === \"connect\") {\n                                    this.disconnect(true);\n                                }\n                            }\n                            else {\n                                readyHandler.call(this);\n                            }\n                        });\n                    }\n                    else {\n                        readyHandler.call(this);\n                    }\n                };\n                closeListener = function () {\n                    this.removeListener(\"refresh\", refreshListener);\n                    reject(new Error(\"None of startup nodes is available\"));\n                };\n                this.once(\"refresh\", refreshListener);\n                this.once(\"close\", closeListener);\n                this.once(\"close\", this.handleCloseEvent.bind(this));\n                this.refreshSlotsCache(function (err) {\n                    if (err && err.message === \"Failed to refresh slots cache.\") {\n                        redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n                        this.connectionPool.reset([]);\n                    }\n                }.bind(this));\n                this.subscriber.start();\n            })\n                .catch(err => {\n                this.setStatus(\"close\");\n                this.handleCloseEvent(err);\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     *\n     * @private\n     * @memberof Cluster\n     */\n    handleCloseEvent(reason) {\n        if (reason) {\n            debug(\"closed because %s\", reason);\n        }\n        let retryDelay;\n        if (!this.manuallyClosing &&\n            typeof this.options.clusterRetryStrategy === \"function\") {\n            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n        }\n        if (typeof retryDelay === \"number\") {\n            this.setStatus(\"reconnecting\");\n            this.reconnectTimeout = setTimeout(function () {\n                this.reconnectTimeout = null;\n                debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n                this.connect().catch(function (err) {\n                    debug(\"Got error %s when reconnecting. Ignoring...\", err);\n                });\n            }.bind(this), retryDelay);\n        }\n        else {\n            this.setStatus(\"end\");\n            this.flushQueue(new Error(\"None of startup nodes is available\"));\n        }\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     *\n     * @param {boolean} [reconnect=false]\n     * @memberof Cluster\n     */\n    disconnect(reconnect = false) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n            debug(\"Canceled reconnecting attempts\");\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (status === \"wait\") {\n            this.setStatus(\"close\");\n            this.handleCloseEvent();\n        }\n        else {\n            this.connectionPool.reset([]);\n        }\n    }\n    /**\n     * Quit the cluster gracefully.\n     *\n     * @param {CallbackFunction<'OK'>} [callback]\n     * @returns {Promise<'OK'>}\n     * @memberof Cluster\n     */\n    quit(callback) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        this.manuallyClosing = true;\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        const Promise = PromiseContainer.get();\n        if (status === \"wait\") {\n            const ret = standard_as_callback_1.default(Promise.resolve(\"OK\"), callback);\n            // use setImmediate to make sure \"close\" event\n            // being emitted after quit() is returned\n            setImmediate(function () {\n                this.setStatus(\"close\");\n                this.handleCloseEvent();\n            }.bind(this));\n            return ret;\n        }\n        return standard_as_callback_1.default(Promise.all(this.nodes().map(node => node.quit().catch(err => {\n            // Ignore the error caused by disconnecting since\n            // we're disconnecting...\n            if (err.message === utils_2.CONNECTION_CLOSED_ERROR_MSG) {\n                return \"OK\";\n            }\n            throw err;\n        }))).then(() => \"OK\"), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     *\n     * @public\n     * @param {(Array<string | number | object>)} [overrideStartupNodes=[]]\n     * @param {IClusterOptions} [overrideOptions={}]\n     * @memberof Cluster\n     */\n    duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n        const startupNodes = overrideStartupNodes.length > 0\n            ? overrideStartupNodes\n            : this.startupNodes.slice(0);\n        const options = Object.assign({}, this.options, overrideOptions);\n        return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     *\n     * @param {NodeRole} [role='all']\n     * @returns {any[]}\n     * @memberof Cluster\n     */\n    nodes(role = \"all\") {\n        if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n            throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n        }\n        return this.connectionPool.getNodes(role);\n    }\n    /**\n     * Change cluster instance's status\n     *\n     * @private\n     * @param {ClusterStatus} status\n     * @memberof Cluster\n     */\n    setStatus(status) {\n        debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n        this.status = status;\n        process.nextTick(() => {\n            this.emit(status);\n        });\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @private\n     * @param {CallbackFunction} [callback]\n     * @memberof Cluster\n     */\n    refreshSlotsCache(callback) {\n        if (this.isRefreshing) {\n            if (typeof callback === \"function\") {\n                process.nextTick(callback);\n            }\n            return;\n        }\n        this.isRefreshing = true;\n        const _this = this;\n        const wrapper = function (error) {\n            _this.isRefreshing = false;\n            if (typeof callback === \"function\") {\n                callback(error);\n            }\n        };\n        const nodes = utils_2.shuffle(this.connectionPool.getNodes());\n        let lastNodeError = null;\n        function tryNode(index) {\n            if (index === nodes.length) {\n                const error = new ClusterAllFailedError_1.default(\"Failed to refresh slots cache.\", lastNodeError);\n                return wrapper(error);\n            }\n            const node = nodes[index];\n            const key = `${node.options.host}:${node.options.port}`;\n            debug(\"getting slot cache from %s\", key);\n            _this.getInfoFromNode(node, function (err) {\n                switch (_this.status) {\n                    case \"close\":\n                    case \"end\":\n                        return wrapper(new Error(\"Cluster is disconnected.\"));\n                    case \"disconnecting\":\n                        return wrapper(new Error(\"Cluster is disconnecting.\"));\n                }\n                if (err) {\n                    _this.emit(\"node error\", err, key);\n                    lastNodeError = err;\n                    tryNode(index + 1);\n                }\n                else {\n                    _this.emit(\"refresh\");\n                    wrapper();\n                }\n            });\n        }\n        tryNode(0);\n    }\n    /**\n     * Flush offline queue with error.\n     *\n     * @param {Error} error\n     * @memberof Cluster\n     */\n    flushQueue(error) {\n        let item;\n        while (this.offlineQueue.length > 0) {\n            item = this.offlineQueue.shift();\n            item.command.reject(error);\n        }\n    }\n    executeOfflineCommands() {\n        if (this.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n            const offlineQueue = this.offlineQueue;\n            this.resetOfflineQueue();\n            while (offlineQueue.length > 0) {\n                const item = offlineQueue.shift();\n                this.sendCommand(item.command, item.stream, item.node);\n            }\n        }\n    }\n    natMapper(nodeKey) {\n        if (this.options.natMap && typeof this.options.natMap === \"object\") {\n            const key = typeof nodeKey === \"string\"\n                ? nodeKey\n                : `${nodeKey.host}:${nodeKey.port}`;\n            const mapped = this.options.natMap[key];\n            if (mapped) {\n                debug(\"NAT mapping %s -> %O\", key, mapped);\n                return Object.assign({}, mapped);\n            }\n        }\n        return typeof nodeKey === \"string\"\n            ? util_1.nodeKeyToRedisOptions(nodeKey)\n            : nodeKey;\n    }\n    sendCommand(command, stream, node) {\n        if (this.status === \"wait\") {\n            this.connect().catch(utils_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_2.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        let to = this.options.scaleReads;\n        if (to !== \"master\") {\n            const isCommandReadOnly = command.isReadOnly ||\n                (commands.exists(command.name) &&\n                    commands.hasFlag(command.name, \"readonly\"));\n            if (!isCommandReadOnly) {\n                to = \"master\";\n            }\n        }\n        let targetSlot = node ? node.slot : command.getSlot();\n        const ttl = {};\n        const _this = this;\n        if (!node && !command.__is_reject_overwritten) {\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            command.__is_reject_overwritten = true;\n            const reject = command.reject;\n            command.reject = function (err) {\n                const partialTry = tryConnection.bind(null, true);\n                _this.handleError(err, ttl, {\n                    moved: function (slot, key) {\n                        debug(\"command %s is moved to %s\", command.name, key);\n                        targetSlot = Number(slot);\n                        if (_this.slots[slot]) {\n                            _this.slots[slot][0] = key;\n                        }\n                        else {\n                            _this.slots[slot] = [key];\n                        }\n                        _this.connectionPool.findOrCreate(_this.natMapper(key));\n                        tryConnection();\n                        debug(\"refreshing slot caches... (triggered by MOVED error)\");\n                        _this.refreshSlotsCache();\n                    },\n                    ask: function (slot, key) {\n                        debug(\"command %s is required to ask %s:%s\", command.name, key);\n                        const mapped = _this.natMapper(key);\n                        _this.connectionPool.findOrCreate(mapped);\n                        tryConnection(false, `${mapped.host}:${mapped.port}`);\n                    },\n                    tryagain: partialTry,\n                    clusterDown: partialTry,\n                    connectionClosed: partialTry,\n                    maxRedirections: function (redirectionError) {\n                        reject.call(command, redirectionError);\n                    },\n                    defaults: function () {\n                        reject.call(command, err);\n                    }\n                });\n            };\n        }\n        tryConnection();\n        function tryConnection(random, asking) {\n            if (_this.status === \"end\") {\n                command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n                return;\n            }\n            let redis;\n            if (_this.status === \"ready\" || command.name === \"cluster\") {\n                if (node && node.redis) {\n                    redis = node.redis;\n                }\n                else if (command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) ||\n                    command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n                    redis = _this.subscriber.getInstance();\n                    if (!redis) {\n                        command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n                        return;\n                    }\n                }\n                else {\n                    if (!random) {\n                        if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                            const nodeKeys = _this.slots[targetSlot];\n                            if (typeof to === \"function\") {\n                                const nodes = nodeKeys.map(function (key) {\n                                    return _this.connectionPool.getInstanceByKey(key);\n                                });\n                                redis = to(nodes, command);\n                                if (Array.isArray(redis)) {\n                                    redis = utils_2.sample(redis);\n                                }\n                                if (!redis) {\n                                    redis = nodes[0];\n                                }\n                            }\n                            else {\n                                let key;\n                                if (to === \"all\") {\n                                    key = utils_2.sample(nodeKeys);\n                                }\n                                else if (to === \"slave\" && nodeKeys.length > 1) {\n                                    key = utils_2.sample(nodeKeys, 1);\n                                }\n                                else {\n                                    key = nodeKeys[0];\n                                }\n                                redis = _this.connectionPool.getInstanceByKey(key);\n                            }\n                        }\n                        if (asking) {\n                            redis = _this.connectionPool.getInstanceByKey(asking);\n                            redis.asking();\n                        }\n                    }\n                    if (!redis) {\n                        redis =\n                            (typeof to === \"function\"\n                                ? null\n                                : _this.connectionPool.getSampleInstance(to)) ||\n                                _this.connectionPool.getSampleInstance(\"all\");\n                    }\n                }\n                if (node && !node.redis) {\n                    node.redis = redis;\n                }\n            }\n            if (redis) {\n                redis.sendCommand(command, stream);\n            }\n            else if (_this.options.enableOfflineQueue) {\n                _this.offlineQueue.push({\n                    command: command,\n                    stream: stream,\n                    node: node\n                });\n            }\n            else {\n                command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n            }\n        }\n        return command.promise;\n    }\n    handleError(error, ttl, handlers) {\n        if (typeof ttl.value === \"undefined\") {\n            ttl.value = this.options.maxRedirections;\n        }\n        else {\n            ttl.value -= 1;\n        }\n        if (ttl.value <= 0) {\n            handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n            return;\n        }\n        const errv = error.message.split(\" \");\n        if (errv[0] === \"MOVED\" || errv[0] === \"ASK\") {\n            handlers[errv[0] === \"MOVED\" ? \"moved\" : \"ask\"](errv[1], errv[2]);\n        }\n        else if (errv[0] === \"TRYAGAIN\") {\n            this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n                timeout: this.options.retryDelayOnTryAgain\n            });\n        }\n        else if (errv[0] === \"CLUSTERDOWN\" &&\n            this.options.retryDelayOnClusterDown > 0) {\n            this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnClusterDown,\n                callback: this.refreshSlotsCache.bind(this)\n            });\n        }\n        else if (error.message === utils_2.CONNECTION_CLOSED_ERROR_MSG &&\n            this.options.retryDelayOnFailover > 0 &&\n            this.status === \"ready\") {\n            this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnFailover,\n                callback: this.refreshSlotsCache.bind(this)\n            });\n        }\n        else {\n            handlers.defaults();\n        }\n    }\n    getInfoFromNode(redis, callback) {\n        if (!redis) {\n            return callback(new Error(\"Node is disconnected\"));\n        }\n        // Use a duplication of the connection to avoid\n        // timeouts when the connection is in the blocking\n        // mode (e.g. waiting for BLPOP).\n        const duplicatedConnection = redis.duplicate({\n            enableOfflineQueue: true,\n            enableReadyCheck: false,\n            retryStrategy: null,\n            connectionName: \"ioredisClusterRefresher\"\n        });\n        // Ignore error events since we will handle\n        // exceptions for the CLUSTER SLOTS command.\n        duplicatedConnection.on(\"error\", utils_1.noop);\n        duplicatedConnection.cluster(\"slots\", utils_2.timeout((err, result) => {\n            duplicatedConnection.disconnect();\n            if (err) {\n                return callback(err);\n            }\n            if (this.status === \"disconnecting\" ||\n                this.status === \"close\" ||\n                this.status === \"end\") {\n                debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n                callback();\n                return;\n            }\n            const nodes = [];\n            debug(\"cluster slots result count: %d\", result.length);\n            for (let i = 0; i < result.length; ++i) {\n                const items = result[i];\n                const slotRangeStart = items[0];\n                const slotRangeEnd = items[1];\n                const keys = [];\n                for (let j = 2; j < items.length; j++) {\n                    if (!items[j][0]) {\n                        continue;\n                    }\n                    items[j] = this.natMapper({ host: items[j][0], port: items[j][1] });\n                    items[j].readOnly = j !== 2;\n                    nodes.push(items[j]);\n                    keys.push(items[j].host + \":\" + items[j].port);\n                }\n                debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n                for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n                    this.slots[slot] = keys;\n                }\n            }\n            this.connectionPool.reset(nodes);\n            callback();\n        }, this.options.slotsRefreshTimeout));\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     *\n     * @param {Function} callback\n     * @private\n     */\n    readyCheck(callback) {\n        this.cluster(\"info\", function (err, res) {\n            if (err) {\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback();\n            }\n            let state;\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const parts = lines[i].split(\":\");\n                if (parts[0] === \"cluster_state\") {\n                    state = parts[1];\n                    break;\n                }\n            }\n            if (state === \"fail\") {\n                debug(\"cluster state not ok (%s)\", state);\n                callback(null, state);\n            }\n            else {\n                callback();\n            }\n        });\n    }\n    dnsLookup(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.dnsLookup(hostname, (err, address) => {\n                if (err) {\n                    debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n                    reject(err);\n                }\n                else {\n                    debug(\"resolved hostname %s to IP %s\", hostname, address);\n                    resolve(address);\n                }\n            });\n        });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     *\n     * @private\n     * @returns {Promise<IRedisOptions[]>}\n     */\n    resolveStartupNodeHostnames() {\n        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n            return Promise.reject(new Error(\"`startupNodes` should contain at least one node.\"));\n        }\n        const startupNodes = util_1.normalizeNodeOptions(this.startupNodes);\n        const hostnames = util_1.getUniqueHostnamesFromOptions(startupNodes);\n        if (hostnames.length === 0) {\n            return Promise.resolve(startupNodes);\n        }\n        return Promise.all(hostnames.map(hostname => this.dnsLookup(hostname))).then(ips => {\n            const hostnameToIP = utils_2.zipMap(hostnames, ips);\n            return startupNodes.map(node => hostnameToIP.has(node.host)\n                ? Object.assign({}, node, { host: hostnameToIP.get(node.host) })\n                : node);\n        });\n    }\n}\nObject.getOwnPropertyNames(commander_1.default.prototype).forEach(name => {\n    if (!Cluster.prototype.hasOwnProperty(name)) {\n        Cluster.prototype[name] = commander_1.default.prototype[name];\n    }\n});\nconst scanCommands = [\n    \"sscan\",\n    \"hscan\",\n    \"zscan\",\n    \"sscanBuffer\",\n    \"hscanBuffer\",\n    \"zscanBuffer\"\n];\nscanCommands.forEach(command => {\n    Cluster.prototype[command + \"Stream\"] = function (key, options) {\n        return new ScanStream_1.default(utils_1.defaults({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command\n        }, options));\n    };\n});\nrequire(\"../transaction\").addTransactionSupport(Cluster.prototype);\nexports.default = Cluster;\n"]},"metadata":{},"sourceType":"script"}