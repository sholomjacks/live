{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = require(\"../utils/lodash\");\n\nconst util_1 = require(\"util\");\n\nconst events_1 = require(\"events\");\n\nconst Deque = require(\"denque\");\n\nconst command_1 = require(\"../command\");\n\nconst commander_1 = require(\"../commander\");\n\nconst utils_1 = require(\"../utils\");\n\nconst standard_as_callback_1 = require(\"standard-as-callback\");\n\nconst eventHandler = require(\"./event_handler\");\n\nconst connectors_1 = require(\"../connectors\");\n\nconst ScanStream_1 = require(\"../ScanStream\");\n\nconst commands = require(\"redis-commands\");\n\nconst PromiseContainer = require(\"../promiseContainer\");\n\nconst transaction_1 = require(\"../transaction\");\n\nconst RedisOptions_1 = require(\"./RedisOptions\");\n\nvar debug = utils_1.Debug(\"redis\");\n/**\n * Creates a Redis instance\n *\n * @constructor\n * @param {(number|string|Object)} [port=6379] - Port of the Redis server,\n * or a URL string(see the examples below),\n * or the `options` object(see the third argument).\n * @param {string|Object} [host=localhost] - Host of the Redis server,\n * when the first argument is a URL string,\n * this argument is an object represents the options.\n * @param {Object} [options] - Other options.\n * @param {number} [options.port=6379] - Port of the Redis server.\n * @param {string} [options.host=localhost] - Host of the Redis server.\n * @param {string} [options.family=4] - Version of IP stack. Defaults to 4.\n * @param {string} [options.path=null] - Local domain socket path. If set the `port`,\n * `host` and `family` will be ignored.\n * @param {number} [options.keepAlive=0] - TCP KeepAlive on the socket with a X ms delay before start.\n * Set to a non-number value to disable keepAlive.\n * @param {boolean} [options.noDelay=true] - Whether to disable the Nagle's Algorithm. By default we disable\n * it to reduce the latency.\n * @param {string} [options.connectionName=null] - Connection name.\n * @param {number} [options.db=0] - Database index to use.\n * @param {string} [options.password=null] - If set, client will send AUTH command\n * with the value of this option when connected.\n * @param {boolean} [options.dropBufferSupport=false] - Drop the buffer support for better performance.\n * This option is recommended to be enabled when\n * handling large array response and you don't need the buffer support.\n * @param {boolean} [options.enableReadyCheck=true] - When a connection is established to\n * the Redis server, the server might still be loading the database from disk.\n * While loading, the server not respond to any commands.\n * To work around this, when this option is `true`,\n * ioredis will check the status of the Redis server,\n * and when the Redis server is able to process commands,\n * a `ready` event will be emitted.\n * @param {boolean} [options.enableOfflineQueue=true] - By default,\n * if there is no active connection to the Redis server,\n * commands are added to a queue and are executed once the connection is \"ready\"\n * (when `enableReadyCheck` is `true`,\n * \"ready\" means the Redis server has loaded the database from disk, otherwise means the connection\n * to the Redis server has been established). If this option is false,\n * when execute the command when the connection isn't ready, an error will be returned.\n * @param {number} [options.connectTimeout=10000] - The milliseconds before a timeout occurs during the initial\n * connection to the Redis server.\n * @param {boolean} [options.autoResubscribe=true] - After reconnected, if the previous connection was in the\n * subscriber mode, client will auto re-subscribe these channels.\n * @param {boolean} [options.autoResendUnfulfilledCommands=true] - If true, client will resend unfulfilled\n * commands(e.g. block commands) in the previous connection when reconnected.\n * @param {boolean} [options.lazyConnect=false] - By default,\n * When a new `Redis` instance is created, it will connect to Redis server automatically.\n * If you want to keep the instance disconnected until a command is called, you can pass the `lazyConnect` option to\n * the constructor:\n *\n * ```javascript\n * var redis = new Redis({ lazyConnect: true });\n * // No attempting to connect to the Redis server here.\n\n * // Now let's connect to the Redis server\n * redis.get('foo', function () {\n * });\n * ```\n * @param {Object} [options.tls] - TLS connection support. See https://github.com/luin/ioredis#tls-options\n * @param {string} [options.keyPrefix=''] - The prefix to prepend to all keys in a command.\n * @param {function} [options.retryStrategy] - See \"Quick Start\" section\n * @param {number} [options.maxRetriesPerRequest] - See \"Quick Start\" section\n * @param {number} [options.maxLoadingRetryTime=10000] - when redis server is not ready, we will wait for\n * `loading_eta_seconds` from `info` command or maxLoadingRetryTime (milliseconds), whichever is smaller.\n * @param {function} [options.reconnectOnError] - See \"Quick Start\" section\n * @param {boolean} [options.readOnly=false] - Enable READONLY mode for the connection.\n * Only available for cluster mode.\n * @param {boolean} [options.stringNumbers=false] - Force numbers to be always returned as JavaScript\n * strings. This option is necessary when dealing with big numbers (exceed the [-2^53, +2^53] range).\n * @param {boolean} [options.enableTLSForSentinelMode=false] - Whether to support the `tls` option\n * when connecting to Redis via sentinel mode.\n * @param {NatMap} [options.natMap=null] NAT map for sentinel connector.\n * @param {boolean} [options.updateSentinels=true] - Update the given `sentinels` list with new IP\n * addresses when communicating with existing sentinels.\n * @extends [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)\n * @extends Commander\n * @example\n * ```js\n * var Redis = require('ioredis');\n *\n * var redis = new Redis();\n *\n * var redisOnPort6380 = new Redis(6380);\n * var anotherRedis = new Redis(6380, '192.168.100.1');\n * var unixSocketRedis = new Redis({ path: '/tmp/echo.sock' });\n * var unixSocketRedis2 = new Redis('/tmp/echo.sock');\n * var urlRedis = new Redis('redis://user:password@redis-service.com:6379/');\n * var urlRedis2 = new Redis('//localhost:6379');\n * var urlRedisTls = new Redis('rediss://user:password@redis-service.com:6379/');\n * var authedRedis = new Redis(6380, '192.168.100.1', { password: 'password' });\n * ```\n */\n\nexports.default = Redis;\n\nfunction Redis() {\n  if (!(this instanceof Redis)) {\n    console.error(new Error(\"Calling `Redis()` like a function is deprecated. Using `new Redis()` instead.\").stack.replace(\"Error\", \"Warning\"));\n    return new Redis(arguments[0], arguments[1], arguments[2]);\n  }\n\n  this.parseOptions(arguments[0], arguments[1], arguments[2]);\n  events_1.EventEmitter.call(this);\n  commander_1.default.call(this);\n  this.resetCommandQueue();\n  this.resetOfflineQueue();\n  this.connectionEpoch = 0;\n\n  if (this.options.Connector) {\n    this.connector = new this.options.Connector(this.options);\n  } else if (this.options.sentinels) {\n    this.connector = new connectors_1.SentinelConnector(this.options);\n  } else {\n    this.connector = new connectors_1.StandaloneConnector(this.options);\n  }\n\n  this.retryAttempts = 0; // end(or wait) -> connecting -> connect -> ready -> end\n\n  if (this.options.lazyConnect) {\n    this.setStatus(\"wait\");\n  } else {\n    this.connect().catch(lodash_1.noop);\n  }\n}\n\nutil_1.inherits(Redis, events_1.EventEmitter);\nObject.assign(Redis.prototype, commander_1.default.prototype);\n/**\n * Create a Redis instance\n *\n * @deprecated\n */\n// @ts-ignore\n\nRedis.createClient = function (...args) {\n  // @ts-ignore\n  return new Redis(...args);\n};\n/**\n * Default options\n *\n * @var defaultOptions\n * @private\n */\n\n\nRedis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n\nRedis.prototype.resetCommandQueue = function () {\n  this.commandQueue = new Deque();\n};\n\nRedis.prototype.resetOfflineQueue = function () {\n  this.offlineQueue = new Deque();\n};\n\nRedis.prototype.parseOptions = function () {\n  this.options = {};\n  let isTls = false;\n\n  for (var i = 0; i < arguments.length; ++i) {\n    var arg = arguments[i];\n\n    if (arg === null || typeof arg === \"undefined\") {\n      continue;\n    }\n\n    if (typeof arg === \"object\") {\n      lodash_1.defaults(this.options, arg);\n    } else if (typeof arg === \"string\") {\n      lodash_1.defaults(this.options, utils_1.parseURL(arg));\n\n      if (arg.startsWith(\"rediss://\")) {\n        isTls = true;\n      }\n    } else if (typeof arg === \"number\") {\n      this.options.port = arg;\n    } else {\n      throw new Error(\"Invalid argument \" + arg);\n    }\n  }\n\n  if (isTls) {\n    lodash_1.defaults(this.options, {\n      tls: true\n    });\n  }\n\n  lodash_1.defaults(this.options, Redis.defaultOptions);\n\n  if (typeof this.options.port === \"string\") {\n    this.options.port = parseInt(this.options.port, 10);\n  }\n\n  if (typeof this.options.db === \"string\") {\n    this.options.db = parseInt(this.options.db, 10);\n  }\n\n  if (this.options.parser === \"hiredis\") {\n    console.warn(\"Hiredis parser is abandoned since ioredis v3.0, and JavaScript parser will be used\");\n  }\n};\n/**\n * Change instance's status\n * @private\n */\n\n\nRedis.prototype.setStatus = function (status, arg) {\n  // @ts-ignore\n  if (debug.enabled) {\n    debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n  }\n\n  this.status = status;\n  process.nextTick(this.emit.bind(this, status, arg));\n};\n/**\n * Create a connection to Redis.\n * This method will be invoked automatically when creating a new Redis instance\n * unless `lazyConnect: true` is passed.\n *\n * When calling this method manually, a Promise is returned, which will\n * be resolved when the connection status is ready.\n * @param {function} [callback]\n * @return {Promise<void>}\n * @public\n */\n\n\nRedis.prototype.connect = function (callback) {\n  var _Promise = PromiseContainer.get();\n\n  var promise = new _Promise((resolve, reject) => {\n    if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n      reject(new Error(\"Redis is already connecting/connected\"));\n      return;\n    }\n\n    this.connectionEpoch += 1;\n    this.setStatus(\"connecting\");\n    const {\n      options\n    } = this;\n    this.condition = {\n      select: options.db,\n      auth: options.password,\n      subscriber: false\n    };\n\n    var _this = this;\n\n    standard_as_callback_1.default(this.connector.connect(function (type, err) {\n      _this.silentEmit(type, err);\n    }), function (err, stream) {\n      if (err) {\n        _this.flushQueue(err);\n\n        _this.silentEmit(\"error\", err);\n\n        reject(err);\n\n        _this.setStatus(\"end\");\n\n        return;\n      }\n\n      var CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n\n      if (options.sentinels && !options.enableTLSForSentinelMode) {\n        CONNECT_EVENT = \"connect\";\n      }\n\n      _this.stream = stream;\n\n      if (typeof options.keepAlive === \"number\") {\n        stream.setKeepAlive(true, options.keepAlive);\n      }\n\n      stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n      stream.once(\"error\", eventHandler.errorHandler(_this));\n      stream.once(\"close\", eventHandler.closeHandler(_this));\n\n      if (options.connectTimeout) {\n        /*\n         * Typically, Socket#setTimeout(0) will clear the timer\n         * set before. However, in some platforms (Electron 3.x~4.x),\n         * the timer will not be cleared. So we introduce a variable here.\n         *\n         * See https://github.com/electron/electron/issues/14915\n         */\n        var connectTimeoutCleared = false;\n        stream.setTimeout(options.connectTimeout, function () {\n          if (connectTimeoutCleared) {\n            return;\n          }\n\n          stream.setTimeout(0);\n          stream.destroy();\n          var err = new Error(\"connect ETIMEDOUT\"); // @ts-ignore\n\n          err.errorno = \"ETIMEDOUT\"; // @ts-ignore\n\n          err.code = \"ETIMEDOUT\"; // @ts-ignore\n\n          err.syscall = \"connect\";\n          eventHandler.errorHandler(_this)(err);\n        });\n        stream.once(CONNECT_EVENT, function () {\n          connectTimeoutCleared = true;\n          stream.setTimeout(0);\n        });\n      }\n\n      if (options.noDelay) {\n        stream.setNoDelay(true);\n      }\n\n      var connectionReadyHandler = function () {\n        _this.removeListener(\"close\", connectionCloseHandler);\n\n        resolve();\n      };\n\n      var connectionCloseHandler = function () {\n        _this.removeListener(\"ready\", connectionReadyHandler);\n\n        reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n      };\n\n      _this.once(\"ready\", connectionReadyHandler);\n\n      _this.once(\"close\", connectionCloseHandler);\n    });\n  });\n  return standard_as_callback_1.default(promise, callback);\n};\n/**\n * Disconnect from Redis.\n *\n * This method closes the connection immediately,\n * and may lose some pending replies that haven't written to client.\n * If you want to wait for the pending replies, use Redis#quit instead.\n * @public\n */\n\n\nRedis.prototype.disconnect = function (reconnect) {\n  if (!reconnect) {\n    this.manuallyClosing = true;\n  }\n\n  if (this.reconnectTimeout) {\n    clearTimeout(this.reconnectTimeout);\n    this.reconnectTimeout = null;\n  }\n\n  if (this.status === \"wait\") {\n    eventHandler.closeHandler(this)();\n  } else {\n    this.connector.disconnect();\n  }\n};\n/**\n * Disconnect from Redis.\n *\n * @deprecated\n */\n\n\nRedis.prototype.end = function () {\n  this.disconnect();\n};\n/**\n * Create a new instance with the same options as the current one.\n *\n * @example\n * ```js\n * var redis = new Redis(6380);\n * var anotherRedis = redis.duplicate();\n * ```\n *\n * @public\n */\n\n\nRedis.prototype.duplicate = function (override) {\n  return new Redis(Object.assign({}, this.options, override || {}));\n};\n\nRedis.prototype.recoverFromFatalError = function (commandError, err, options) {\n  this.flushQueue(err, options);\n  this.silentEmit(\"error\", err);\n  this.disconnect(true);\n};\n\nRedis.prototype.handleReconnection = function handleReconnection(err, item) {\n  var needReconnect = false;\n\n  if (this.options.reconnectOnError) {\n    needReconnect = this.options.reconnectOnError(err);\n  }\n\n  switch (needReconnect) {\n    case 1:\n    case true:\n      if (this.status !== \"reconnecting\") {\n        this.disconnect(true);\n      }\n\n      item.command.reject(err);\n      break;\n\n    case 2:\n      if (this.status !== \"reconnecting\") {\n        this.disconnect(true);\n      }\n\n      if (this.condition.select !== item.select && item.command.name !== \"select\") {\n        this.select(item.select);\n      }\n\n      this.sendCommand(item.command);\n      break;\n\n    default:\n      item.command.reject(err);\n  }\n};\n/**\n * Flush offline queue and command queue with error.\n *\n * @param {Error} error - The error object to send to the commands\n * @param {object} options\n * @private\n */\n\n\nRedis.prototype.flushQueue = function (error, options) {\n  options = lodash_1.defaults({}, options, {\n    offlineQueue: true,\n    commandQueue: true\n  });\n  var item;\n\n  if (options.offlineQueue) {\n    while (this.offlineQueue.length > 0) {\n      item = this.offlineQueue.shift();\n      item.command.reject(error);\n    }\n  }\n\n  if (options.commandQueue) {\n    if (this.commandQueue.length > 0) {\n      if (this.stream) {\n        this.stream.removeAllListeners(\"data\");\n      }\n\n      while (this.commandQueue.length > 0) {\n        item = this.commandQueue.shift();\n        item.command.reject(error);\n      }\n    }\n  }\n};\n/**\n * Check whether Redis has finished loading the persistent data and is able to\n * process commands.\n *\n * @param {Function} callback\n * @private\n */\n\n\nRedis.prototype._readyCheck = function (callback) {\n  var _this = this;\n\n  this.info(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (typeof res !== \"string\") {\n      return callback(null, res);\n    }\n\n    var info = {};\n    var lines = res.split(\"\\r\\n\");\n\n    for (var i = 0; i < lines.length; ++i) {\n      var parts = lines[i].split(\":\");\n\n      if (parts[1]) {\n        info[parts[0]] = parts[1];\n      }\n    }\n\n    if (!info.loading || info.loading === \"0\") {\n      callback(null, info);\n    } else {\n      var loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n      var retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;\n      debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n      setTimeout(function () {\n        _this._readyCheck(callback);\n      }, retryTime);\n    }\n  });\n};\n/**\n * Emit only when there's at least one listener.\n *\n * @param {string} eventName - Event to emit\n * @param {...*} arguments - Arguments\n * @return {boolean} Returns true if event had listeners, false otherwise.\n * @private\n */\n\n\nRedis.prototype.silentEmit = function (eventName) {\n  var error;\n\n  if (eventName === \"error\") {\n    error = arguments[1];\n\n    if (this.status === \"end\") {\n      return;\n    }\n\n    if (this.manuallyClosing) {\n      // ignore connection related errors when manually disconnecting\n      if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || // @ts-ignore\n      error.syscall === \"connect\" || // @ts-ignore\n      error.syscall === \"read\")) {\n        return;\n      }\n    }\n  }\n\n  if (this.listeners(eventName).length > 0) {\n    return this.emit.apply(this, arguments);\n  }\n\n  if (error && error instanceof Error) {\n    console.error(\"[ioredis] Unhandled error event:\", error.stack);\n  }\n\n  return false;\n};\n/**\n * Listen for all requests received by the server in real time.\n *\n * This command will create a new connection to Redis and send a\n * MONITOR command via the new connection in order to avoid disturbing\n * the current connection.\n *\n * @param {function} [callback] The callback function. If omit, a promise will be returned.\n * @example\n * ```js\n * var redis = new Redis();\n * redis.monitor(function (err, monitor) {\n *   // Entering monitoring mode.\n *   monitor.on('monitor', function (time, args, source, database) {\n *     console.log(time + \": \" + util.inspect(args));\n *   });\n * });\n *\n * // supports promise as well as other commands\n * redis.monitor().then(function (monitor) {\n *   monitor.on('monitor', function (time, args, source, database) {\n *     console.log(time + \": \" + util.inspect(args));\n *   });\n * });\n * ```\n * @public\n */\n\n\nRedis.prototype.monitor = function (callback) {\n  var monitorInstance = this.duplicate({\n    monitor: true,\n    lazyConnect: false\n  });\n  var Promise = PromiseContainer.get();\n  return standard_as_callback_1.default(new Promise(function (resolve) {\n    monitorInstance.once(\"monitoring\", function () {\n      resolve(monitorInstance);\n    });\n  }), callback);\n};\n\ntransaction_1.addTransactionSupport(Redis.prototype);\n/**\n * Send a command to Redis\n *\n * This method is used internally by the `Redis#set`, `Redis#lpush` etc.\n * Most of the time you won't invoke this method directly.\n * However when you want to send a command that is not supported by ioredis yet,\n * this command will be useful.\n *\n * @method sendCommand\n * @memberOf Redis#\n * @param {Command} command - The Command instance to send.\n * @see {@link Command}\n * @example\n * ```js\n * var redis = new Redis();\n *\n * // Use callback\n * var get = new Command('get', ['foo'], 'utf8', function (err, result) {\n *   console.log(result);\n * });\n * redis.sendCommand(get);\n *\n * // Use promise\n * var set = new Command('set', ['foo', 'bar'], 'utf8');\n * set.promise.then(function (result) {\n *   console.log(result);\n * });\n * redis.sendCommand(set);\n * ```\n * @private\n */\n\nRedis.prototype.sendCommand = function (command, stream) {\n  if (this.status === \"wait\") {\n    this.connect().catch(lodash_1.noop);\n  }\n\n  if (this.status === \"end\") {\n    command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n    return command.promise;\n  }\n\n  if (this.condition.subscriber && !command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n    command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n    return command.promise;\n  }\n\n  var writable = this.status === \"ready\" || !stream && this.status === \"connect\" && commands.exists(command.name) && commands.hasFlag(command.name, \"loading\");\n\n  if (!this.stream) {\n    writable = false;\n  } else if (!this.stream.writable) {\n    writable = false;\n  } else if (this.stream._writableState && this.stream._writableState.ended) {\n    // https://github.com/iojs/io.js/pull/1217\n    writable = false;\n  }\n\n  if (!writable && !this.options.enableOfflineQueue) {\n    command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n    return command.promise;\n  }\n\n  if (!writable && command.name === \"quit\" && this.offlineQueue.length === 0) {\n    this.disconnect();\n    command.resolve(Buffer.from(\"OK\"));\n    return command.promise;\n  }\n\n  if (writable) {\n    // @ts-ignore\n    if (debug.enabled) {\n      debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n    }\n\n    (stream || this.stream).write(command.toWritable());\n    this.commandQueue.push({\n      command: command,\n      stream: stream,\n      select: this.condition.select\n    });\n\n    if (command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n      this.manuallyClosing = true;\n    }\n  } else if (this.options.enableOfflineQueue) {\n    // @ts-ignore\n    if (debug.enabled) {\n      debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n    }\n\n    this.offlineQueue.push({\n      command: command,\n      stream: stream,\n      select: this.condition.select\n    });\n  }\n\n  if (command.name === \"select\" && utils_1.isInt(command.args[0])) {\n    var db = parseInt(command.args[0], 10);\n\n    if (this.condition.select !== db) {\n      this.condition.select = db;\n      this.emit(\"select\", db);\n      debug(\"switch to db [%d]\", this.condition.select);\n    }\n  }\n\n  return command.promise;\n};\n/**\n * Get description of the connection. Used for debugging.\n * @private\n */\n\n\nRedis.prototype._getDescription = function () {\n  let description;\n\n  if (this.options.path) {\n    description = this.options.path;\n  } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {\n    description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n  } else {\n    description = this.options.host + \":\" + this.options.port;\n  }\n\n  if (this.options.connectionName) {\n    description += ` (${this.options.connectionName})`;\n  }\n\n  return description;\n};\n\n[\"scan\", \"sscan\", \"hscan\", \"zscan\", \"scanBuffer\", \"sscanBuffer\", \"hscanBuffer\", \"zscanBuffer\"].forEach(function (command) {\n  Redis.prototype[command + \"Stream\"] = function (key, options) {\n    if (command === \"scan\" || command === \"scanBuffer\") {\n      options = key;\n      key = null;\n    }\n\n    return new ScanStream_1.default(lodash_1.defaults({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command\n    }, options));\n  };\n});","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/redis/index.js"],"names":["Object","defineProperty","exports","value","lodash_1","require","util_1","events_1","Deque","command_1","commander_1","utils_1","standard_as_callback_1","eventHandler","connectors_1","ScanStream_1","commands","PromiseContainer","transaction_1","RedisOptions_1","debug","Debug","default","Redis","console","error","Error","stack","replace","arguments","parseOptions","EventEmitter","call","resetCommandQueue","resetOfflineQueue","connectionEpoch","options","Connector","connector","sentinels","SentinelConnector","StandaloneConnector","retryAttempts","lazyConnect","setStatus","connect","catch","noop","inherits","assign","prototype","createClient","args","defaultOptions","DEFAULT_REDIS_OPTIONS","commandQueue","offlineQueue","isTls","i","length","arg","defaults","parseURL","startsWith","port","tls","parseInt","db","parser","warn","status","enabled","_getDescription","process","nextTick","emit","bind","callback","_Promise","get","promise","resolve","reject","condition","select","auth","password","subscriber","_this","type","err","silentEmit","stream","flushQueue","CONNECT_EVENT","enableTLSForSentinelMode","keepAlive","setKeepAlive","once","connectHandler","errorHandler","closeHandler","connectTimeout","connectTimeoutCleared","setTimeout","destroy","errorno","code","syscall","noDelay","setNoDelay","connectionReadyHandler","removeListener","connectionCloseHandler","CONNECTION_CLOSED_ERROR_MSG","disconnect","reconnect","manuallyClosing","reconnectTimeout","clearTimeout","end","duplicate","override","recoverFromFatalError","commandError","handleReconnection","item","needReconnect","reconnectOnError","command","name","sendCommand","shift","removeAllListeners","_readyCheck","info","res","lines","split","parts","loading","loadingEtaMs","loading_eta_seconds","retryTime","maxLoadingRetryTime","eventName","message","listeners","apply","monitor","monitorInstance","Promise","addTransactionSupport","checkFlag","writable","exists","hasFlag","_writableState","ended","enableOfflineQueue","Buffer","from","write","toWritable","push","isInt","description","path","remoteAddress","remotePort","host","connectionName","forEach","key","objectMode","redis"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,iBAAD,CAAxB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,QAAD,CAArB;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,YAAD,CAAzB;;AACA,MAAMK,WAAW,GAAGL,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMO,sBAAsB,GAAGP,OAAO,CAAC,sBAAD,CAAtC;;AACA,MAAMQ,YAAY,GAAGR,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAMS,YAAY,GAAGT,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAMU,YAAY,GAAGV,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAMW,QAAQ,GAAGX,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAMY,gBAAgB,GAAGZ,OAAO,CAAC,qBAAD,CAAhC;;AACA,MAAMa,aAAa,GAAGb,OAAO,CAAC,gBAAD,CAA7B;;AACA,MAAMc,cAAc,GAAGd,OAAO,CAAC,gBAAD,CAA9B;;AACA,IAAIe,KAAK,GAAGT,OAAO,CAACU,KAAR,CAAc,OAAd,CAAZ;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8FAnB,OAAO,CAACoB,OAAR,GAAkBC,KAAlB;;AACA,SAASA,KAAT,GAAiB;AACb,MAAI,EAAE,gBAAgBA,KAAlB,CAAJ,EAA8B;AAC1BC,IAAAA,OAAO,CAACC,KAAR,CAAc,IAAIC,KAAJ,CAAU,+EAAV,EAA2FC,KAA3F,CAAiGC,OAAjG,CAAyG,OAAzG,EAAkH,SAAlH,CAAd;AACA,WAAO,IAAIL,KAAJ,CAAUM,SAAS,CAAC,CAAD,CAAnB,EAAwBA,SAAS,CAAC,CAAD,CAAjC,EAAsCA,SAAS,CAAC,CAAD,CAA/C,CAAP;AACH;;AACD,OAAKC,YAAL,CAAkBD,SAAS,CAAC,CAAD,CAA3B,EAAgCA,SAAS,CAAC,CAAD,CAAzC,EAA8CA,SAAS,CAAC,CAAD,CAAvD;AACAtB,EAAAA,QAAQ,CAACwB,YAAT,CAAsBC,IAAtB,CAA2B,IAA3B;AACAtB,EAAAA,WAAW,CAACY,OAAZ,CAAoBU,IAApB,CAAyB,IAAzB;AACA,OAAKC,iBAAL;AACA,OAAKC,iBAAL;AACA,OAAKC,eAAL,GAAuB,CAAvB;;AACA,MAAI,KAAKC,OAAL,CAAaC,SAAjB,EAA4B;AACxB,SAAKC,SAAL,GAAiB,IAAI,KAAKF,OAAL,CAAaC,SAAjB,CAA2B,KAAKD,OAAhC,CAAjB;AACH,GAFD,MAGK,IAAI,KAAKA,OAAL,CAAaG,SAAjB,EAA4B;AAC7B,SAAKD,SAAL,GAAiB,IAAIxB,YAAY,CAAC0B,iBAAjB,CAAmC,KAAKJ,OAAxC,CAAjB;AACH,GAFI,MAGA;AACD,SAAKE,SAAL,GAAiB,IAAIxB,YAAY,CAAC2B,mBAAjB,CAAqC,KAAKL,OAA1C,CAAjB;AACH;;AACD,OAAKM,aAAL,GAAqB,CAArB,CApBa,CAqBb;;AACA,MAAI,KAAKN,OAAL,CAAaO,WAAjB,EAA8B;AAC1B,SAAKC,SAAL,CAAe,MAAf;AACH,GAFD,MAGK;AACD,SAAKC,OAAL,GAAeC,KAAf,CAAqB1C,QAAQ,CAAC2C,IAA9B;AACH;AACJ;;AACDzC,MAAM,CAAC0C,QAAP,CAAgBzB,KAAhB,EAAuBhB,QAAQ,CAACwB,YAAhC;AACA/B,MAAM,CAACiD,MAAP,CAAc1B,KAAK,CAAC2B,SAApB,EAA+BxC,WAAW,CAACY,OAAZ,CAAoB4B,SAAnD;AACA;;;;;AAKA;;AACA3B,KAAK,CAAC4B,YAAN,GAAqB,UAAU,GAAGC,IAAb,EAAmB;AACpC;AACA,SAAO,IAAI7B,KAAJ,CAAU,GAAG6B,IAAb,CAAP;AACH,CAHD;AAIA;;;;;;;;AAMA7B,KAAK,CAAC8B,cAAN,GAAuBlC,cAAc,CAACmC,qBAAtC;;AACA/B,KAAK,CAAC2B,SAAN,CAAgBjB,iBAAhB,GAAoC,YAAY;AAC5C,OAAKsB,YAAL,GAAoB,IAAI/C,KAAJ,EAApB;AACH,CAFD;;AAGAe,KAAK,CAAC2B,SAAN,CAAgBhB,iBAAhB,GAAoC,YAAY;AAC5C,OAAKsB,YAAL,GAAoB,IAAIhD,KAAJ,EAApB;AACH,CAFD;;AAGAe,KAAK,CAAC2B,SAAN,CAAgBpB,YAAhB,GAA+B,YAAY;AACvC,OAAKM,OAAL,GAAe,EAAf;AACA,MAAIqB,KAAK,GAAG,KAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7B,SAAS,CAAC8B,MAA9B,EAAsC,EAAED,CAAxC,EAA2C;AACvC,QAAIE,GAAG,GAAG/B,SAAS,CAAC6B,CAAD,CAAnB;;AACA,QAAIE,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,WAAnC,EAAgD;AAC5C;AACH;;AACD,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AACzBxD,MAAAA,QAAQ,CAACyD,QAAT,CAAkB,KAAKzB,OAAvB,EAAgCwB,GAAhC;AACH,KAFD,MAGK,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC9BxD,MAAAA,QAAQ,CAACyD,QAAT,CAAkB,KAAKzB,OAAvB,EAAgCzB,OAAO,CAACmD,QAAR,CAAiBF,GAAjB,CAAhC;;AACA,UAAIA,GAAG,CAACG,UAAJ,CAAe,WAAf,CAAJ,EAAiC;AAC7BN,QAAAA,KAAK,GAAG,IAAR;AACH;AACJ,KALI,MAMA,IAAI,OAAOG,GAAP,KAAe,QAAnB,EAA6B;AAC9B,WAAKxB,OAAL,CAAa4B,IAAb,GAAoBJ,GAApB;AACH,KAFI,MAGA;AACD,YAAM,IAAIlC,KAAJ,CAAU,sBAAsBkC,GAAhC,CAAN;AACH;AACJ;;AACD,MAAIH,KAAJ,EAAW;AACPrD,IAAAA,QAAQ,CAACyD,QAAT,CAAkB,KAAKzB,OAAvB,EAAgC;AAAE6B,MAAAA,GAAG,EAAE;AAAP,KAAhC;AACH;;AACD7D,EAAAA,QAAQ,CAACyD,QAAT,CAAkB,KAAKzB,OAAvB,EAAgCb,KAAK,CAAC8B,cAAtC;;AACA,MAAI,OAAO,KAAKjB,OAAL,CAAa4B,IAApB,KAA6B,QAAjC,EAA2C;AACvC,SAAK5B,OAAL,CAAa4B,IAAb,GAAoBE,QAAQ,CAAC,KAAK9B,OAAL,CAAa4B,IAAd,EAAoB,EAApB,CAA5B;AACH;;AACD,MAAI,OAAO,KAAK5B,OAAL,CAAa+B,EAApB,KAA2B,QAA/B,EAAyC;AACrC,SAAK/B,OAAL,CAAa+B,EAAb,GAAkBD,QAAQ,CAAC,KAAK9B,OAAL,CAAa+B,EAAd,EAAkB,EAAlB,CAA1B;AACH;;AACD,MAAI,KAAK/B,OAAL,CAAagC,MAAb,KAAwB,SAA5B,EAAuC;AACnC5C,IAAAA,OAAO,CAAC6C,IAAR,CAAa,oFAAb;AACH;AACJ,CArCD;AAsCA;;;;;;AAIA9C,KAAK,CAAC2B,SAAN,CAAgBN,SAAhB,GAA4B,UAAU0B,MAAV,EAAkBV,GAAlB,EAAuB;AAC/C;AACA,MAAIxC,KAAK,CAACmD,OAAV,EAAmB;AACfnD,IAAAA,KAAK,CAAC,sBAAD,EAAyB,KAAKoD,eAAL,EAAzB,EAAiD,KAAKF,MAAL,IAAe,SAAhE,EAA2EA,MAA3E,CAAL;AACH;;AACD,OAAKA,MAAL,GAAcA,MAAd;AACAG,EAAAA,OAAO,CAACC,QAAR,CAAiB,KAAKC,IAAL,CAAUC,IAAV,CAAe,IAAf,EAAqBN,MAArB,EAA6BV,GAA7B,CAAjB;AACH,CAPD;AAQA;;;;;;;;;;;;;AAWArC,KAAK,CAAC2B,SAAN,CAAgBL,OAAhB,GAA0B,UAAUgC,QAAV,EAAoB;AAC1C,MAAIC,QAAQ,GAAG7D,gBAAgB,CAAC8D,GAAjB,EAAf;;AACA,MAAIC,OAAO,GAAG,IAAIF,QAAJ,CAAa,CAACG,OAAD,EAAUC,MAAV,KAAqB;AAC5C,QAAI,KAAKZ,MAAL,KAAgB,YAAhB,IACA,KAAKA,MAAL,KAAgB,SADhB,IAEA,KAAKA,MAAL,KAAgB,OAFpB,EAE6B;AACzBY,MAAAA,MAAM,CAAC,IAAIxD,KAAJ,CAAU,uCAAV,CAAD,CAAN;AACA;AACH;;AACD,SAAKS,eAAL,IAAwB,CAAxB;AACA,SAAKS,SAAL,CAAe,YAAf;AACA,UAAM;AAAER,MAAAA;AAAF,QAAc,IAApB;AACA,SAAK+C,SAAL,GAAiB;AACbC,MAAAA,MAAM,EAAEhD,OAAO,CAAC+B,EADH;AAEbkB,MAAAA,IAAI,EAAEjD,OAAO,CAACkD,QAFD;AAGbC,MAAAA,UAAU,EAAE;AAHC,KAAjB;;AAKA,QAAIC,KAAK,GAAG,IAAZ;;AACA5E,IAAAA,sBAAsB,CAACU,OAAvB,CAA+B,KAAKgB,SAAL,CAAeO,OAAf,CAAuB,UAAU4C,IAAV,EAAgBC,GAAhB,EAAqB;AACvEF,MAAAA,KAAK,CAACG,UAAN,CAAiBF,IAAjB,EAAuBC,GAAvB;AACH,KAF8B,CAA/B,EAEI,UAAUA,GAAV,EAAeE,MAAf,EAAuB;AACvB,UAAIF,GAAJ,EAAS;AACLF,QAAAA,KAAK,CAACK,UAAN,CAAiBH,GAAjB;;AACAF,QAAAA,KAAK,CAACG,UAAN,CAAiB,OAAjB,EAA0BD,GAA1B;;AACAR,QAAAA,MAAM,CAACQ,GAAD,CAAN;;AACAF,QAAAA,KAAK,CAAC5C,SAAN,CAAgB,KAAhB;;AACA;AACH;;AACD,UAAIkD,aAAa,GAAG1D,OAAO,CAAC6B,GAAR,GAAc,eAAd,GAAgC,SAApD;;AACA,UAAI7B,OAAO,CAACG,SAAR,IAAqB,CAACH,OAAO,CAAC2D,wBAAlC,EAA4D;AACxDD,QAAAA,aAAa,GAAG,SAAhB;AACH;;AACDN,MAAAA,KAAK,CAACI,MAAN,GAAeA,MAAf;;AACA,UAAI,OAAOxD,OAAO,CAAC4D,SAAf,KAA6B,QAAjC,EAA2C;AACvCJ,QAAAA,MAAM,CAACK,YAAP,CAAoB,IAApB,EAA0B7D,OAAO,CAAC4D,SAAlC;AACH;;AACDJ,MAAAA,MAAM,CAACM,IAAP,CAAYJ,aAAZ,EAA2BjF,YAAY,CAACsF,cAAb,CAA4BX,KAA5B,CAA3B;AACAI,MAAAA,MAAM,CAACM,IAAP,CAAY,OAAZ,EAAqBrF,YAAY,CAACuF,YAAb,CAA0BZ,KAA1B,CAArB;AACAI,MAAAA,MAAM,CAACM,IAAP,CAAY,OAAZ,EAAqBrF,YAAY,CAACwF,YAAb,CAA0Bb,KAA1B,CAArB;;AACA,UAAIpD,OAAO,CAACkE,cAAZ,EAA4B;AACxB;;;;;;;AAOA,YAAIC,qBAAqB,GAAG,KAA5B;AACAX,QAAAA,MAAM,CAACY,UAAP,CAAkBpE,OAAO,CAACkE,cAA1B,EAA0C,YAAY;AAClD,cAAIC,qBAAJ,EAA2B;AACvB;AACH;;AACDX,UAAAA,MAAM,CAACY,UAAP,CAAkB,CAAlB;AACAZ,UAAAA,MAAM,CAACa,OAAP;AACA,cAAIf,GAAG,GAAG,IAAIhE,KAAJ,CAAU,mBAAV,CAAV,CANkD,CAOlD;;AACAgE,UAAAA,GAAG,CAACgB,OAAJ,GAAc,WAAd,CARkD,CASlD;;AACAhB,UAAAA,GAAG,CAACiB,IAAJ,GAAW,WAAX,CAVkD,CAWlD;;AACAjB,UAAAA,GAAG,CAACkB,OAAJ,GAAc,SAAd;AACA/F,UAAAA,YAAY,CAACuF,YAAb,CAA0BZ,KAA1B,EAAiCE,GAAjC;AACH,SAdD;AAeAE,QAAAA,MAAM,CAACM,IAAP,CAAYJ,aAAZ,EAA2B,YAAY;AACnCS,UAAAA,qBAAqB,GAAG,IAAxB;AACAX,UAAAA,MAAM,CAACY,UAAP,CAAkB,CAAlB;AACH,SAHD;AAIH;;AACD,UAAIpE,OAAO,CAACyE,OAAZ,EAAqB;AACjBjB,QAAAA,MAAM,CAACkB,UAAP,CAAkB,IAAlB;AACH;;AACD,UAAIC,sBAAsB,GAAG,YAAY;AACrCvB,QAAAA,KAAK,CAACwB,cAAN,CAAqB,OAArB,EAA8BC,sBAA9B;;AACAhC,QAAAA,OAAO;AACV,OAHD;;AAIA,UAAIgC,sBAAsB,GAAG,YAAY;AACrCzB,QAAAA,KAAK,CAACwB,cAAN,CAAqB,OAArB,EAA8BD,sBAA9B;;AACA7B,QAAAA,MAAM,CAAC,IAAIxD,KAAJ,CAAUf,OAAO,CAACuG,2BAAlB,CAAD,CAAN;AACH,OAHD;;AAIA1B,MAAAA,KAAK,CAACU,IAAN,CAAW,OAAX,EAAoBa,sBAApB;;AACAvB,MAAAA,KAAK,CAACU,IAAN,CAAW,OAAX,EAAoBe,sBAApB;AACH,KA/DD;AAgEH,GAhFa,CAAd;AAiFA,SAAOrG,sBAAsB,CAACU,OAAvB,CAA+B0D,OAA/B,EAAwCH,QAAxC,CAAP;AACH,CApFD;AAqFA;;;;;;;;;;AAQAtD,KAAK,CAAC2B,SAAN,CAAgBiE,UAAhB,GAA6B,UAAUC,SAAV,EAAqB;AAC9C,MAAI,CAACA,SAAL,EAAgB;AACZ,SAAKC,eAAL,GAAuB,IAAvB;AACH;;AACD,MAAI,KAAKC,gBAAT,EAA2B;AACvBC,IAAAA,YAAY,CAAC,KAAKD,gBAAN,CAAZ;AACA,SAAKA,gBAAL,GAAwB,IAAxB;AACH;;AACD,MAAI,KAAKhD,MAAL,KAAgB,MAApB,EAA4B;AACxBzD,IAAAA,YAAY,CAACwF,YAAb,CAA0B,IAA1B;AACH,GAFD,MAGK;AACD,SAAK/D,SAAL,CAAe6E,UAAf;AACH;AACJ,CAdD;AAeA;;;;;;;AAKA5F,KAAK,CAAC2B,SAAN,CAAgBsE,GAAhB,GAAsB,YAAY;AAC9B,OAAKL,UAAL;AACH,CAFD;AAGA;;;;;;;;;;;;;AAWA5F,KAAK,CAAC2B,SAAN,CAAgBuE,SAAhB,GAA4B,UAAUC,QAAV,EAAoB;AAC5C,SAAO,IAAInG,KAAJ,CAAUvB,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkB,KAAKb,OAAvB,EAAgCsF,QAAQ,IAAI,EAA5C,CAAV,CAAP;AACH,CAFD;;AAGAnG,KAAK,CAAC2B,SAAN,CAAgByE,qBAAhB,GAAwC,UAAUC,YAAV,EAAwBlC,GAAxB,EAA6BtD,OAA7B,EAAsC;AAC1E,OAAKyD,UAAL,CAAgBH,GAAhB,EAAqBtD,OAArB;AACA,OAAKuD,UAAL,CAAgB,OAAhB,EAAyBD,GAAzB;AACA,OAAKyB,UAAL,CAAgB,IAAhB;AACH,CAJD;;AAKA5F,KAAK,CAAC2B,SAAN,CAAgB2E,kBAAhB,GAAqC,SAASA,kBAAT,CAA4BnC,GAA5B,EAAiCoC,IAAjC,EAAuC;AACxE,MAAIC,aAAa,GAAG,KAApB;;AACA,MAAI,KAAK3F,OAAL,CAAa4F,gBAAjB,EAAmC;AAC/BD,IAAAA,aAAa,GAAG,KAAK3F,OAAL,CAAa4F,gBAAb,CAA8BtC,GAA9B,CAAhB;AACH;;AACD,UAAQqC,aAAR;AACI,SAAK,CAAL;AACA,SAAK,IAAL;AACI,UAAI,KAAKzD,MAAL,KAAgB,cAApB,EAAoC;AAChC,aAAK6C,UAAL,CAAgB,IAAhB;AACH;;AACDW,MAAAA,IAAI,CAACG,OAAL,CAAa/C,MAAb,CAAoBQ,GAApB;AACA;;AACJ,SAAK,CAAL;AACI,UAAI,KAAKpB,MAAL,KAAgB,cAApB,EAAoC;AAChC,aAAK6C,UAAL,CAAgB,IAAhB;AACH;;AACD,UAAI,KAAKhC,SAAL,CAAeC,MAAf,KAA0B0C,IAAI,CAAC1C,MAA/B,IACA0C,IAAI,CAACG,OAAL,CAAaC,IAAb,KAAsB,QAD1B,EACoC;AAChC,aAAK9C,MAAL,CAAY0C,IAAI,CAAC1C,MAAjB;AACH;;AACD,WAAK+C,WAAL,CAAiBL,IAAI,CAACG,OAAtB;AACA;;AACJ;AACIH,MAAAA,IAAI,CAACG,OAAL,CAAa/C,MAAb,CAAoBQ,GAApB;AAnBR;AAqBH,CA1BD;AA2BA;;;;;;;;;AAOAnE,KAAK,CAAC2B,SAAN,CAAgB2C,UAAhB,GAA6B,UAAUpE,KAAV,EAAiBW,OAAjB,EAA0B;AACnDA,EAAAA,OAAO,GAAGhC,QAAQ,CAACyD,QAAT,CAAkB,EAAlB,EAAsBzB,OAAtB,EAA+B;AACrCoB,IAAAA,YAAY,EAAE,IADuB;AAErCD,IAAAA,YAAY,EAAE;AAFuB,GAA/B,CAAV;AAIA,MAAIuE,IAAJ;;AACA,MAAI1F,OAAO,CAACoB,YAAZ,EAA0B;AACtB,WAAO,KAAKA,YAAL,CAAkBG,MAAlB,GAA2B,CAAlC,EAAqC;AACjCmE,MAAAA,IAAI,GAAG,KAAKtE,YAAL,CAAkB4E,KAAlB,EAAP;AACAN,MAAAA,IAAI,CAACG,OAAL,CAAa/C,MAAb,CAAoBzD,KAApB;AACH;AACJ;;AACD,MAAIW,OAAO,CAACmB,YAAZ,EAA0B;AACtB,QAAI,KAAKA,YAAL,CAAkBI,MAAlB,GAA2B,CAA/B,EAAkC;AAC9B,UAAI,KAAKiC,MAAT,EAAiB;AACb,aAAKA,MAAL,CAAYyC,kBAAZ,CAA+B,MAA/B;AACH;;AACD,aAAO,KAAK9E,YAAL,CAAkBI,MAAlB,GAA2B,CAAlC,EAAqC;AACjCmE,QAAAA,IAAI,GAAG,KAAKvE,YAAL,CAAkB6E,KAAlB,EAAP;AACAN,QAAAA,IAAI,CAACG,OAAL,CAAa/C,MAAb,CAAoBzD,KAApB;AACH;AACJ;AACJ;AACJ,CAvBD;AAwBA;;;;;;;;;AAOAF,KAAK,CAAC2B,SAAN,CAAgBoF,WAAhB,GAA8B,UAAUzD,QAAV,EAAoB;AAC9C,MAAIW,KAAK,GAAG,IAAZ;;AACA,OAAK+C,IAAL,CAAU,UAAU7C,GAAV,EAAe8C,GAAf,EAAoB;AAC1B,QAAI9C,GAAJ,EAAS;AACL,aAAOb,QAAQ,CAACa,GAAD,CAAf;AACH;;AACD,QAAI,OAAO8C,GAAP,KAAe,QAAnB,EAA6B;AACzB,aAAO3D,QAAQ,CAAC,IAAD,EAAO2D,GAAP,CAAf;AACH;;AACD,QAAID,IAAI,GAAG,EAAX;AACA,QAAIE,KAAK,GAAGD,GAAG,CAACE,KAAJ,CAAU,MAAV,CAAZ;;AACA,SAAK,IAAIhF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+E,KAAK,CAAC9E,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,UAAIiF,KAAK,GAAGF,KAAK,CAAC/E,CAAD,CAAL,CAASgF,KAAT,CAAe,GAAf,CAAZ;;AACA,UAAIC,KAAK,CAAC,CAAD,CAAT,EAAc;AACVJ,QAAAA,IAAI,CAACI,KAAK,CAAC,CAAD,CAAN,CAAJ,GAAiBA,KAAK,CAAC,CAAD,CAAtB;AACH;AACJ;;AACD,QAAI,CAACJ,IAAI,CAACK,OAAN,IAAiBL,IAAI,CAACK,OAAL,KAAiB,GAAtC,EAA2C;AACvC/D,MAAAA,QAAQ,CAAC,IAAD,EAAO0D,IAAP,CAAR;AACH,KAFD,MAGK;AACD,UAAIM,YAAY,GAAG,CAACN,IAAI,CAACO,mBAAL,IAA4B,CAA7B,IAAkC,IAArD;AACA,UAAIC,SAAS,GAAGvD,KAAK,CAACpD,OAAN,CAAc4G,mBAAd,IACZxD,KAAK,CAACpD,OAAN,CAAc4G,mBAAd,GAAoCH,YADxB,GAEVrD,KAAK,CAACpD,OAAN,CAAc4G,mBAFJ,GAGVH,YAHN;AAIAzH,MAAAA,KAAK,CAAC,iDAAiD2H,SAAjD,GAA6D,IAA9D,CAAL;AACAvC,MAAAA,UAAU,CAAC,YAAY;AACnBhB,QAAAA,KAAK,CAAC8C,WAAN,CAAkBzD,QAAlB;AACH,OAFS,EAEPkE,SAFO,CAAV;AAGH;AACJ,GA7BD;AA8BH,CAhCD;AAiCA;;;;;;;;;;AAQAxH,KAAK,CAAC2B,SAAN,CAAgByC,UAAhB,GAA6B,UAAUsD,SAAV,EAAqB;AAC9C,MAAIxH,KAAJ;;AACA,MAAIwH,SAAS,KAAK,OAAlB,EAA2B;AACvBxH,IAAAA,KAAK,GAAGI,SAAS,CAAC,CAAD,CAAjB;;AACA,QAAI,KAAKyC,MAAL,KAAgB,KAApB,EAA2B;AACvB;AACH;;AACD,QAAI,KAAK+C,eAAT,EAA0B;AACtB;AACA,UAAI5F,KAAK,YAAYC,KAAjB,KACCD,KAAK,CAACyH,OAAN,KAAkBvI,OAAO,CAACuG,2BAA1B,IACG;AACAzF,MAAAA,KAAK,CAACmF,OAAN,KAAkB,SAFrB,IAGG;AACAnF,MAAAA,KAAK,CAACmF,OAAN,KAAkB,MALtB,CAAJ,EAKmC;AAC/B;AACH;AACJ;AACJ;;AACD,MAAI,KAAKuC,SAAL,CAAeF,SAAf,EAA0BtF,MAA1B,GAAmC,CAAvC,EAA0C;AACtC,WAAO,KAAKgB,IAAL,CAAUyE,KAAV,CAAgB,IAAhB,EAAsBvH,SAAtB,CAAP;AACH;;AACD,MAAIJ,KAAK,IAAIA,KAAK,YAAYC,KAA9B,EAAqC;AACjCF,IAAAA,OAAO,CAACC,KAAR,CAAc,kCAAd,EAAkDA,KAAK,CAACE,KAAxD;AACH;;AACD,SAAO,KAAP;AACH,CA1BD;AA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BAJ,KAAK,CAAC2B,SAAN,CAAgBmG,OAAhB,GAA0B,UAAUxE,QAAV,EAAoB;AAC1C,MAAIyE,eAAe,GAAG,KAAK7B,SAAL,CAAe;AACjC4B,IAAAA,OAAO,EAAE,IADwB;AAEjC1G,IAAAA,WAAW,EAAE;AAFoB,GAAf,CAAtB;AAIA,MAAI4G,OAAO,GAAGtI,gBAAgB,CAAC8D,GAAjB,EAAd;AACA,SAAOnE,sBAAsB,CAACU,OAAvB,CAA+B,IAAIiI,OAAJ,CAAY,UAAUtE,OAAV,EAAmB;AACjEqE,IAAAA,eAAe,CAACpD,IAAhB,CAAqB,YAArB,EAAmC,YAAY;AAC3CjB,MAAAA,OAAO,CAACqE,eAAD,CAAP;AACH,KAFD;AAGH,GAJqC,CAA/B,EAIHzE,QAJG,CAAP;AAKH,CAXD;;AAYA3D,aAAa,CAACsI,qBAAd,CAAoCjI,KAAK,CAAC2B,SAA1C;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA3B,KAAK,CAAC2B,SAAN,CAAgBiF,WAAhB,GAA8B,UAAUF,OAAV,EAAmBrC,MAAnB,EAA2B;AACrD,MAAI,KAAKtB,MAAL,KAAgB,MAApB,EAA4B;AACxB,SAAKzB,OAAL,GAAeC,KAAf,CAAqB1C,QAAQ,CAAC2C,IAA9B;AACH;;AACD,MAAI,KAAKuB,MAAL,KAAgB,KAApB,EAA2B;AACvB2D,IAAAA,OAAO,CAAC/C,MAAR,CAAe,IAAIxD,KAAJ,CAAUf,OAAO,CAACuG,2BAAlB,CAAf;AACA,WAAOe,OAAO,CAACjD,OAAf;AACH;;AACD,MAAI,KAAKG,SAAL,CAAeI,UAAf,IACA,CAAC9E,SAAS,CAACa,OAAV,CAAkBmI,SAAlB,CAA4B,0BAA5B,EAAwDxB,OAAO,CAACC,IAAhE,CADL,EAC4E;AACxED,IAAAA,OAAO,CAAC/C,MAAR,CAAe,IAAIxD,KAAJ,CAAU,qEAAV,CAAf;AACA,WAAOuG,OAAO,CAACjD,OAAf;AACH;;AACD,MAAI0E,QAAQ,GAAG,KAAKpF,MAAL,KAAgB,OAAhB,IACV,CAACsB,MAAD,IACG,KAAKtB,MAAL,KAAgB,SADnB,IAEGtD,QAAQ,CAAC2I,MAAT,CAAgB1B,OAAO,CAACC,IAAxB,CAFH,IAGGlH,QAAQ,CAAC4I,OAAT,CAAiB3B,OAAO,CAACC,IAAzB,EAA+B,SAA/B,CAJR;;AAKA,MAAI,CAAC,KAAKtC,MAAV,EAAkB;AACd8D,IAAAA,QAAQ,GAAG,KAAX;AACH,GAFD,MAGK,IAAI,CAAC,KAAK9D,MAAL,CAAY8D,QAAjB,EAA2B;AAC5BA,IAAAA,QAAQ,GAAG,KAAX;AACH,GAFI,MAGA,IAAI,KAAK9D,MAAL,CAAYiE,cAAZ,IAA8B,KAAKjE,MAAL,CAAYiE,cAAZ,CAA2BC,KAA7D,EAAoE;AACrE;AACAJ,IAAAA,QAAQ,GAAG,KAAX;AACH;;AACD,MAAI,CAACA,QAAD,IAAa,CAAC,KAAKtH,OAAL,CAAa2H,kBAA/B,EAAmD;AAC/C9B,IAAAA,OAAO,CAAC/C,MAAR,CAAe,IAAIxD,KAAJ,CAAU,gEAAV,CAAf;AACA,WAAOuG,OAAO,CAACjD,OAAf;AACH;;AACD,MAAI,CAAC0E,QAAD,IAAazB,OAAO,CAACC,IAAR,KAAiB,MAA9B,IAAwC,KAAK1E,YAAL,CAAkBG,MAAlB,KAA6B,CAAzE,EAA4E;AACxE,SAAKwD,UAAL;AACAc,IAAAA,OAAO,CAAChD,OAAR,CAAgB+E,MAAM,CAACC,IAAP,CAAY,IAAZ,CAAhB;AACA,WAAOhC,OAAO,CAACjD,OAAf;AACH;;AACD,MAAI0E,QAAJ,EAAc;AACV;AACA,QAAItI,KAAK,CAACmD,OAAV,EAAmB;AACfnD,MAAAA,KAAK,CAAC,iCAAD,EAAoC,KAAKoD,eAAL,EAApC,EAA4D,KAAKW,SAAL,CAAeC,MAA3E,EAAmF6C,OAAO,CAACC,IAA3F,EAAiGD,OAAO,CAAC7E,IAAzG,CAAL;AACH;;AACD,KAACwC,MAAM,IAAI,KAAKA,MAAhB,EAAwBsE,KAAxB,CAA8BjC,OAAO,CAACkC,UAAR,EAA9B;AACA,SAAK5G,YAAL,CAAkB6G,IAAlB,CAAuB;AACnBnC,MAAAA,OAAO,EAAEA,OADU;AAEnBrC,MAAAA,MAAM,EAAEA,MAFW;AAGnBR,MAAAA,MAAM,EAAE,KAAKD,SAAL,CAAeC;AAHJ,KAAvB;;AAKA,QAAI3E,SAAS,CAACa,OAAV,CAAkBmI,SAAlB,CAA4B,iBAA5B,EAA+CxB,OAAO,CAACC,IAAvD,CAAJ,EAAkE;AAC9D,WAAKb,eAAL,GAAuB,IAAvB;AACH;AACJ,GAdD,MAeK,IAAI,KAAKjF,OAAL,CAAa2H,kBAAjB,EAAqC;AACtC;AACA,QAAI3I,KAAK,CAACmD,OAAV,EAAmB;AACfnD,MAAAA,KAAK,CAAC,iCAAD,EAAoC,KAAKoD,eAAL,EAApC,EAA4D,KAAKW,SAAL,CAAeC,MAA3E,EAAmF6C,OAAO,CAACC,IAA3F,EAAiGD,OAAO,CAAC7E,IAAzG,CAAL;AACH;;AACD,SAAKI,YAAL,CAAkB4G,IAAlB,CAAuB;AACnBnC,MAAAA,OAAO,EAAEA,OADU;AAEnBrC,MAAAA,MAAM,EAAEA,MAFW;AAGnBR,MAAAA,MAAM,EAAE,KAAKD,SAAL,CAAeC;AAHJ,KAAvB;AAKH;;AACD,MAAI6C,OAAO,CAACC,IAAR,KAAiB,QAAjB,IAA6BvH,OAAO,CAAC0J,KAAR,CAAcpC,OAAO,CAAC7E,IAAR,CAAa,CAAb,CAAd,CAAjC,EAAiE;AAC7D,QAAIe,EAAE,GAAGD,QAAQ,CAAC+D,OAAO,CAAC7E,IAAR,CAAa,CAAb,CAAD,EAAkB,EAAlB,CAAjB;;AACA,QAAI,KAAK+B,SAAL,CAAeC,MAAf,KAA0BjB,EAA9B,EAAkC;AAC9B,WAAKgB,SAAL,CAAeC,MAAf,GAAwBjB,EAAxB;AACA,WAAKQ,IAAL,CAAU,QAAV,EAAoBR,EAApB;AACA/C,MAAAA,KAAK,CAAC,mBAAD,EAAsB,KAAK+D,SAAL,CAAeC,MAArC,CAAL;AACH;AACJ;;AACD,SAAO6C,OAAO,CAACjD,OAAf;AACH,CAxED;AAyEA;;;;;;AAIAzD,KAAK,CAAC2B,SAAN,CAAgBsB,eAAhB,GAAkC,YAAY;AAC1C,MAAI8F,WAAJ;;AACA,MAAI,KAAKlI,OAAL,CAAamI,IAAjB,EAAuB;AACnBD,IAAAA,WAAW,GAAG,KAAKlI,OAAL,CAAamI,IAA3B;AACH,GAFD,MAGK,IAAI,KAAK3E,MAAL,IACL,KAAKA,MAAL,CAAY4E,aADP,IAEL,KAAK5E,MAAL,CAAY6E,UAFX,EAEuB;AACxBH,IAAAA,WAAW,GAAG,KAAK1E,MAAL,CAAY4E,aAAZ,GAA4B,GAA5B,GAAkC,KAAK5E,MAAL,CAAY6E,UAA5D;AACH,GAJI,MAKA;AACDH,IAAAA,WAAW,GAAG,KAAKlI,OAAL,CAAasI,IAAb,GAAoB,GAApB,GAA0B,KAAKtI,OAAL,CAAa4B,IAArD;AACH;;AACD,MAAI,KAAK5B,OAAL,CAAauI,cAAjB,EAAiC;AAC7BL,IAAAA,WAAW,IAAK,KAAI,KAAKlI,OAAL,CAAauI,cAAe,GAAhD;AACH;;AACD,SAAOL,WAAP;AACH,CAjBD;;AAkBA,CACI,MADJ,EAEI,OAFJ,EAGI,OAHJ,EAII,OAJJ,EAKI,YALJ,EAMI,aANJ,EAOI,aAPJ,EAQI,aARJ,EASEM,OATF,CASU,UAAU3C,OAAV,EAAmB;AACzB1G,EAAAA,KAAK,CAAC2B,SAAN,CAAgB+E,OAAO,GAAG,QAA1B,IAAsC,UAAU4C,GAAV,EAAezI,OAAf,EAAwB;AAC1D,QAAI6F,OAAO,KAAK,MAAZ,IAAsBA,OAAO,KAAK,YAAtC,EAAoD;AAChD7F,MAAAA,OAAO,GAAGyI,GAAV;AACAA,MAAAA,GAAG,GAAG,IAAN;AACH;;AACD,WAAO,IAAI9J,YAAY,CAACO,OAAjB,CAAyBlB,QAAQ,CAACyD,QAAT,CAAkB;AAC9CiH,MAAAA,UAAU,EAAE,IADkC;AAE9CD,MAAAA,GAAG,EAAEA,GAFyC;AAG9CE,MAAAA,KAAK,EAAE,IAHuC;AAI9C9C,MAAAA,OAAO,EAAEA;AAJqC,KAAlB,EAK7B7F,OAL6B,CAAzB,CAAP;AAMH,GAXD;AAYH,CAtBD","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = require(\"../utils/lodash\");\nconst util_1 = require(\"util\");\nconst events_1 = require(\"events\");\nconst Deque = require(\"denque\");\nconst command_1 = require(\"../command\");\nconst commander_1 = require(\"../commander\");\nconst utils_1 = require(\"../utils\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst eventHandler = require(\"./event_handler\");\nconst connectors_1 = require(\"../connectors\");\nconst ScanStream_1 = require(\"../ScanStream\");\nconst commands = require(\"redis-commands\");\nconst PromiseContainer = require(\"../promiseContainer\");\nconst transaction_1 = require(\"../transaction\");\nconst RedisOptions_1 = require(\"./RedisOptions\");\nvar debug = utils_1.Debug(\"redis\");\n/**\n * Creates a Redis instance\n *\n * @constructor\n * @param {(number|string|Object)} [port=6379] - Port of the Redis server,\n * or a URL string(see the examples below),\n * or the `options` object(see the third argument).\n * @param {string|Object} [host=localhost] - Host of the Redis server,\n * when the first argument is a URL string,\n * this argument is an object represents the options.\n * @param {Object} [options] - Other options.\n * @param {number} [options.port=6379] - Port of the Redis server.\n * @param {string} [options.host=localhost] - Host of the Redis server.\n * @param {string} [options.family=4] - Version of IP stack. Defaults to 4.\n * @param {string} [options.path=null] - Local domain socket path. If set the `port`,\n * `host` and `family` will be ignored.\n * @param {number} [options.keepAlive=0] - TCP KeepAlive on the socket with a X ms delay before start.\n * Set to a non-number value to disable keepAlive.\n * @param {boolean} [options.noDelay=true] - Whether to disable the Nagle's Algorithm. By default we disable\n * it to reduce the latency.\n * @param {string} [options.connectionName=null] - Connection name.\n * @param {number} [options.db=0] - Database index to use.\n * @param {string} [options.password=null] - If set, client will send AUTH command\n * with the value of this option when connected.\n * @param {boolean} [options.dropBufferSupport=false] - Drop the buffer support for better performance.\n * This option is recommended to be enabled when\n * handling large array response and you don't need the buffer support.\n * @param {boolean} [options.enableReadyCheck=true] - When a connection is established to\n * the Redis server, the server might still be loading the database from disk.\n * While loading, the server not respond to any commands.\n * To work around this, when this option is `true`,\n * ioredis will check the status of the Redis server,\n * and when the Redis server is able to process commands,\n * a `ready` event will be emitted.\n * @param {boolean} [options.enableOfflineQueue=true] - By default,\n * if there is no active connection to the Redis server,\n * commands are added to a queue and are executed once the connection is \"ready\"\n * (when `enableReadyCheck` is `true`,\n * \"ready\" means the Redis server has loaded the database from disk, otherwise means the connection\n * to the Redis server has been established). If this option is false,\n * when execute the command when the connection isn't ready, an error will be returned.\n * @param {number} [options.connectTimeout=10000] - The milliseconds before a timeout occurs during the initial\n * connection to the Redis server.\n * @param {boolean} [options.autoResubscribe=true] - After reconnected, if the previous connection was in the\n * subscriber mode, client will auto re-subscribe these channels.\n * @param {boolean} [options.autoResendUnfulfilledCommands=true] - If true, client will resend unfulfilled\n * commands(e.g. block commands) in the previous connection when reconnected.\n * @param {boolean} [options.lazyConnect=false] - By default,\n * When a new `Redis` instance is created, it will connect to Redis server automatically.\n * If you want to keep the instance disconnected until a command is called, you can pass the `lazyConnect` option to\n * the constructor:\n *\n * ```javascript\n * var redis = new Redis({ lazyConnect: true });\n * // No attempting to connect to the Redis server here.\n\n * // Now let's connect to the Redis server\n * redis.get('foo', function () {\n * });\n * ```\n * @param {Object} [options.tls] - TLS connection support. See https://github.com/luin/ioredis#tls-options\n * @param {string} [options.keyPrefix=''] - The prefix to prepend to all keys in a command.\n * @param {function} [options.retryStrategy] - See \"Quick Start\" section\n * @param {number} [options.maxRetriesPerRequest] - See \"Quick Start\" section\n * @param {number} [options.maxLoadingRetryTime=10000] - when redis server is not ready, we will wait for\n * `loading_eta_seconds` from `info` command or maxLoadingRetryTime (milliseconds), whichever is smaller.\n * @param {function} [options.reconnectOnError] - See \"Quick Start\" section\n * @param {boolean} [options.readOnly=false] - Enable READONLY mode for the connection.\n * Only available for cluster mode.\n * @param {boolean} [options.stringNumbers=false] - Force numbers to be always returned as JavaScript\n * strings. This option is necessary when dealing with big numbers (exceed the [-2^53, +2^53] range).\n * @param {boolean} [options.enableTLSForSentinelMode=false] - Whether to support the `tls` option\n * when connecting to Redis via sentinel mode.\n * @param {NatMap} [options.natMap=null] NAT map for sentinel connector.\n * @param {boolean} [options.updateSentinels=true] - Update the given `sentinels` list with new IP\n * addresses when communicating with existing sentinels.\n * @extends [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)\n * @extends Commander\n * @example\n * ```js\n * var Redis = require('ioredis');\n *\n * var redis = new Redis();\n *\n * var redisOnPort6380 = new Redis(6380);\n * var anotherRedis = new Redis(6380, '192.168.100.1');\n * var unixSocketRedis = new Redis({ path: '/tmp/echo.sock' });\n * var unixSocketRedis2 = new Redis('/tmp/echo.sock');\n * var urlRedis = new Redis('redis://user:password@redis-service.com:6379/');\n * var urlRedis2 = new Redis('//localhost:6379');\n * var urlRedisTls = new Redis('rediss://user:password@redis-service.com:6379/');\n * var authedRedis = new Redis(6380, '192.168.100.1', { password: 'password' });\n * ```\n */\nexports.default = Redis;\nfunction Redis() {\n    if (!(this instanceof Redis)) {\n        console.error(new Error(\"Calling `Redis()` like a function is deprecated. Using `new Redis()` instead.\").stack.replace(\"Error\", \"Warning\"));\n        return new Redis(arguments[0], arguments[1], arguments[2]);\n    }\n    this.parseOptions(arguments[0], arguments[1], arguments[2]);\n    events_1.EventEmitter.call(this);\n    commander_1.default.call(this);\n    this.resetCommandQueue();\n    this.resetOfflineQueue();\n    this.connectionEpoch = 0;\n    if (this.options.Connector) {\n        this.connector = new this.options.Connector(this.options);\n    }\n    else if (this.options.sentinels) {\n        this.connector = new connectors_1.SentinelConnector(this.options);\n    }\n    else {\n        this.connector = new connectors_1.StandaloneConnector(this.options);\n    }\n    this.retryAttempts = 0;\n    // end(or wait) -> connecting -> connect -> ready -> end\n    if (this.options.lazyConnect) {\n        this.setStatus(\"wait\");\n    }\n    else {\n        this.connect().catch(lodash_1.noop);\n    }\n}\nutil_1.inherits(Redis, events_1.EventEmitter);\nObject.assign(Redis.prototype, commander_1.default.prototype);\n/**\n * Create a Redis instance\n *\n * @deprecated\n */\n// @ts-ignore\nRedis.createClient = function (...args) {\n    // @ts-ignore\n    return new Redis(...args);\n};\n/**\n * Default options\n *\n * @var defaultOptions\n * @private\n */\nRedis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\nRedis.prototype.resetCommandQueue = function () {\n    this.commandQueue = new Deque();\n};\nRedis.prototype.resetOfflineQueue = function () {\n    this.offlineQueue = new Deque();\n};\nRedis.prototype.parseOptions = function () {\n    this.options = {};\n    let isTls = false;\n    for (var i = 0; i < arguments.length; ++i) {\n        var arg = arguments[i];\n        if (arg === null || typeof arg === \"undefined\") {\n            continue;\n        }\n        if (typeof arg === \"object\") {\n            lodash_1.defaults(this.options, arg);\n        }\n        else if (typeof arg === \"string\") {\n            lodash_1.defaults(this.options, utils_1.parseURL(arg));\n            if (arg.startsWith(\"rediss://\")) {\n                isTls = true;\n            }\n        }\n        else if (typeof arg === \"number\") {\n            this.options.port = arg;\n        }\n        else {\n            throw new Error(\"Invalid argument \" + arg);\n        }\n    }\n    if (isTls) {\n        lodash_1.defaults(this.options, { tls: true });\n    }\n    lodash_1.defaults(this.options, Redis.defaultOptions);\n    if (typeof this.options.port === \"string\") {\n        this.options.port = parseInt(this.options.port, 10);\n    }\n    if (typeof this.options.db === \"string\") {\n        this.options.db = parseInt(this.options.db, 10);\n    }\n    if (this.options.parser === \"hiredis\") {\n        console.warn(\"Hiredis parser is abandoned since ioredis v3.0, and JavaScript parser will be used\");\n    }\n};\n/**\n * Change instance's status\n * @private\n */\nRedis.prototype.setStatus = function (status, arg) {\n    // @ts-ignore\n    if (debug.enabled) {\n        debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n    }\n    this.status = status;\n    process.nextTick(this.emit.bind(this, status, arg));\n};\n/**\n * Create a connection to Redis.\n * This method will be invoked automatically when creating a new Redis instance\n * unless `lazyConnect: true` is passed.\n *\n * When calling this method manually, a Promise is returned, which will\n * be resolved when the connection status is ready.\n * @param {function} [callback]\n * @return {Promise<void>}\n * @public\n */\nRedis.prototype.connect = function (callback) {\n    var _Promise = PromiseContainer.get();\n    var promise = new _Promise((resolve, reject) => {\n        if (this.status === \"connecting\" ||\n            this.status === \"connect\" ||\n            this.status === \"ready\") {\n            reject(new Error(\"Redis is already connecting/connected\"));\n            return;\n        }\n        this.connectionEpoch += 1;\n        this.setStatus(\"connecting\");\n        const { options } = this;\n        this.condition = {\n            select: options.db,\n            auth: options.password,\n            subscriber: false\n        };\n        var _this = this;\n        standard_as_callback_1.default(this.connector.connect(function (type, err) {\n            _this.silentEmit(type, err);\n        }), function (err, stream) {\n            if (err) {\n                _this.flushQueue(err);\n                _this.silentEmit(\"error\", err);\n                reject(err);\n                _this.setStatus(\"end\");\n                return;\n            }\n            var CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n            if (options.sentinels && !options.enableTLSForSentinelMode) {\n                CONNECT_EVENT = \"connect\";\n            }\n            _this.stream = stream;\n            if (typeof options.keepAlive === \"number\") {\n                stream.setKeepAlive(true, options.keepAlive);\n            }\n            stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n            stream.once(\"error\", eventHandler.errorHandler(_this));\n            stream.once(\"close\", eventHandler.closeHandler(_this));\n            if (options.connectTimeout) {\n                /*\n                 * Typically, Socket#setTimeout(0) will clear the timer\n                 * set before. However, in some platforms (Electron 3.x~4.x),\n                 * the timer will not be cleared. So we introduce a variable here.\n                 *\n                 * See https://github.com/electron/electron/issues/14915\n                 */\n                var connectTimeoutCleared = false;\n                stream.setTimeout(options.connectTimeout, function () {\n                    if (connectTimeoutCleared) {\n                        return;\n                    }\n                    stream.setTimeout(0);\n                    stream.destroy();\n                    var err = new Error(\"connect ETIMEDOUT\");\n                    // @ts-ignore\n                    err.errorno = \"ETIMEDOUT\";\n                    // @ts-ignore\n                    err.code = \"ETIMEDOUT\";\n                    // @ts-ignore\n                    err.syscall = \"connect\";\n                    eventHandler.errorHandler(_this)(err);\n                });\n                stream.once(CONNECT_EVENT, function () {\n                    connectTimeoutCleared = true;\n                    stream.setTimeout(0);\n                });\n            }\n            if (options.noDelay) {\n                stream.setNoDelay(true);\n            }\n            var connectionReadyHandler = function () {\n                _this.removeListener(\"close\", connectionCloseHandler);\n                resolve();\n            };\n            var connectionCloseHandler = function () {\n                _this.removeListener(\"ready\", connectionReadyHandler);\n                reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            };\n            _this.once(\"ready\", connectionReadyHandler);\n            _this.once(\"close\", connectionCloseHandler);\n        });\n    });\n    return standard_as_callback_1.default(promise, callback);\n};\n/**\n * Disconnect from Redis.\n *\n * This method closes the connection immediately,\n * and may lose some pending replies that haven't written to client.\n * If you want to wait for the pending replies, use Redis#quit instead.\n * @public\n */\nRedis.prototype.disconnect = function (reconnect) {\n    if (!reconnect) {\n        this.manuallyClosing = true;\n    }\n    if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n    }\n    if (this.status === \"wait\") {\n        eventHandler.closeHandler(this)();\n    }\n    else {\n        this.connector.disconnect();\n    }\n};\n/**\n * Disconnect from Redis.\n *\n * @deprecated\n */\nRedis.prototype.end = function () {\n    this.disconnect();\n};\n/**\n * Create a new instance with the same options as the current one.\n *\n * @example\n * ```js\n * var redis = new Redis(6380);\n * var anotherRedis = redis.duplicate();\n * ```\n *\n * @public\n */\nRedis.prototype.duplicate = function (override) {\n    return new Redis(Object.assign({}, this.options, override || {}));\n};\nRedis.prototype.recoverFromFatalError = function (commandError, err, options) {\n    this.flushQueue(err, options);\n    this.silentEmit(\"error\", err);\n    this.disconnect(true);\n};\nRedis.prototype.handleReconnection = function handleReconnection(err, item) {\n    var needReconnect = false;\n    if (this.options.reconnectOnError) {\n        needReconnect = this.options.reconnectOnError(err);\n    }\n    switch (needReconnect) {\n        case 1:\n        case true:\n            if (this.status !== \"reconnecting\") {\n                this.disconnect(true);\n            }\n            item.command.reject(err);\n            break;\n        case 2:\n            if (this.status !== \"reconnecting\") {\n                this.disconnect(true);\n            }\n            if (this.condition.select !== item.select &&\n                item.command.name !== \"select\") {\n                this.select(item.select);\n            }\n            this.sendCommand(item.command);\n            break;\n        default:\n            item.command.reject(err);\n    }\n};\n/**\n * Flush offline queue and command queue with error.\n *\n * @param {Error} error - The error object to send to the commands\n * @param {object} options\n * @private\n */\nRedis.prototype.flushQueue = function (error, options) {\n    options = lodash_1.defaults({}, options, {\n        offlineQueue: true,\n        commandQueue: true\n    });\n    var item;\n    if (options.offlineQueue) {\n        while (this.offlineQueue.length > 0) {\n            item = this.offlineQueue.shift();\n            item.command.reject(error);\n        }\n    }\n    if (options.commandQueue) {\n        if (this.commandQueue.length > 0) {\n            if (this.stream) {\n                this.stream.removeAllListeners(\"data\");\n            }\n            while (this.commandQueue.length > 0) {\n                item = this.commandQueue.shift();\n                item.command.reject(error);\n            }\n        }\n    }\n};\n/**\n * Check whether Redis has finished loading the persistent data and is able to\n * process commands.\n *\n * @param {Function} callback\n * @private\n */\nRedis.prototype._readyCheck = function (callback) {\n    var _this = this;\n    this.info(function (err, res) {\n        if (err) {\n            return callback(err);\n        }\n        if (typeof res !== \"string\") {\n            return callback(null, res);\n        }\n        var info = {};\n        var lines = res.split(\"\\r\\n\");\n        for (var i = 0; i < lines.length; ++i) {\n            var parts = lines[i].split(\":\");\n            if (parts[1]) {\n                info[parts[0]] = parts[1];\n            }\n        }\n        if (!info.loading || info.loading === \"0\") {\n            callback(null, info);\n        }\n        else {\n            var loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n            var retryTime = _this.options.maxLoadingRetryTime &&\n                _this.options.maxLoadingRetryTime < loadingEtaMs\n                ? _this.options.maxLoadingRetryTime\n                : loadingEtaMs;\n            debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n            setTimeout(function () {\n                _this._readyCheck(callback);\n            }, retryTime);\n        }\n    });\n};\n/**\n * Emit only when there's at least one listener.\n *\n * @param {string} eventName - Event to emit\n * @param {...*} arguments - Arguments\n * @return {boolean} Returns true if event had listeners, false otherwise.\n * @private\n */\nRedis.prototype.silentEmit = function (eventName) {\n    var error;\n    if (eventName === \"error\") {\n        error = arguments[1];\n        if (this.status === \"end\") {\n            return;\n        }\n        if (this.manuallyClosing) {\n            // ignore connection related errors when manually disconnecting\n            if (error instanceof Error &&\n                (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||\n                    // @ts-ignore\n                    error.syscall === \"connect\" ||\n                    // @ts-ignore\n                    error.syscall === \"read\")) {\n                return;\n            }\n        }\n    }\n    if (this.listeners(eventName).length > 0) {\n        return this.emit.apply(this, arguments);\n    }\n    if (error && error instanceof Error) {\n        console.error(\"[ioredis] Unhandled error event:\", error.stack);\n    }\n    return false;\n};\n/**\n * Listen for all requests received by the server in real time.\n *\n * This command will create a new connection to Redis and send a\n * MONITOR command via the new connection in order to avoid disturbing\n * the current connection.\n *\n * @param {function} [callback] The callback function. If omit, a promise will be returned.\n * @example\n * ```js\n * var redis = new Redis();\n * redis.monitor(function (err, monitor) {\n *   // Entering monitoring mode.\n *   monitor.on('monitor', function (time, args, source, database) {\n *     console.log(time + \": \" + util.inspect(args));\n *   });\n * });\n *\n * // supports promise as well as other commands\n * redis.monitor().then(function (monitor) {\n *   monitor.on('monitor', function (time, args, source, database) {\n *     console.log(time + \": \" + util.inspect(args));\n *   });\n * });\n * ```\n * @public\n */\nRedis.prototype.monitor = function (callback) {\n    var monitorInstance = this.duplicate({\n        monitor: true,\n        lazyConnect: false\n    });\n    var Promise = PromiseContainer.get();\n    return standard_as_callback_1.default(new Promise(function (resolve) {\n        monitorInstance.once(\"monitoring\", function () {\n            resolve(monitorInstance);\n        });\n    }), callback);\n};\ntransaction_1.addTransactionSupport(Redis.prototype);\n/**\n * Send a command to Redis\n *\n * This method is used internally by the `Redis#set`, `Redis#lpush` etc.\n * Most of the time you won't invoke this method directly.\n * However when you want to send a command that is not supported by ioredis yet,\n * this command will be useful.\n *\n * @method sendCommand\n * @memberOf Redis#\n * @param {Command} command - The Command instance to send.\n * @see {@link Command}\n * @example\n * ```js\n * var redis = new Redis();\n *\n * // Use callback\n * var get = new Command('get', ['foo'], 'utf8', function (err, result) {\n *   console.log(result);\n * });\n * redis.sendCommand(get);\n *\n * // Use promise\n * var set = new Command('set', ['foo', 'bar'], 'utf8');\n * set.promise.then(function (result) {\n *   console.log(result);\n * });\n * redis.sendCommand(set);\n * ```\n * @private\n */\nRedis.prototype.sendCommand = function (command, stream) {\n    if (this.status === \"wait\") {\n        this.connect().catch(lodash_1.noop);\n    }\n    if (this.status === \"end\") {\n        command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n        return command.promise;\n    }\n    if (this.condition.subscriber &&\n        !command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n        command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n        return command.promise;\n    }\n    var writable = this.status === \"ready\" ||\n        (!stream &&\n            this.status === \"connect\" &&\n            commands.exists(command.name) &&\n            commands.hasFlag(command.name, \"loading\"));\n    if (!this.stream) {\n        writable = false;\n    }\n    else if (!this.stream.writable) {\n        writable = false;\n    }\n    else if (this.stream._writableState && this.stream._writableState.ended) {\n        // https://github.com/iojs/io.js/pull/1217\n        writable = false;\n    }\n    if (!writable && !this.options.enableOfflineQueue) {\n        command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n        return command.promise;\n    }\n    if (!writable && command.name === \"quit\" && this.offlineQueue.length === 0) {\n        this.disconnect();\n        command.resolve(Buffer.from(\"OK\"));\n        return command.promise;\n    }\n    if (writable) {\n        // @ts-ignore\n        if (debug.enabled) {\n            debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n        }\n        (stream || this.stream).write(command.toWritable());\n        this.commandQueue.push({\n            command: command,\n            stream: stream,\n            select: this.condition.select\n        });\n        if (command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n            this.manuallyClosing = true;\n        }\n    }\n    else if (this.options.enableOfflineQueue) {\n        // @ts-ignore\n        if (debug.enabled) {\n            debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n        }\n        this.offlineQueue.push({\n            command: command,\n            stream: stream,\n            select: this.condition.select\n        });\n    }\n    if (command.name === \"select\" && utils_1.isInt(command.args[0])) {\n        var db = parseInt(command.args[0], 10);\n        if (this.condition.select !== db) {\n            this.condition.select = db;\n            this.emit(\"select\", db);\n            debug(\"switch to db [%d]\", this.condition.select);\n        }\n    }\n    return command.promise;\n};\n/**\n * Get description of the connection. Used for debugging.\n * @private\n */\nRedis.prototype._getDescription = function () {\n    let description;\n    if (this.options.path) {\n        description = this.options.path;\n    }\n    else if (this.stream &&\n        this.stream.remoteAddress &&\n        this.stream.remotePort) {\n        description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n    }\n    else {\n        description = this.options.host + \":\" + this.options.port;\n    }\n    if (this.options.connectionName) {\n        description += ` (${this.options.connectionName})`;\n    }\n    return description;\n};\n[\n    \"scan\",\n    \"sscan\",\n    \"hscan\",\n    \"zscan\",\n    \"scanBuffer\",\n    \"sscanBuffer\",\n    \"hscanBuffer\",\n    \"zscanBuffer\"\n].forEach(function (command) {\n    Redis.prototype[command + \"Stream\"] = function (key, options) {\n        if (command === \"scan\" || command === \"scanBuffer\") {\n            options = key;\n            key = null;\n        }\n        return new ScanStream_1.default(lodash_1.defaults({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command\n        }, options));\n    };\n});\n"]},"metadata":{},"sourceType":"script"}