{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\gamem\\\\codecademy\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar net_1 = require(\"net\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar tls_1 = require(\"tls\");\n\nvar StandaloneConnector_1 = require(\"../StandaloneConnector\");\n\nvar SentinelIterator_1 = require(\"./SentinelIterator\");\n\nexports.SentinelIterator = SentinelIterator_1.default;\n\nvar AbstractConnector_1 = require(\"../AbstractConnector\");\n\nvar redis_1 = require(\"../../redis\");\n\nvar debug = utils_1.Debug(\"SentinelConnector\");\n\nvar SentinelConnector =\n/*#__PURE__*/\nfunction (_AbstractConnector_1$) {\n  _inherits(SentinelConnector, _AbstractConnector_1$);\n\n  function SentinelConnector(options) {\n    var _this;\n\n    _classCallCheck(this, SentinelConnector);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SentinelConnector).call(this));\n    _this.options = options;\n\n    if (!_this.options.sentinels.length) {\n      throw new Error(\"Requires at least one sentinel to connect to.\");\n    }\n\n    if (!_this.options.name) {\n      throw new Error(\"Requires the name of master.\");\n    }\n\n    _this.sentinelIterator = new SentinelIterator_1.default(_this.options.sentinels);\n    return _this;\n  }\n\n  _createClass(SentinelConnector, [{\n    key: \"check\",\n    value: function check(info) {\n      var roleMatches = !info.role || this.options.role === info.role;\n\n      if (!roleMatches) {\n        debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role); // Start from the next item.\n        // Note that `reset` will move the cursor to the previous element,\n        // so we advance two steps here.\n\n        this.sentinelIterator.next();\n        this.sentinelIterator.next();\n        this.sentinelIterator.reset(true);\n      }\n\n      return roleMatches;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(eventEmitter) {\n      var _this2 = this;\n\n      this.connecting = true;\n      this.retryAttempts = 0;\n      var lastError;\n\n      var connectToNext = function connectToNext() {\n        return new Promise(function (resolve, reject) {\n          var endpoint = _this2.sentinelIterator.next();\n\n          if (endpoint.done) {\n            _this2.sentinelIterator.reset(false);\n\n            var retryDelay = typeof _this2.options.sentinelRetryStrategy === \"function\" ? _this2.options.sentinelRetryStrategy(++_this2.retryAttempts) : null;\n            var errorMsg = typeof retryDelay !== \"number\" ? \"All sentinels are unreachable and retry is disabled.\" : \"All sentinels are unreachable. Retrying from scratch after \".concat(retryDelay, \"ms.\");\n\n            if (lastError) {\n              errorMsg += \" Last error: \".concat(lastError.message);\n            }\n\n            debug(errorMsg);\n            var error = new Error(errorMsg);\n\n            if (typeof retryDelay === \"number\") {\n              setTimeout(function () {\n                resolve(connectToNext());\n              }, retryDelay);\n              eventEmitter(\"error\", error);\n            } else {\n              reject(error);\n            }\n\n            return;\n          }\n\n          _this2.resolve(endpoint.value, function (err, resolved) {\n            if (!_this2.connecting) {\n              reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n              return;\n            }\n\n            if (resolved) {\n              debug(\"resolved: %s:%s\", resolved.host, resolved.port);\n\n              if (_this2.options.enableTLSForSentinelMode && _this2.options.tls) {\n                Object.assign(resolved, _this2.options.tls);\n                _this2.stream = tls_1.connect(resolved);\n              } else {\n                _this2.stream = net_1.createConnection(resolved);\n              }\n\n              _this2.sentinelIterator.reset(true);\n\n              resolve(_this2.stream);\n            } else {\n              var endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n\n              var _errorMsg = err ? \"failed to connect to sentinel \" + endpointAddress + \" because \" + err.message : \"connected to sentinel \" + endpointAddress + \" successfully, but got an invalid reply: \" + resolved;\n\n              debug(_errorMsg);\n              eventEmitter(\"sentinelError\", new Error(_errorMsg));\n\n              if (err) {\n                lastError = err;\n              }\n\n              resolve(connectToNext());\n            }\n          });\n        });\n      };\n\n      return connectToNext();\n    }\n  }, {\n    key: \"updateSentinels\",\n    value: function updateSentinels(client, callback) {\n      var _this3 = this;\n\n      if (!this.options.updateSentinels) {\n        return callback(null);\n      }\n\n      client.sentinel(\"sentinels\", this.options.name, function (err, result) {\n        if (err) {\n          client.disconnect();\n          return callback(err);\n        }\n\n        if (!Array.isArray(result)) {\n          return callback(null);\n        }\n\n        result.map(utils_1.packObject).forEach(function (sentinel) {\n          var flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n\n          if (flags.indexOf(\"disconnected\") === -1 && sentinel.ip && sentinel.port) {\n            var endpoint = _this3.sentinelNatResolve(addressResponseToAddress(sentinel));\n\n            if (_this3.sentinelIterator.add(endpoint)) {\n              debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n            }\n          }\n        });\n        debug(\"Updated internal sentinels: %s\", _this3.sentinelIterator);\n        callback(null);\n      });\n    }\n  }, {\n    key: \"resolveMaster\",\n    value: function resolveMaster(client, callback) {\n      var _this4 = this;\n\n      client.sentinel(\"get-master-addr-by-name\", this.options.name, function (err, result) {\n        if (err) {\n          client.disconnect();\n          return callback(err);\n        }\n\n        _this4.updateSentinels(client, function (err) {\n          client.disconnect();\n\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, _this4.sentinelNatResolve(Array.isArray(result) ? {\n            host: result[0],\n            port: Number(result[1])\n          } : null));\n        });\n      });\n    }\n  }, {\n    key: \"resolveSlave\",\n    value: function resolveSlave(client, callback) {\n      var _this5 = this;\n\n      client.sentinel(\"slaves\", this.options.name, function (err, result) {\n        client.disconnect();\n\n        if (err) {\n          return callback(err);\n        }\n\n        if (!Array.isArray(result)) {\n          return callback(null, null);\n        }\n\n        var availableSlaves = result.map(utils_1.packObject).filter(function (slave) {\n          return slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/);\n        });\n        callback(null, _this5.sentinelNatResolve(selectPreferredSentinel(availableSlaves, _this5.options.preferredSlaves)));\n      });\n    }\n  }, {\n    key: \"sentinelNatResolve\",\n    value: function sentinelNatResolve(item) {\n      if (!item || !this.options.natMap) return item;\n      return this.options.natMap[\"\".concat(item.host, \":\").concat(item.port)] || item;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(endpoint, callback) {\n      var client = new redis_1.default({\n        port: endpoint.port || 26379,\n        host: endpoint.host,\n        password: this.options.sentinelPassword || null,\n        family: endpoint.family || (StandaloneConnector_1.isIIpcConnectionOptions(this.options) ? undefined : this.options.family),\n        tls: this.options.sentinelTLS,\n        retryStrategy: null,\n        enableReadyCheck: false,\n        connectTimeout: this.options.connectTimeout,\n        dropBufferSupport: true\n      }); // ignore the errors since resolve* methods will handle them\n\n      client.on(\"error\", noop);\n\n      if (this.options.role === \"slave\") {\n        this.resolveSlave(client, callback);\n      } else {\n        this.resolveMaster(client, callback);\n      }\n    }\n  }]);\n\n  return SentinelConnector;\n}(AbstractConnector_1.default);\n\nexports.default = SentinelConnector;\n\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n  if (availableSlaves.length === 0) {\n    return null;\n  }\n\n  var selectedSlave;\n\n  if (typeof preferredSlaves === \"function\") {\n    selectedSlave = preferredSlaves(availableSlaves);\n  } else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n    var preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves]; // sort by priority\n\n    preferredSlavesArray.sort(function (a, b) {\n      // default the priority to 1\n      if (!a.prio) {\n        a.prio = 1;\n      }\n\n      if (!b.prio) {\n        b.prio = 1;\n      } // lowest priority first\n\n\n      if (a.prio < b.prio) {\n        return -1;\n      }\n\n      if (a.prio > b.prio) {\n        return 1;\n      }\n\n      return 0;\n    }); // loop over preferred slaves and return the first match\n\n    for (var p = 0; p < preferredSlavesArray.length; p++) {\n      for (var a = 0; a < availableSlaves.length; a++) {\n        var slave = availableSlaves[a];\n\n        if (slave.ip === preferredSlavesArray[p].ip) {\n          if (slave.port === preferredSlavesArray[p].port) {\n            selectedSlave = slave;\n            break;\n          }\n        }\n      }\n\n      if (selectedSlave) {\n        break;\n      }\n    }\n  } // if none of the preferred slaves are available, a random available slave is returned\n\n\n  if (!selectedSlave) {\n    selectedSlave = utils_1.sample(availableSlaves);\n  }\n\n  return addressResponseToAddress(selectedSlave);\n}\n\nfunction addressResponseToAddress(input) {\n  return {\n    host: input.ip,\n    port: Number(input.port)\n  };\n}\n\nfunction noop() {}","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/connectors/SentinelConnector/index.js"],"names":["Object","defineProperty","exports","value","net_1","require","utils_1","tls_1","StandaloneConnector_1","SentinelIterator_1","SentinelIterator","default","AbstractConnector_1","redis_1","debug","Debug","SentinelConnector","options","sentinels","length","Error","name","sentinelIterator","info","roleMatches","role","next","reset","eventEmitter","connecting","retryAttempts","lastError","connectToNext","Promise","resolve","reject","endpoint","done","retryDelay","sentinelRetryStrategy","errorMsg","message","error","setTimeout","err","resolved","CONNECTION_CLOSED_ERROR_MSG","host","port","enableTLSForSentinelMode","tls","assign","stream","connect","createConnection","endpointAddress","client","callback","updateSentinels","sentinel","result","disconnect","Array","isArray","map","packObject","forEach","flags","split","indexOf","ip","sentinelNatResolve","addressResponseToAddress","add","Number","availableSlaves","filter","slave","match","selectPreferredSentinel","preferredSlaves","item","natMap","password","sentinelPassword","family","isIIpcConnectionOptions","undefined","sentinelTLS","retryStrategy","enableReadyCheck","connectTimeout","dropBufferSupport","on","noop","resolveSlave","resolveMaster","selectedSlave","preferredSlavesArray","sort","a","b","prio","p","sample","input"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = require(\"net\");\nconst utils_1 = require(\"../../utils\");\nconst tls_1 = require(\"tls\");\nconst StandaloneConnector_1 = require(\"../StandaloneConnector\");\nconst SentinelIterator_1 = require(\"./SentinelIterator\");\nexports.SentinelIterator = SentinelIterator_1.default;\nconst AbstractConnector_1 = require(\"../AbstractConnector\");\nconst redis_1 = require(\"../../redis\");\nconst debug = utils_1.Debug(\"SentinelConnector\");\nclass SentinelConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super();\n        this.options = options;\n        if (!this.options.sentinels.length) {\n            throw new Error(\"Requires at least one sentinel to connect to.\");\n        }\n        if (!this.options.name) {\n            throw new Error(\"Requires the name of master.\");\n        }\n        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n    }\n    check(info) {\n        const roleMatches = !info.role || this.options.role === info.role;\n        if (!roleMatches) {\n            debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role);\n            // Start from the next item.\n            // Note that `reset` will move the cursor to the previous element,\n            // so we advance two steps here.\n            this.sentinelIterator.next();\n            this.sentinelIterator.next();\n            this.sentinelIterator.reset(true);\n        }\n        return roleMatches;\n    }\n    connect(eventEmitter) {\n        this.connecting = true;\n        this.retryAttempts = 0;\n        let lastError;\n        const connectToNext = () => new Promise((resolve, reject) => {\n            const endpoint = this.sentinelIterator.next();\n            if (endpoint.done) {\n                this.sentinelIterator.reset(false);\n                const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\"\n                    ? this.options.sentinelRetryStrategy(++this.retryAttempts)\n                    : null;\n                let errorMsg = typeof retryDelay !== \"number\"\n                    ? \"All sentinels are unreachable and retry is disabled.\"\n                    : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n                if (lastError) {\n                    errorMsg += ` Last error: ${lastError.message}`;\n                }\n                debug(errorMsg);\n                const error = new Error(errorMsg);\n                if (typeof retryDelay === \"number\") {\n                    setTimeout(() => {\n                        resolve(connectToNext());\n                    }, retryDelay);\n                    eventEmitter(\"error\", error);\n                }\n                else {\n                    reject(error);\n                }\n                return;\n            }\n            this.resolve(endpoint.value, (err, resolved) => {\n                if (!this.connecting) {\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                    return;\n                }\n                if (resolved) {\n                    debug(\"resolved: %s:%s\", resolved.host, resolved.port);\n                    if (this.options.enableTLSForSentinelMode && this.options.tls) {\n                        Object.assign(resolved, this.options.tls);\n                        this.stream = tls_1.connect(resolved);\n                    }\n                    else {\n                        this.stream = net_1.createConnection(resolved);\n                    }\n                    this.sentinelIterator.reset(true);\n                    resolve(this.stream);\n                }\n                else {\n                    const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n                    const errorMsg = err\n                        ? \"failed to connect to sentinel \" +\n                            endpointAddress +\n                            \" because \" +\n                            err.message\n                        : \"connected to sentinel \" +\n                            endpointAddress +\n                            \" successfully, but got an invalid reply: \" +\n                            resolved;\n                    debug(errorMsg);\n                    eventEmitter(\"sentinelError\", new Error(errorMsg));\n                    if (err) {\n                        lastError = err;\n                    }\n                    resolve(connectToNext());\n                }\n            });\n        });\n        return connectToNext();\n    }\n    updateSentinels(client, callback) {\n        if (!this.options.updateSentinels) {\n            return callback(null);\n        }\n        client.sentinel(\"sentinels\", this.options.name, (err, result) => {\n            if (err) {\n                client.disconnect();\n                return callback(err);\n            }\n            if (!Array.isArray(result)) {\n                return callback(null);\n            }\n            result\n                .map(utils_1.packObject)\n                .forEach(sentinel => {\n                const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n                if (flags.indexOf(\"disconnected\") === -1 &&\n                    sentinel.ip &&\n                    sentinel.port) {\n                    const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n                    if (this.sentinelIterator.add(endpoint)) {\n                        debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n                    }\n                }\n            });\n            debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n            callback(null);\n        });\n    }\n    resolveMaster(client, callback) {\n        client.sentinel(\"get-master-addr-by-name\", this.options.name, (err, result) => {\n            if (err) {\n                client.disconnect();\n                return callback(err);\n            }\n            this.updateSentinels(client, err => {\n                client.disconnect();\n                if (err) {\n                    return callback(err);\n                }\n                callback(null, this.sentinelNatResolve(Array.isArray(result)\n                    ? { host: result[0], port: Number(result[1]) }\n                    : null));\n            });\n        });\n    }\n    resolveSlave(client, callback) {\n        client.sentinel(\"slaves\", this.options.name, (err, result) => {\n            client.disconnect();\n            if (err) {\n                return callback(err);\n            }\n            if (!Array.isArray(result)) {\n                return callback(null, null);\n            }\n            const availableSlaves = result\n                .map(utils_1.packObject)\n                .filter(slave => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n            callback(null, this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves)));\n        });\n    }\n    sentinelNatResolve(item) {\n        if (!item || !this.options.natMap)\n            return item;\n        return this.options.natMap[`${item.host}:${item.port}`] || item;\n    }\n    resolve(endpoint, callback) {\n        var client = new redis_1.default({\n            port: endpoint.port || 26379,\n            host: endpoint.host,\n            password: this.options.sentinelPassword || null,\n            family: endpoint.family ||\n                (StandaloneConnector_1.isIIpcConnectionOptions(this.options)\n                    ? undefined\n                    : this.options.family),\n            tls: this.options.sentinelTLS,\n            retryStrategy: null,\n            enableReadyCheck: false,\n            connectTimeout: this.options.connectTimeout,\n            dropBufferSupport: true\n        });\n        // ignore the errors since resolve* methods will handle them\n        client.on(\"error\", noop);\n        if (this.options.role === \"slave\") {\n            this.resolveSlave(client, callback);\n        }\n        else {\n            this.resolveMaster(client, callback);\n        }\n    }\n}\nexports.default = SentinelConnector;\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n    if (availableSlaves.length === 0) {\n        return null;\n    }\n    let selectedSlave;\n    if (typeof preferredSlaves === \"function\") {\n        selectedSlave = preferredSlaves(availableSlaves);\n    }\n    else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n        const preferredSlavesArray = Array.isArray(preferredSlaves)\n            ? preferredSlaves\n            : [preferredSlaves];\n        // sort by priority\n        preferredSlavesArray.sort((a, b) => {\n            // default the priority to 1\n            if (!a.prio) {\n                a.prio = 1;\n            }\n            if (!b.prio) {\n                b.prio = 1;\n            }\n            // lowest priority first\n            if (a.prio < b.prio) {\n                return -1;\n            }\n            if (a.prio > b.prio) {\n                return 1;\n            }\n            return 0;\n        });\n        // loop over preferred slaves and return the first match\n        for (let p = 0; p < preferredSlavesArray.length; p++) {\n            for (let a = 0; a < availableSlaves.length; a++) {\n                const slave = availableSlaves[a];\n                if (slave.ip === preferredSlavesArray[p].ip) {\n                    if (slave.port === preferredSlavesArray[p].port) {\n                        selectedSlave = slave;\n                        break;\n                    }\n                }\n            }\n            if (selectedSlave) {\n                break;\n            }\n        }\n    }\n    // if none of the preferred slaves are available, a random available slave is returned\n    if (!selectedSlave) {\n        selectedSlave = utils_1.sample(availableSlaves);\n    }\n    return addressResponseToAddress(selectedSlave);\n}\nfunction addressResponseToAddress(input) {\n    return { host: input.ip, port: Number(input.port) };\n}\nfunction noop() { }\n"]},"metadata":{},"sourceType":"script"}