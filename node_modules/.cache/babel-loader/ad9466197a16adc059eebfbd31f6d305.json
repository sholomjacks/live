{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst command_1 = require(\"./command\");\n\nconst utils_1 = require(\"./utils\");\n\nconst RedisParser = require(\"redis-parser\");\n\nconst SubscriptionSet_1 = require(\"./SubscriptionSet\");\n\nconst debug = utils_1.Debug(\"dataHandler\");\n\nclass DataHandler {\n  constructor(redis, parserOptions) {\n    this.redis = redis;\n    const parser = new RedisParser({\n      stringNumbers: parserOptions.stringNumbers,\n      returnBuffers: !parserOptions.dropBufferSupport,\n      returnError: err => {\n        this.returnError(err);\n      },\n      returnFatalError: err => {\n        this.returnFatalError(err);\n      },\n      returnReply: reply => {\n        this.returnReply(reply);\n      }\n    });\n    redis.stream.on(\"data\", data => {\n      parser.execute(data);\n    });\n  }\n\n  returnFatalError(err) {\n    err.message += \". Please report this.\";\n    this.redis.recoverFromFatalError(err, err, {\n      offlineQueue: false\n    });\n  }\n\n  returnError(err) {\n    const item = this.shiftCommand(err);\n\n    if (!item) {\n      return;\n    }\n\n    err.command = {\n      name: item.command.name,\n      args: item.command.args\n    };\n    this.redis.handleReconnection(err, item);\n  }\n\n  returnReply(reply) {\n    if (this.handleMonitorReply(reply)) {\n      return;\n    }\n\n    if (this.handleSubscriberReply(reply)) {\n      return;\n    }\n\n    const item = this.shiftCommand(reply);\n\n    if (!item) {\n      return;\n    }\n\n    if (command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", item.command.name)) {\n      this.redis.condition.subscriber = new SubscriptionSet_1.default();\n      this.redis.condition.subscriber.add(item.command.name, reply[1].toString());\n\n      if (!fillSubCommand(item.command, reply[2])) {\n        this.redis.commandQueue.unshift(item);\n      }\n    } else if (command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", item.command.name)) {\n      if (!fillUnsubCommand(item.command, reply[2])) {\n        this.redis.commandQueue.unshift(item);\n      }\n    } else {\n      item.command.resolve(reply);\n    }\n  }\n\n  handleSubscriberReply(reply) {\n    if (!this.redis.condition.subscriber) {\n      return false;\n    }\n\n    const replyType = Array.isArray(reply) ? reply[0].toString() : null;\n    debug('receive reply \"%s\" in subscriber mode', replyType);\n\n    switch (replyType) {\n      case \"message\":\n        if (this.redis.listeners(\"message\").length > 0) {\n          // Check if there're listeners to avoid unnecessary `toString()`.\n          this.redis.emit(\"message\", reply[1].toString(), reply[2].toString());\n        }\n\n        this.redis.emit(\"messageBuffer\", reply[1], reply[2]);\n        break;\n\n      case \"pmessage\":\n        {\n          const pattern = reply[1].toString();\n\n          if (this.redis.listeners(\"pmessage\").length > 0) {\n            this.redis.emit(\"pmessage\", pattern, reply[2].toString(), reply[3].toString());\n          }\n\n          this.redis.emit(\"pmessageBuffer\", pattern, reply[2], reply[3]);\n          break;\n        }\n\n      case \"subscribe\":\n      case \"psubscribe\":\n        {\n          const channel = reply[1].toString();\n          this.redis.condition.subscriber.add(replyType, channel);\n          const item = this.shiftCommand(reply);\n\n          if (!item) {\n            return;\n          }\n\n          if (!fillSubCommand(item.command, reply[2])) {\n            this.redis.commandQueue.unshift(item);\n          }\n\n          break;\n        }\n\n      case \"unsubscribe\":\n      case \"punsubscribe\":\n        {\n          const channel = reply[1] ? reply[1].toString() : null;\n\n          if (channel) {\n            this.redis.condition.subscriber.del(replyType, channel);\n          }\n\n          const count = reply[2];\n\n          if (count === 0) {\n            this.redis.condition.subscriber = false;\n          }\n\n          const item = this.shiftCommand(reply);\n\n          if (!item) {\n            return;\n          }\n\n          if (!fillUnsubCommand(item.command, count)) {\n            this.redis.commandQueue.unshift(item);\n          }\n\n          break;\n        }\n\n      default:\n        {\n          const item = this.shiftCommand(reply);\n\n          if (!item) {\n            return;\n          }\n\n          item.command.resolve(reply);\n        }\n    }\n\n    return true;\n  }\n\n  handleMonitorReply(reply) {\n    if (this.redis.status !== \"monitoring\") {\n      return false;\n    }\n\n    const replyStr = reply.toString();\n\n    if (replyStr === \"OK\") {\n      // Valid commands in the monitoring mode are AUTH and MONITOR,\n      // both of which always reply with 'OK'.\n      // So if we got an 'OK', we can make certain that\n      // the reply is made to AUTH & MONITO.\n      return false;\n    } // Since commands sent in the monitoring mode will trigger an exception,\n    // any replies we received in the monitoring mode should consider to be\n    // realtime monitor data instead of result of commands.\n\n\n    const len = replyStr.indexOf(\" \");\n    const timestamp = replyStr.slice(0, len);\n    const argindex = replyStr.indexOf('\"');\n    const args = replyStr.slice(argindex + 1, -1).split('\" \"').map(elem => elem.replace(/\\\\\"/g, '\"'));\n    const dbAndSource = replyStr.slice(len + 2, argindex - 2).split(\" \");\n    this.redis.emit(\"monitor\", timestamp, args, dbAndSource[1], dbAndSource[0]);\n    return true;\n  }\n\n  shiftCommand(reply) {\n    const item = this.redis.commandQueue.shift();\n\n    if (!item) {\n      const message = \"Command queue state error. If you can reproduce this, please report it.\";\n      const error = new Error(message + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));\n      this.redis.emit(\"error\", error);\n      return null;\n    }\n\n    return item;\n  }\n\n}\n\nexports.default = DataHandler;\n\nfunction fillSubCommand(command, count) {\n  // TODO: use WeakMap here\n  if (typeof command.remainReplies === \"undefined\") {\n    command.remainReplies = command.args.length;\n  }\n\n  if (--command.remainReplies === 0) {\n    command.resolve(count);\n    return true;\n  }\n\n  return false;\n}\n\nfunction fillUnsubCommand(command, count) {\n  if (typeof command.remainReplies === \"undefined\") {\n    command.remainReplies = command.args.length;\n  }\n\n  if (command.remainReplies === 0) {\n    if (count === 0) {\n      command.resolve(count);\n      return true;\n    }\n\n    return false;\n  }\n\n  if (--command.remainReplies === 0) {\n    command.resolve(count);\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/DataHandler.js"],"names":["Object","defineProperty","exports","value","command_1","require","utils_1","RedisParser","SubscriptionSet_1","debug","Debug","DataHandler","constructor","redis","parserOptions","parser","stringNumbers","returnBuffers","dropBufferSupport","returnError","err","returnFatalError","returnReply","reply","stream","on","data","execute","message","recoverFromFatalError","offlineQueue","item","shiftCommand","command","name","args","handleReconnection","handleMonitorReply","handleSubscriberReply","default","checkFlag","condition","subscriber","add","toString","fillSubCommand","commandQueue","unshift","fillUnsubCommand","resolve","replyType","Array","isArray","listeners","length","emit","pattern","channel","del","count","status","replyStr","len","indexOf","timestamp","slice","argindex","split","map","elem","replace","dbAndSource","shift","error","Error","remainReplies"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst command_1 = require(\"./command\");\nconst utils_1 = require(\"./utils\");\nconst RedisParser = require(\"redis-parser\");\nconst SubscriptionSet_1 = require(\"./SubscriptionSet\");\nconst debug = utils_1.Debug(\"dataHandler\");\nclass DataHandler {\n    constructor(redis, parserOptions) {\n        this.redis = redis;\n        const parser = new RedisParser({\n            stringNumbers: parserOptions.stringNumbers,\n            returnBuffers: !parserOptions.dropBufferSupport,\n            returnError: (err) => {\n                this.returnError(err);\n            },\n            returnFatalError: (err) => {\n                this.returnFatalError(err);\n            },\n            returnReply: (reply) => {\n                this.returnReply(reply);\n            }\n        });\n        redis.stream.on(\"data\", data => {\n            parser.execute(data);\n        });\n    }\n    returnFatalError(err) {\n        err.message += \". Please report this.\";\n        this.redis.recoverFromFatalError(err, err, { offlineQueue: false });\n    }\n    returnError(err) {\n        const item = this.shiftCommand(err);\n        if (!item) {\n            return;\n        }\n        err.command = {\n            name: item.command.name,\n            args: item.command.args\n        };\n        this.redis.handleReconnection(err, item);\n    }\n    returnReply(reply) {\n        if (this.handleMonitorReply(reply)) {\n            return;\n        }\n        if (this.handleSubscriberReply(reply)) {\n            return;\n        }\n        const item = this.shiftCommand(reply);\n        if (!item) {\n            return;\n        }\n        if (command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", item.command.name)) {\n            this.redis.condition.subscriber = new SubscriptionSet_1.default();\n            this.redis.condition.subscriber.add(item.command.name, reply[1].toString());\n            if (!fillSubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        }\n        else if (command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", item.command.name)) {\n            if (!fillUnsubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        }\n        else {\n            item.command.resolve(reply);\n        }\n    }\n    handleSubscriberReply(reply) {\n        if (!this.redis.condition.subscriber) {\n            return false;\n        }\n        const replyType = Array.isArray(reply) ? reply[0].toString() : null;\n        debug('receive reply \"%s\" in subscriber mode', replyType);\n        switch (replyType) {\n            case \"message\":\n                if (this.redis.listeners(\"message\").length > 0) {\n                    // Check if there're listeners to avoid unnecessary `toString()`.\n                    this.redis.emit(\"message\", reply[1].toString(), reply[2].toString());\n                }\n                this.redis.emit(\"messageBuffer\", reply[1], reply[2]);\n                break;\n            case \"pmessage\": {\n                const pattern = reply[1].toString();\n                if (this.redis.listeners(\"pmessage\").length > 0) {\n                    this.redis.emit(\"pmessage\", pattern, reply[2].toString(), reply[3].toString());\n                }\n                this.redis.emit(\"pmessageBuffer\", pattern, reply[2], reply[3]);\n                break;\n            }\n            case \"subscribe\":\n            case \"psubscribe\": {\n                const channel = reply[1].toString();\n                this.redis.condition.subscriber.add(replyType, channel);\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                if (!fillSubCommand(item.command, reply[2])) {\n                    this.redis.commandQueue.unshift(item);\n                }\n                break;\n            }\n            case \"unsubscribe\":\n            case \"punsubscribe\": {\n                const channel = reply[1] ? reply[1].toString() : null;\n                if (channel) {\n                    this.redis.condition.subscriber.del(replyType, channel);\n                }\n                const count = reply[2];\n                if (count === 0) {\n                    this.redis.condition.subscriber = false;\n                }\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                if (!fillUnsubCommand(item.command, count)) {\n                    this.redis.commandQueue.unshift(item);\n                }\n                break;\n            }\n            default: {\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                item.command.resolve(reply);\n            }\n        }\n        return true;\n    }\n    handleMonitorReply(reply) {\n        if (this.redis.status !== \"monitoring\") {\n            return false;\n        }\n        const replyStr = reply.toString();\n        if (replyStr === \"OK\") {\n            // Valid commands in the monitoring mode are AUTH and MONITOR,\n            // both of which always reply with 'OK'.\n            // So if we got an 'OK', we can make certain that\n            // the reply is made to AUTH & MONITO.\n            return false;\n        }\n        // Since commands sent in the monitoring mode will trigger an exception,\n        // any replies we received in the monitoring mode should consider to be\n        // realtime monitor data instead of result of commands.\n        const len = replyStr.indexOf(\" \");\n        const timestamp = replyStr.slice(0, len);\n        const argindex = replyStr.indexOf('\"');\n        const args = replyStr\n            .slice(argindex + 1, -1)\n            .split('\" \"')\n            .map(elem => elem.replace(/\\\\\"/g, '\"'));\n        const dbAndSource = replyStr.slice(len + 2, argindex - 2).split(\" \");\n        this.redis.emit(\"monitor\", timestamp, args, dbAndSource[1], dbAndSource[0]);\n        return true;\n    }\n    shiftCommand(reply) {\n        const item = this.redis.commandQueue.shift();\n        if (!item) {\n            const message = \"Command queue state error. If you can reproduce this, please report it.\";\n            const error = new Error(message +\n                (reply instanceof Error\n                    ? ` Last error: ${reply.message}`\n                    : ` Last reply: ${reply.toString()}`));\n            this.redis.emit(\"error\", error);\n            return null;\n        }\n        return item;\n    }\n}\nexports.default = DataHandler;\nfunction fillSubCommand(command, count) {\n    // TODO: use WeakMap here\n    if (typeof command.remainReplies === \"undefined\") {\n        command.remainReplies = command.args.length;\n    }\n    if (--command.remainReplies === 0) {\n        command.resolve(count);\n        return true;\n    }\n    return false;\n}\nfunction fillUnsubCommand(command, count) {\n    if (typeof command.remainReplies === \"undefined\") {\n        command.remainReplies = command.args.length;\n    }\n    if (command.remainReplies === 0) {\n        if (count === 0) {\n            command.resolve(count);\n            return true;\n        }\n        return false;\n    }\n    if (--command.remainReplies === 0) {\n        command.resolve(count);\n        return true;\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}