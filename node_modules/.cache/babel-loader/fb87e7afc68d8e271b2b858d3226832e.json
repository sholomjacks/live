{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst net_1 = require(\"net\");\n\nconst tls_1 = require(\"tls\");\n\nconst utils_1 = require(\"../utils\");\n\nconst AbstractConnector_1 = require(\"./AbstractConnector\");\n\nfunction isIIpcConnectionOptions(value) {\n  return value.path;\n}\n\nexports.isIIpcConnectionOptions = isIIpcConnectionOptions;\n\nclass StandaloneConnector extends AbstractConnector_1.default {\n  constructor(options) {\n    super();\n    this.options = options;\n  }\n\n  connect(_) {\n    const {\n      options\n    } = this;\n    this.connecting = true;\n    let connectionOptions;\n\n    if (isIIpcConnectionOptions(options)) {\n      connectionOptions = {\n        path: options.path\n      };\n    } else {\n      connectionOptions = {};\n\n      if (options.port != null) {\n        connectionOptions.port = options.port;\n      }\n\n      if (options.host != null) {\n        connectionOptions.host = options.host;\n      }\n\n      if (options.family != null) {\n        connectionOptions.family = options.family;\n      }\n    }\n\n    if (options.tls) {\n      Object.assign(connectionOptions, options.tls);\n    } // TODO:\n    // We use native Promise here since other Promise\n    // implementation may use different schedulers that\n    // cause issue when the stream is resolved in the\n    // next tick.\n    // Should use the provided promise in the next major\n    // version and do not connect before resolved.\n\n\n    return new Promise((resolve, reject) => {\n      process.nextTick(() => {\n        if (!this.connecting) {\n          reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n          return;\n        }\n\n        try {\n          if (options.tls) {\n            this.stream = tls_1.connect(connectionOptions);\n          } else {\n            this.stream = net_1.createConnection(connectionOptions);\n          }\n        } catch (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(this.stream);\n      });\n    });\n  }\n\n}\n\nexports.default = StandaloneConnector;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/connectors/StandaloneConnector.js"],"names":["Object","defineProperty","exports","value","net_1","require","tls_1","utils_1","AbstractConnector_1","isIIpcConnectionOptions","path","StandaloneConnector","default","constructor","options","connect","_","connecting","connectionOptions","port","host","family","tls","assign","Promise","resolve","reject","process","nextTick","Error","CONNECTION_CLOSED_ERROR_MSG","stream","createConnection","err"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,KAAK,GAAGC,OAAO,CAAC,KAAD,CAArB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,KAAD,CAArB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMG,mBAAmB,GAAGH,OAAO,CAAC,qBAAD,CAAnC;;AACA,SAASI,uBAAT,CAAiCN,KAAjC,EAAwC;AACpC,SAAOA,KAAK,CAACO,IAAb;AACH;;AACDR,OAAO,CAACO,uBAAR,GAAkCA,uBAAlC;;AACA,MAAME,mBAAN,SAAkCH,mBAAmB,CAACI,OAAtD,CAA8D;AAC1DC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB;AACA,SAAKA,OAAL,GAAeA,OAAf;AACH;;AACDC,EAAAA,OAAO,CAACC,CAAD,EAAI;AACP,UAAM;AAAEF,MAAAA;AAAF,QAAc,IAApB;AACA,SAAKG,UAAL,GAAkB,IAAlB;AACA,QAAIC,iBAAJ;;AACA,QAAIT,uBAAuB,CAACK,OAAD,CAA3B,EAAsC;AAClCI,MAAAA,iBAAiB,GAAG;AAChBR,QAAAA,IAAI,EAAEI,OAAO,CAACJ;AADE,OAApB;AAGH,KAJD,MAKK;AACDQ,MAAAA,iBAAiB,GAAG,EAApB;;AACA,UAAIJ,OAAO,CAACK,IAAR,IAAgB,IAApB,EAA0B;AACtBD,QAAAA,iBAAiB,CAACC,IAAlB,GAAyBL,OAAO,CAACK,IAAjC;AACH;;AACD,UAAIL,OAAO,CAACM,IAAR,IAAgB,IAApB,EAA0B;AACtBF,QAAAA,iBAAiB,CAACE,IAAlB,GAAyBN,OAAO,CAACM,IAAjC;AACH;;AACD,UAAIN,OAAO,CAACO,MAAR,IAAkB,IAAtB,EAA4B;AACxBH,QAAAA,iBAAiB,CAACG,MAAlB,GAA2BP,OAAO,CAACO,MAAnC;AACH;AACJ;;AACD,QAAIP,OAAO,CAACQ,GAAZ,EAAiB;AACbtB,MAAAA,MAAM,CAACuB,MAAP,CAAcL,iBAAd,EAAiCJ,OAAO,CAACQ,GAAzC;AACH,KAvBM,CAwBP;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAAO,IAAIE,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpCC,MAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM;AACnB,YAAI,CAAC,KAAKX,UAAV,EAAsB;AAClBS,UAAAA,MAAM,CAAC,IAAIG,KAAJ,CAAUtB,OAAO,CAACuB,2BAAlB,CAAD,CAAN;AACA;AACH;;AACD,YAAI;AACA,cAAIhB,OAAO,CAACQ,GAAZ,EAAiB;AACb,iBAAKS,MAAL,GAAczB,KAAK,CAACS,OAAN,CAAcG,iBAAd,CAAd;AACH,WAFD,MAGK;AACD,iBAAKa,MAAL,GAAc3B,KAAK,CAAC4B,gBAAN,CAAuBd,iBAAvB,CAAd;AACH;AACJ,SAPD,CAQA,OAAOe,GAAP,EAAY;AACRP,UAAAA,MAAM,CAACO,GAAD,CAAN;AACA;AACH;;AACDR,QAAAA,OAAO,CAAC,KAAKM,MAAN,CAAP;AACH,OAlBD;AAmBH,KApBM,CAAP;AAqBH;;AAzDyD;;AA2D9D7B,OAAO,CAACU,OAAR,GAAkBD,mBAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = require(\"net\");\nconst tls_1 = require(\"tls\");\nconst utils_1 = require(\"../utils\");\nconst AbstractConnector_1 = require(\"./AbstractConnector\");\nfunction isIIpcConnectionOptions(value) {\n    return value.path;\n}\nexports.isIIpcConnectionOptions = isIIpcConnectionOptions;\nclass StandaloneConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super();\n        this.options = options;\n    }\n    connect(_) {\n        const { options } = this;\n        this.connecting = true;\n        let connectionOptions;\n        if (isIIpcConnectionOptions(options)) {\n            connectionOptions = {\n                path: options.path\n            };\n        }\n        else {\n            connectionOptions = {};\n            if (options.port != null) {\n                connectionOptions.port = options.port;\n            }\n            if (options.host != null) {\n                connectionOptions.host = options.host;\n            }\n            if (options.family != null) {\n                connectionOptions.family = options.family;\n            }\n        }\n        if (options.tls) {\n            Object.assign(connectionOptions, options.tls);\n        }\n        // TODO:\n        // We use native Promise here since other Promise\n        // implementation may use different schedulers that\n        // cause issue when the stream is resolved in the\n        // next tick.\n        // Should use the provided promise in the next major\n        // version and do not connect before resolved.\n        return new Promise((resolve, reject) => {\n            process.nextTick(() => {\n                if (!this.connecting) {\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                    return;\n                }\n                try {\n                    if (options.tls) {\n                        this.stream = tls_1.connect(connectionOptions);\n                    }\n                    else {\n                        this.stream = net_1.createConnection(connectionOptions);\n                    }\n                }\n                catch (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(this.stream);\n            });\n        });\n    }\n}\nexports.default = StandaloneConnector;\n"]},"metadata":{},"sourceType":"script"}