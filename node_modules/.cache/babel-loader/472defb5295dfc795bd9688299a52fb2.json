{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst utils_1 = require(\"../utils\");\n\nconst util_1 = require(\"./util\");\n\nconst redis_1 = require(\"../redis\");\n\nconst debug = utils_1.Debug(\"cluster:connectionPool\");\n\nclass ConnectionPool extends events_1.EventEmitter {\n  constructor(redisOptions) {\n    super();\n    this.redisOptions = redisOptions; // master + slave = all\n\n    this.nodes = {\n      all: {},\n      master: {},\n      slave: {}\n    };\n    this.specifiedOptions = {};\n  }\n\n  getNodes(role = \"all\") {\n    const nodes = this.nodes[role];\n    return Object.keys(nodes).map(key => nodes[key]);\n  }\n\n  getInstanceByKey(key) {\n    return this.nodes.all[key];\n  }\n\n  getSampleInstance(role) {\n    const keys = Object.keys(this.nodes[role]);\n    const sampleKey = utils_1.sample(keys);\n    return this.nodes[role][sampleKey];\n  }\n  /**\n   * Find or create a connection to the node\n   *\n   * @param {IRedisOptions} node\n   * @param {boolean} [readOnly=false]\n   * @returns {*}\n   * @memberof ConnectionPool\n   */\n\n\n  findOrCreate(node, readOnly = false) {\n    const key = util_1.getNodeKey(node);\n    readOnly = Boolean(readOnly);\n\n    if (this.specifiedOptions[key]) {\n      Object.assign(node, this.specifiedOptions[key]);\n    } else {\n      this.specifiedOptions[key] = node;\n    }\n\n    let redis;\n\n    if (this.nodes.all[key]) {\n      redis = this.nodes.all[key];\n\n      if (redis.options.readOnly !== readOnly) {\n        redis.options.readOnly = readOnly;\n        debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n        redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n\n        if (readOnly) {\n          delete this.nodes.master[key];\n          this.nodes.slave[key] = redis;\n        } else {\n          delete this.nodes.slave[key];\n          this.nodes.master[key] = redis;\n        }\n      }\n    } else {\n      debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n      redis = new redis_1.default(utils_1.defaults({\n        // Never try to reconnect when a node is lose,\n        // instead, waiting for a `MOVED` error and\n        // fetch the slots again.\n        retryStrategy: null,\n        // Offline queue should be enabled so that\n        // we don't need to wait for the `ready` event\n        // before sending commands to the node.\n        enableOfflineQueue: true,\n        readOnly: readOnly\n      }, node, this.redisOptions, {\n        lazyConnect: true\n      }));\n      this.nodes.all[key] = redis;\n      this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n      redis.once(\"end\", () => {\n        this.removeNode(key);\n        this.emit(\"-node\", redis, key);\n\n        if (!Object.keys(this.nodes.all).length) {\n          this.emit(\"drain\");\n        }\n      });\n      this.emit(\"+node\", redis, key);\n      redis.on(\"error\", function (error) {\n        this.emit(\"nodeError\", error, key);\n      });\n    }\n\n    return redis;\n  }\n  /**\n   * Remove a node from the pool.\n   */\n\n\n  removeNode(key) {\n    const {\n      nodes\n    } = this;\n\n    if (nodes.all[key]) {\n      debug(\"Remove %s from the pool\", key);\n      delete nodes.all[key];\n    }\n\n    delete nodes.master[key];\n    delete nodes.slave[key];\n  }\n  /**\n   * Reset the pool with a set of nodes.\n   * The old node will be removed.\n   *\n   * @param {(Array<string | number | object>)} nodes\n   * @memberof ConnectionPool\n   */\n\n\n  reset(nodes) {\n    debug(\"Reset with %O\", nodes);\n    const newNodes = {};\n    nodes.forEach(node => {\n      const key = util_1.getNodeKey(node); // Don't override the existing (master) node\n      // when the current one is slave.\n\n      if (!(node.readOnly && newNodes[key])) {\n        newNodes[key] = node;\n      }\n    });\n    Object.keys(this.nodes.all).forEach(key => {\n      if (!newNodes[key]) {\n        debug(\"Disconnect %s because the node does not hold any slot\", key);\n        this.nodes.all[key].disconnect();\n        this.removeNode(key);\n      }\n    });\n    Object.keys(newNodes).forEach(key => {\n      const node = newNodes[key];\n      this.findOrCreate(node, node.readOnly);\n    });\n  }\n\n}\n\nexports.default = ConnectionPool;","map":{"version":3,"sources":["C:/Users/gamem/codecademy/node_modules/ioredis/built/cluster/ConnectionPool.js"],"names":["Object","defineProperty","exports","value","events_1","require","utils_1","util_1","redis_1","debug","Debug","ConnectionPool","EventEmitter","constructor","redisOptions","nodes","all","master","slave","specifiedOptions","getNodes","role","keys","map","key","getInstanceByKey","getSampleInstance","sampleKey","sample","findOrCreate","node","readOnly","getNodeKey","Boolean","assign","redis","options","catch","noop","default","defaults","retryStrategy","enableOfflineQueue","lazyConnect","once","removeNode","emit","length","on","error","reset","newNodes","forEach","disconnect"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst utils_1 = require(\"../utils\");\nconst util_1 = require(\"./util\");\nconst redis_1 = require(\"../redis\");\nconst debug = utils_1.Debug(\"cluster:connectionPool\");\nclass ConnectionPool extends events_1.EventEmitter {\n    constructor(redisOptions) {\n        super();\n        this.redisOptions = redisOptions;\n        // master + slave = all\n        this.nodes = {\n            all: {},\n            master: {},\n            slave: {}\n        };\n        this.specifiedOptions = {};\n    }\n    getNodes(role = \"all\") {\n        const nodes = this.nodes[role];\n        return Object.keys(nodes).map(key => nodes[key]);\n    }\n    getInstanceByKey(key) {\n        return this.nodes.all[key];\n    }\n    getSampleInstance(role) {\n        const keys = Object.keys(this.nodes[role]);\n        const sampleKey = utils_1.sample(keys);\n        return this.nodes[role][sampleKey];\n    }\n    /**\n     * Find or create a connection to the node\n     *\n     * @param {IRedisOptions} node\n     * @param {boolean} [readOnly=false]\n     * @returns {*}\n     * @memberof ConnectionPool\n     */\n    findOrCreate(node, readOnly = false) {\n        const key = util_1.getNodeKey(node);\n        readOnly = Boolean(readOnly);\n        if (this.specifiedOptions[key]) {\n            Object.assign(node, this.specifiedOptions[key]);\n        }\n        else {\n            this.specifiedOptions[key] = node;\n        }\n        let redis;\n        if (this.nodes.all[key]) {\n            redis = this.nodes.all[key];\n            if (redis.options.readOnly !== readOnly) {\n                redis.options.readOnly = readOnly;\n                debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n                redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n                if (readOnly) {\n                    delete this.nodes.master[key];\n                    this.nodes.slave[key] = redis;\n                }\n                else {\n                    delete this.nodes.slave[key];\n                    this.nodes.master[key] = redis;\n                }\n            }\n        }\n        else {\n            debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n            redis = new redis_1.default(utils_1.defaults({\n                // Never try to reconnect when a node is lose,\n                // instead, waiting for a `MOVED` error and\n                // fetch the slots again.\n                retryStrategy: null,\n                // Offline queue should be enabled so that\n                // we don't need to wait for the `ready` event\n                // before sending commands to the node.\n                enableOfflineQueue: true,\n                readOnly: readOnly\n            }, node, this.redisOptions, { lazyConnect: true }));\n            this.nodes.all[key] = redis;\n            this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n            redis.once(\"end\", () => {\n                this.removeNode(key);\n                this.emit(\"-node\", redis, key);\n                if (!Object.keys(this.nodes.all).length) {\n                    this.emit(\"drain\");\n                }\n            });\n            this.emit(\"+node\", redis, key);\n            redis.on(\"error\", function (error) {\n                this.emit(\"nodeError\", error, key);\n            });\n        }\n        return redis;\n    }\n    /**\n     * Remove a node from the pool.\n     */\n    removeNode(key) {\n        const { nodes } = this;\n        if (nodes.all[key]) {\n            debug(\"Remove %s from the pool\", key);\n            delete nodes.all[key];\n        }\n        delete nodes.master[key];\n        delete nodes.slave[key];\n    }\n    /**\n     * Reset the pool with a set of nodes.\n     * The old node will be removed.\n     *\n     * @param {(Array<string | number | object>)} nodes\n     * @memberof ConnectionPool\n     */\n    reset(nodes) {\n        debug(\"Reset with %O\", nodes);\n        const newNodes = {};\n        nodes.forEach(node => {\n            const key = util_1.getNodeKey(node);\n            // Don't override the existing (master) node\n            // when the current one is slave.\n            if (!(node.readOnly && newNodes[key])) {\n                newNodes[key] = node;\n            }\n        });\n        Object.keys(this.nodes.all).forEach(key => {\n            if (!newNodes[key]) {\n                debug(\"Disconnect %s because the node does not hold any slot\", key);\n                this.nodes.all[key].disconnect();\n                this.removeNode(key);\n            }\n        });\n        Object.keys(newNodes).forEach(key => {\n            const node = newNodes[key];\n            this.findOrCreate(node, node.readOnly);\n        });\n    }\n}\nexports.default = ConnectionPool;\n"]},"metadata":{},"sourceType":"script"}