"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ramda_1 = require("ramda");
var serialize = require('serialize-javascript');
exports.is_array = function (el) { return ramda_1.type(el) === 'Array'; };
exports.is_object = function (el) { return ramda_1.type(el) === 'Object'; };
exports.is_array_or_object = function (el) { return ramda_1.type(el) === 'Array' || ramda_1.type(el) === 'Object'; };
var ensure_is_array = function (value) { return exports.is_array(value) ? value : [value]; };
exports.is_numeric_string = ramda_1.test(/^0$|^[1-9][0-9]*$/);
exports.path_to_key = function (path) { return ramda_1.type(path) === "Array" ? path.join('.') : path; };
exports.key_to_path = function (path) { return ramda_1.type(path) === "String" ? ramda_1.compose(ramda_1.map(function (el) { return exports.is_numeric_string(el) ? Number(el) : el; }), ramda_1.split('.'))(path) : path; };
exports.stringify = function (value) { return serialize(value, { ignoreFunction: true }); };
exports.parse = function (serializedJavascript) { return eval('(' + serializedJavascript + ')'); };
exports.concat_if_nonexistent = function (arr1, arr2) { return ramda_1.uniq(__spreadArrays(arr1, arr2)); };
exports.concat_with_dot = ramda_1.curry(function (a, b) { return ramda_1.compose(ramda_1.join('.'), ramda_1.reject(ramda_1.isEmpty))([a, b]); });
var json_to_path_list = function (val) {
    if (exports.is_array(val)) {
        var child_paths = ramda_1.unnest(val.map(function (child, i) {
            return json_to_path_list(child).map(function (path) { return __spreadArrays([i], path); });
        }));
        return child_paths;
    }
    if (exports.is_object(val)) {
        var child_paths = ramda_1.chain(function (key, i) {
            return json_to_path_list(val[key]).map(function (path) { return __spreadArrays([key], path); });
        })(ramda_1.keys(val));
        return child_paths;
    }
    return [[]];
};
exports.who_cares = function (changes, subscriptions) {
    return ramda_1.reduce(function (acc, val) {
        var changed_key = val;
        var new_pairs = changes.new[changed_key];
        var old_pairs = changes.old[changed_key];
        var relevant_subscription_keys = ramda_1.keys(subscriptions).filter(function (key) { return ramda_1.startsWith(key)(changed_key); });
        return ramda_1.concat(relevant_subscription_keys.map(function (watched_key) {
            var fns = ramda_1.values(subscriptions[watched_key]);
            return { watched_key: watched_key, changed_key: changed_key, new: new_pairs, old: old_pairs, fns: fns };
        }), acc);
    }, [])(ramda_1.keys(__assign(__assign({}, changes.old), changes.new)));
};
// like pathOr but doesnt return null when value is null and not undefined
exports.strict_path_or = function (default_val, val_path, obj) {
    if (val_path.length === 0) {
        return obj;
    }
    if (ramda_1.hasPath(val_path, obj)) {
        return ramda_1.path(val_path, obj);
    }
    else {
        return default_val;
    }
};
exports.json_to_pairs = function (json) {
    var path_list = json_to_path_list(json);
    return ramda_1.reduce(function (acc, val) {
        var _a;
        var redis_key = exports.path_to_key(val);
        var given_value = exports.strict_path_or(undefined, val, json);
        var redis_value = exports.is_array_or_object(given_value) ? ramda_1.keys(given_value) : given_value;
        return __assign(__assign({}, acc), (_a = {}, _a[redis_key] = redis_value, _a));
    }, {})(path_list);
};
exports.pairs_to_json = function (pairs) {
    var output = {};
    var paths = ramda_1.compose(ramda_1.map(function (key) { return ({ path: exports.key_to_path(key), val: pairs[key] }); }), ramda_1.keys)(pairs);
    paths.map(function (path_el) { return output = ramda_1.assocPath(path_el.path, path_el.val, output); });
    return output;
};
exports.map_keys = ramda_1.curry(function (fn, obj) { return ramda_1.fromPairs(ramda_1.map(ramda_1.adjust(0, fn), ramda_1.toPairs(obj))); });
exports.delete_parent_indices = function (missing_paths, data) {
    var output = ramda_1.reduce(function (acc, val) {
        var _a;
        var old_index = acc[exports.path_to_key(ramda_1.dropLast(1, val))];
        if (ramda_1.isNil(old_index))
            return acc;
        var new_index = ramda_1.without(ramda_1.toString(ramda_1.last(val)))(old_index);
        var key_to_update = exports.path_to_key(ramda_1.dropLast(1, val));
        var update_obj = __assign(__assign({}, acc), (_a = {}, _a[key_to_update] = new_index, _a));
        return update_obj;
    }, data, missing_paths);
    return output;
};
var parent_keys = function (shpath) { return shpath.length > 0 && !ramda_1.equals(shpath, ['']) ? shpath.map(function (el, i) {
    var _a;
    return (_a = {}, _a[exports.path_to_key(ramda_1.slice(0, i, shpath))] = exports.key_to_path(shpath)[i], _a);
}) : []; };
exports.get_required_indexes = function (key_list) {
    var required_indexes = ramda_1.reduce(function (acc, val) {
        var pkeys = ramda_1.compose(ramda_1.mergeAll, parent_keys, exports.key_to_path)(val);
        var left = ramda_1.map(ensure_is_array)(acc);
        var right = ramda_1.map(ensure_is_array)(pkeys);
        return ramda_1.mergeWithKey(function (k, l, r) { return exports.concat_if_nonexistent(l, r); })(left, right);
    }, {})(key_list);
    var indexes_to_add_for_given_key = function (key, required_indexes, key_list) {
        return ramda_1.mergeAll(required_indexes[key].map(function (el) {
            var _a;
            return (_a = {}, _a[el] = ramda_1.includes(exports.concat_with_dot(key, el), key_list) ? 'leaf' : 'branch', _a);
        }));
    };
    var commands = ramda_1.map(function (key) { return ['hmset', key, indexes_to_add_for_given_key(key, required_indexes, key_list)]; })(ramda_1.keys(required_indexes));
    return commands;
};
